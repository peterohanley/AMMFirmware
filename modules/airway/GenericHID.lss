
GenericHID.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000023e  00800100  00002a00  00002a94  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002a00  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000301  0080033e  0080033e  00002cd2  2**0
                  ALLOC
  3 .noinit       00000004  0080063f  0080063f  00002cd2  2**0
                  ALLOC
  4 .stab         00002784  00000000  00000000  00002cd4  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      00000910  00000000  00000000  00005458  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 000007d8  00000000  00000000  00005d68  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000cce8  00000000  00000000  00006540  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00002e32  00000000  00000000  00013228  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000053c7  00000000  00000000  0001605a  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00001604  00000000  00000000  0001b424  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000480a  00000000  00000000  0001ca28  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00007e58  00000000  00000000  00021232  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000d68  00000000  00000000  0002908a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	98 c2       	rjmp	.+1328   	; 0x532 <__ctors_end>
       2:	00 00       	nop
       4:	d0 c2       	rjmp	.+1440   	; 0x5a6 <__bad_interrupt>
       6:	00 00       	nop
       8:	ce c2       	rjmp	.+1436   	; 0x5a6 <__bad_interrupt>
       a:	00 00       	nop
       c:	cc c2       	rjmp	.+1432   	; 0x5a6 <__bad_interrupt>
       e:	00 00       	nop
      10:	ca c2       	rjmp	.+1428   	; 0x5a6 <__bad_interrupt>
      12:	00 00       	nop
      14:	c8 c2       	rjmp	.+1424   	; 0x5a6 <__bad_interrupt>
      16:	00 00       	nop
      18:	c6 c2       	rjmp	.+1420   	; 0x5a6 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	c4 c2       	rjmp	.+1416   	; 0x5a6 <__bad_interrupt>
      1e:	00 00       	nop
      20:	c2 c2       	rjmp	.+1412   	; 0x5a6 <__bad_interrupt>
      22:	00 00       	nop
      24:	c0 c2       	rjmp	.+1408   	; 0x5a6 <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 18 0f 	jmp	0x1e30	; 0x1e30 <__vector_10>
      2c:	bc c2       	rjmp	.+1400   	; 0x5a6 <__bad_interrupt>
      2e:	00 00       	nop
      30:	ba c2       	rjmp	.+1396   	; 0x5a6 <__bad_interrupt>
      32:	00 00       	nop
      34:	b8 c2       	rjmp	.+1392   	; 0x5a6 <__bad_interrupt>
      36:	00 00       	nop
      38:	b6 c2       	rjmp	.+1388   	; 0x5a6 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	b4 c2       	rjmp	.+1384   	; 0x5a6 <__bad_interrupt>
      3e:	00 00       	nop
      40:	b2 c2       	rjmp	.+1380   	; 0x5a6 <__bad_interrupt>
      42:	00 00       	nop
      44:	b0 c2       	rjmp	.+1376   	; 0x5a6 <__bad_interrupt>
      46:	00 00       	nop
      48:	ae c2       	rjmp	.+1372   	; 0x5a6 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ac c2       	rjmp	.+1368   	; 0x5a6 <__bad_interrupt>
      4e:	00 00       	nop
      50:	aa c2       	rjmp	.+1364   	; 0x5a6 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 f4 09 	jmp	0x13e8	; 0x13e8 <__vector_21>
      58:	a6 c2       	rjmp	.+1356   	; 0x5a6 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	a4 c2       	rjmp	.+1352   	; 0x5a6 <__bad_interrupt>
      5e:	00 00       	nop
      60:	a2 c2       	rjmp	.+1348   	; 0x5a6 <__bad_interrupt>
      62:	00 00       	nop
      64:	a0 c2       	rjmp	.+1344   	; 0x5a6 <__bad_interrupt>
      66:	00 00       	nop
      68:	9e c2       	rjmp	.+1340   	; 0x5a6 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	9c c2       	rjmp	.+1336   	; 0x5a6 <__bad_interrupt>
      6e:	00 00       	nop
      70:	9a c2       	rjmp	.+1332   	; 0x5a6 <__bad_interrupt>
      72:	00 00       	nop
      74:	98 c2       	rjmp	.+1328   	; 0x5a6 <__bad_interrupt>
      76:	00 00       	nop
      78:	96 c2       	rjmp	.+1324   	; 0x5a6 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	94 c2       	rjmp	.+1320   	; 0x5a6 <__bad_interrupt>
      7e:	00 00       	nop
      80:	92 c2       	rjmp	.+1316   	; 0x5a6 <__bad_interrupt>
      82:	00 00       	nop
      84:	90 c2       	rjmp	.+1312   	; 0x5a6 <__bad_interrupt>
      86:	00 00       	nop
      88:	8e c2       	rjmp	.+1308   	; 0x5a6 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	8c c2       	rjmp	.+1304   	; 0x5a6 <__bad_interrupt>
      8e:	00 00       	nop
      90:	8a c2       	rjmp	.+1300   	; 0x5a6 <__bad_interrupt>
      92:	00 00       	nop
      94:	88 c2       	rjmp	.+1296   	; 0x5a6 <__bad_interrupt>
      96:	00 00       	nop
      98:	86 c2       	rjmp	.+1292   	; 0x5a6 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	84 c2       	rjmp	.+1288   	; 0x5a6 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	82 c2       	rjmp	.+1284   	; 0x5a6 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	80 c2       	rjmp	.+1280   	; 0x5a6 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	7e c2       	rjmp	.+1276   	; 0x5a6 <__bad_interrupt>
      aa:	00 00       	nop

000000ac <pstr_ROC>:
      ac:	08 47 49 56 45 5f 52 4f 43 00                       .GIVE_ROC.

000000b6 <pstr_LIDOCANE>:
      b6:	0d 47 49 56 45 5f 4c 49 44 4f 43 41 4e 45 00        .GIVE_LIDOCANE.

000000c5 <pstr_PROPOFOL>:
      c5:	0d 47 49 56 45 5f 50 52 4f 50 4f 46 4f 4c 00        .GIVE_PROPOFOL.

000000d4 <pstr_ANTIBIOTICS>:
      d4:	10 47 49 56 45 5f 41 4e 54 49 42 49 4f 54 49 43     .GIVE_ANTIBIOTIC
      e4:	53 00                                               S.

000000e6 <pstr_KETAMINE>:
      e6:	0d 47 49 56 45 5f 4b 45 54 41 4d 49 4e 45 00        .GIVE_KETAMINE.

000000f5 <pstr_FENTANYL>:
      f5:	0d 47 49 56 45 5f 46 45 4e 54 41 4e 59 4c 00        .GIVE_FENTANYL.

00000104 <pstr_MORPHINE>:
     104:	0d 47 49 56 45 5f 4d 4f 52 50 48 49 4e 45 00        .GIVE_MORPHINE.

00000113 <pstr_ETOMIDATE>:
     113:	0e 47 49 56 45 5f 45 54 4f 4d 49 44 41 54 45 00     .GIVE_ETOMIDATE.

00000123 <heat_str>:
     123:	04 48 45 41 54 00                                   .HEAT.

00000129 <blip_str>:
     129:	04 42 4c 49 50 00                                   .BLIP.

0000012f <device_name_string>:
     12f:	06 61 69 72 77 61 79 00                             .airway.

00000137 <iv_arm_msg>:
     137:	0d 41 52 4d 5f 52 5f 49 56 5f 43 41 54 48 00        .ARM_R_IV_CATH.

00000146 <eschar_msg_5>:
     146:	0e 41 52 4d 5f 4c 5f 45 53 43 48 41 52 5f 35 00     .ARM_L_ESCHAR_5.

00000156 <eschar_msg_4>:
     156:	0e 41 52 4d 5f 4c 5f 45 53 43 48 41 52 5f 34 00     .ARM_L_ESCHAR_4.

00000166 <eschar_msg_3>:
     166:	0e 41 52 4d 5f 4c 5f 45 53 43 48 41 52 5f 33 00     .ARM_L_ESCHAR_3.

00000176 <eschar_msg_2>:
     176:	0e 41 52 4d 5f 4c 5f 45 53 43 48 41 52 5f 32 00     .ARM_L_ESCHAR_2.

00000186 <eschar_msg_1>:
     186:	0e 41 52 4d 5f 4c 5f 45 53 43 48 41 52 5f 31 00     .ARM_L_ESCHAR_1.

00000196 <o2_msg_str>:
     196:	02 4f 32 00                                         .O2.

0000019a <hypervent_msg_str>:
     19a:	0e 48 59 50 45 52 56 45 4e 54 49 4c 41 54 45 00     .HYPERVENTILATE.

000001aa <mainstem_msg_str>:
     1aa:	1c 4d 41 49 4e 53 54 45 4d 5f 56 45 4e 54 49 4c     .MAINSTEM_VENTIL
     1ba:	41 54 49 4f 4e 5f 45 54 5f 54 55 42 45 00           ATION_ET_TUBE.

000001c8 <bvm_off_msg_str>:
     1c8:	07 42 56 4d 5f 4f 46 46 00                          .BVM_OFF.

000001d1 <vent_msg_str>:
     1d1:	13 56 45 4e 54 49 4c 41 54 49 4f 4e 5f 45 54 5f     .VENTILATION_ET_
     1e1:	54 55 42 45 00                                      TUBE.

000001e6 <bio_report_string>:
     1e6:	11 41 43 54 3d 31 38 73 2c 50 52 4f 58 3d 31 39     .ACT=18s,PROX=19
     1f6:	73 2c 00                                            s,.

000001f9 <ProductString>:
     1f9:	2c 03 4c 00 55 00 46 00 41 00 20 00 47 00 65 00     ,.L.U.F.A. .G.e.
     209:	6e 00 65 00 72 00 69 00 63 00 20 00 48 00 49 00     n.e.r.i.c. .H.I.
     219:	44 00 20 00 44 00 65 00 6d 00 6f 00 00 00           D. .D.e.m.o...

00000227 <ManufacturerString>:
     227:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
     237:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

00000241 <LanguageString>:
     241:	04 03 09 04                                         ....

00000245 <ConfigurationDescriptor>:
     245:	09 02 22 00 01 01 00 c0 32 09 04 00 00 01 03 00     ..".....2.......
     255:	00 00 09 21 11 01 00 01 22 ca 01 07 05 81 03 08     ...!....".......
     265:	00 05                                               ..

00000267 <DeviceDescriptor>:
     267:	12 01 10 01 00 00 00 08 eb 03 40 20 01 00 01 02     ..........@ ....
     277:	00 01                                               ..

00000279 <GenericReport>:
     279:	06 00 ff 09 01 a1 01 85 01 09 02 15 00 26 ff 00     .............&..
     289:	75 08 95 fe b1 02 85 02 09 02 15 00 26 ff 00 75     u...........&..u
     299:	08 95 ff b1 02 85 03 09 05 15 00 26 ff 00 75 08     ...........&..u.
     2a9:	95 0c 81 00 85 04 09 06 15 00 26 ff 00 75 08 95     ..........&..u..
     2b9:	08 b1 02 85 05 09 07 15 00 26 ff 00 75 08 95 0c     .........&..u...
     2c9:	81 02 85 06 09 08 15 00 26 ff 00 75 08 95 10 b1     ........&..u....
     2d9:	02 85 07 09 09 15 00 26 ff 00 75 08 95 0d 81 02     .......&..u.....
     2e9:	85 ff 09 0a 15 00 26 ff 00 75 08 95 08 b1 02 85     ......&..u......
     2f9:	fe 09 0b 15 00 26 ff 00 75 08 95 08 b1 02 85 08     .....&..u.......
     309:	09 0c 15 00 26 ff 00 75 08 95 04 81 02 85 08 09     ....&..u........
     319:	0c 15 00 26 ff 00 75 08 95 04 91 02 85 09 09 0c     ...&..u.........
     329:	15 00 26 ff 00 75 08 95 04 81 02 85 09 09 0c 15     ..&..u..........
     339:	00 26 ff 00 75 08 95 04 91 02 85 0a 09 0c 15 00     .&..u...........
     349:	26 ff 00 75 08 95 04 81 02 85 0a 09 0c 15 00 26     &..u...........&
     359:	ff 00 75 08 95 04 91 02 85 0b 09 0c 15 00 26 ff     ..u...........&.
     369:	00 75 08 95 04 81 02 85 0b 09 0c 15 00 26 ff 00     .u...........&..
     379:	75 08 95 04 91 02 85 0c 09 0c 15 00 26 ff 00 75     u...........&..u
     389:	08 95 04 81 02 85 0c 09 0c 15 00 26 ff 00 75 08     ...........&..u.
     399:	95 04 91 02 85 0d 09 0c 15 00 26 ff 00 75 08 95     ..........&..u..
     3a9:	04 81 02 85 0d 09 0c 15 00 26 ff 00 75 08 95 04     .........&..u...
     3b9:	91 02 85 0e 09 0c 15 00 26 ff 00 75 08 95 04 81     ........&..u....
     3c9:	02 85 0e 09 0c 15 00 26 ff 00 75 08 95 04 91 02     .......&..u.....
     3d9:	85 0f 09 00 15 00 26 ff 00 75 08 95 04 b1 02 85     ......&..u......
     3e9:	10 09 0d 15 00 26 ff 00 75 08 95 40 81 02 85 11     .....&..u..@....
     3f9:	09 0d 15 00 26 ff 00 75 08 95 01 91 02 85 12 09     ....&..u........
     409:	0e 15 00 26 ff 00 75 08 95 ff 81 02 85 12 09 0e     ...&..u.........
     419:	15 00 26 ff 00 75 08 95 ff 91 02 85 13 09 0f 15     ..&..u..........
     429:	00 26 ff 00 75 08 95 ff 81 02 85 13 09 0f 15 00     .&..u...........
     439:	26 ff 00 75 08 95 ff 91 02 c0                       &..u......

00000443 <o2_str>:
     443:	02 4f 32 00                                         .O2.

00000447 <temp_probe_str>:
     447:	0a 54 45 4d 50 5f 50 52 4f 42 45 00                 .TEMP_PROBE.

00000453 <pulse_ox_str>:
     453:	08 50 55 4c 53 45 5f 4f 58 00                       .PULSE_OX.

0000045d <bp_cuff_str>:
     45d:	07 42 50 5f 43 55 46 46 00                          .BP_CUFF.

00000466 <ecg_str>:
     466:	03 45 43 47 00                                      .ECG.

0000046b <fluids_str>:
     46b:	06 46 4c 55 49 44 53 00                             .FLUIDS.

00000473 <roc_str>:
     473:	03 52 4f 43 00                                      .ROC.

00000478 <lidocane_str>:
     478:	08 4c 49 44 4f 43 41 4e 45 00                       .LIDOCANE.

00000482 <propofol_str>:
     482:	08 50 52 4f 50 4f 46 4f 4c 00                       .PROPOFOL.

0000048c <antibiotics_str>:
     48c:	0b 41 4e 54 49 42 49 4f 54 49 43 53 00              .ANTIBIOTICS.

00000499 <ketamine_str>:
     499:	08 4b 45 54 41 4d 49 4e 45 00                       .KETAMINE.

000004a3 <fentanyl_str>:
     4a3:	08 46 45 4e 54 41 4e 59 4c 00                       .FENTANYL.

000004ad <morphine_str>:
     4ad:	08 4d 4f 52 50 48 49 4e 45 00                       .MORPHINE.

000004b7 <succs_str>:
     4b7:	05 53 55 43 43 53 00                                .SUCCS.

000004be <etomidate_str>:
     4be:	09 45 54 4f 4d 49 44 41 54 45 00                    .ETOMIDATE.

000004c9 <vent_str>:
     4c9:	04 56 45 4e 54 00                                   .VENT.

000004cf <bvm_str>:
     4cf:	03 42 56 4d 00                                      .BVM.

000004d4 <iv_connected_str>:
     4d4:	0d 41 52 4d 5f 52 5f 49 56 5f 43 41 54 48 00        .ARM_R_IV_CATH.

000004e3 <pstr_rcv_ROC>:
     4e3:	03 52 4f 43 00                                      .ROC.

000004e8 <pstr_rcv_LIDOCANE>:
     4e8:	08 4c 49 44 4f 43 41 4e 45 00                       .LIDOCANE.

000004f2 <pstr_rcv_PROPOFOL>:
     4f2:	08 50 52 4f 50 4f 46 4f 4c 00                       .PROPOFOL.

000004fc <pstr_rcv_ANTIBIOTICS>:
     4fc:	0b 41 4e 54 49 42 49 4f 54 49 43 53 00              .ANTIBIOTICS.

00000509 <pstr_rcv_KETAMINE>:
     509:	08 4b 45 54 41 4d 49 4e 45 00                       .KETAMINE.

00000513 <pstr_rcv_FENTANYL>:
     513:	08 46 45 4e 54 41 4e 59 4c 00                       .FENTANYL.

0000051d <pstr_rcv_MORPHINE>:
     51d:	08 4d 4f 52 50 48 49 4e 45 00                       .MORPHINE.

00000527 <pstr_rcv_ETOMIDATE>:
     527:	09 45 54 4f 4d 49 44 41 54 45 00                    .ETOMIDATE.

00000532 <__ctors_end>:
     532:	11 24       	eor	r1, r1
     534:	1f be       	out	0x3f, r1	; 63
     536:	cf ef       	ldi	r28, 0xFF	; 255
     538:	da e0       	ldi	r29, 0x0A	; 10
     53a:	de bf       	out	0x3e, r29	; 62
     53c:	cd bf       	out	0x3d, r28	; 61

0000053e <Bootloader_Jump_Check>:
/* the bootloader stuff */
uint32_t Boot_Key ATTR_NO_INIT;
void Bootloader_Jump_Check(void)
{
    // If the reset source was the bootloader and the key is correct, clear it and jump to the bootloader
    if ((MCUSR & (1 << WDRF)) && (Boot_Key == MAGIC_BOOT_KEY))
     53e:	04 b6       	in	r0, 0x34	; 52
     540:	03 fe       	sbrs	r0, 3
     542:	1b c0       	rjmp	.+54     	; 0x57a <__do_copy_data>
     544:	80 91 3f 06 	lds	r24, 0x063F
     548:	90 91 40 06 	lds	r25, 0x0640
     54c:	a0 91 41 06 	lds	r26, 0x0641
     550:	b0 91 42 06 	lds	r27, 0x0642
     554:	8a 3c       	cpi	r24, 0xCA	; 202
     556:	2c ea       	ldi	r18, 0xAC	; 172
     558:	92 07       	cpc	r25, r18
     55a:	22 e4       	ldi	r18, 0x42	; 66
     55c:	a2 07       	cpc	r26, r18
     55e:	2c ed       	ldi	r18, 0xDC	; 220
     560:	b2 07       	cpc	r27, r18
     562:	59 f4       	brne	.+22     	; 0x57a <__do_copy_data>
    {
		//overwrite boot key so that if the code that's loaded used the same location and value it will not re-bootload.
		//MCUSR &= 0 ; //~(1 << WDRF);
        Boot_Key = 0;
     564:	10 92 3f 06 	sts	0x063F, r1
     568:	10 92 40 06 	sts	0x0640, r1
     56c:	10 92 41 06 	sts	0x0641, r1
     570:	10 92 42 06 	sts	0x0642, r1
        ((void (*)(void))BOOTLOADER_START_ADDRESS)();
     574:	e0 e0       	ldi	r30, 0x00	; 0
     576:	f8 e3       	ldi	r31, 0x38	; 56
     578:	09 95       	icall

0000057a <__do_copy_data>:
     57a:	13 e0       	ldi	r17, 0x03	; 3
     57c:	a0 e0       	ldi	r26, 0x00	; 0
     57e:	b1 e0       	ldi	r27, 0x01	; 1
     580:	e0 e0       	ldi	r30, 0x00	; 0
     582:	fa e2       	ldi	r31, 0x2A	; 42
     584:	02 c0       	rjmp	.+4      	; 0x58a <__do_copy_data+0x10>
     586:	05 90       	lpm	r0, Z+
     588:	0d 92       	st	X+, r0
     58a:	ae 33       	cpi	r26, 0x3E	; 62
     58c:	b1 07       	cpc	r27, r17
     58e:	d9 f7       	brne	.-10     	; 0x586 <__do_copy_data+0xc>

00000590 <__do_clear_bss>:
     590:	16 e0       	ldi	r17, 0x06	; 6
     592:	ae e3       	ldi	r26, 0x3E	; 62
     594:	b3 e0       	ldi	r27, 0x03	; 3
     596:	01 c0       	rjmp	.+2      	; 0x59a <.do_clear_bss_start>

00000598 <.do_clear_bss_loop>:
     598:	1d 92       	st	X+, r1

0000059a <.do_clear_bss_start>:
     59a:	af 33       	cpi	r26, 0x3F	; 63
     59c:	b1 07       	cpc	r27, r17
     59e:	e1 f7       	brne	.-8      	; 0x598 <.do_clear_bss_loop>
     5a0:	c3 d1       	rcall	.+902    	; 0x928 <main>
     5a2:	0c 94 fe 14 	jmp	0x29fc	; 0x29fc <_exit>

000005a6 <__bad_interrupt>:
     5a6:	2c cd       	rjmp	.-1448   	; 0x0 <__vectors>

000005a8 <LEDs_SetAllLEDs>:
				PORTC &= ~(LEDMask & LEDS_PORTC_LEDS);
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTB = ((PORTB |  LEDS_PORTB_LEDS) & ~(LEDMask & LEDS_PORTB_LEDS));
     5a8:	25 b1       	in	r18, 0x05	; 5
     5aa:	98 2f       	mov	r25, r24
     5ac:	91 70       	andi	r25, 0x01	; 1
     5ae:	90 95       	com	r25
     5b0:	21 60       	ori	r18, 0x01	; 1
     5b2:	92 23       	and	r25, r18
     5b4:	95 b9       	out	0x05, r25	; 5
				PORTD = ((PORTD |  LEDS_PORTD_LEDS) & ~(LEDMask & LEDS_PORTD_LEDS));
     5b6:	2b b1       	in	r18, 0x0b	; 11
     5b8:	98 2f       	mov	r25, r24
     5ba:	90 72       	andi	r25, 0x20	; 32
     5bc:	90 95       	com	r25
     5be:	20 62       	ori	r18, 0x20	; 32
     5c0:	92 23       	and	r25, r18
     5c2:	9b b9       	out	0x0b, r25	; 11
				PORTC = ((PORTC & ~LEDS_PORTC_LEDS) |  (LEDMask & LEDS_PORTC_LEDS));
     5c4:	98 b1       	in	r25, 0x08	; 8
     5c6:	80 78       	andi	r24, 0x80	; 128
     5c8:	9f 77       	andi	r25, 0x7F	; 127
     5ca:	89 2b       	or	r24, r25
     5cc:	88 b9       	out	0x08, r24	; 8
			}
     5ce:	08 95       	ret

000005d0 <Jump_To_Bootloader>:
			 *  enumerating the device once attached until \ref USB_Attach() is called.
			 */
			static inline void USB_Detach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Detach(void)
			{
				UDCON  |=  (1 << DETACH);
     5d0:	80 91 e0 00 	lds	r24, 0x00E0
     5d4:	81 60       	ori	r24, 0x01	; 1
     5d6:	80 93 e0 00 	sts	0x00E0, r24
{
    // If USB is used, detach from the bus and reset it
    //USB_Disable();
	USB_Detach();
    // Disable all interrupts
    cli();
     5da:	f8 94       	cli
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     5dc:	8f ef       	ldi	r24, 0xFF	; 255
     5de:	9d e3       	ldi	r25, 0x3D	; 61
     5e0:	a9 e4       	ldi	r26, 0x49	; 73
     5e2:	81 50       	subi	r24, 0x01	; 1
     5e4:	90 40       	sbci	r25, 0x00	; 0
     5e6:	a0 40       	sbci	r26, 0x00	; 0
     5e8:	e1 f7       	brne	.-8      	; 0x5e2 <Jump_To_Bootloader+0x12>
     5ea:	00 c0       	rjmp	.+0      	; 0x5ec <Jump_To_Bootloader+0x1c>
     5ec:	00 00       	nop
    // Wait two seconds for the USB detachment to register on the host
    Delay_MS(1500);
    // Set the bootloader key to the magic value and force a reset
    Boot_Key = MAGIC_BOOT_KEY;
     5ee:	8a ec       	ldi	r24, 0xCA	; 202
     5f0:	9c ea       	ldi	r25, 0xAC	; 172
     5f2:	a2 e4       	ldi	r26, 0x42	; 66
     5f4:	bc ed       	ldi	r27, 0xDC	; 220
     5f6:	80 93 3f 06 	sts	0x063F, r24
     5fa:	90 93 40 06 	sts	0x0640, r25
     5fe:	a0 93 41 06 	sts	0x0641, r26
     602:	b0 93 42 06 	sts	0x0642, r27
    wdt_enable(WDTO_500MS);
     606:	2d e0       	ldi	r18, 0x0D	; 13
     608:	88 e1       	ldi	r24, 0x18	; 24
     60a:	90 e0       	ldi	r25, 0x00	; 0
     60c:	0f b6       	in	r0, 0x3f	; 63
     60e:	f8 94       	cli
     610:	a8 95       	wdr
     612:	80 93 60 00 	sts	0x0060, r24
     616:	0f be       	out	0x3f, r0	; 63
     618:	20 93 60 00 	sts	0x0060, r18
     61c:	ff cf       	rjmp	.-2      	; 0x61c <Jump_To_Bootloader+0x4c>

0000061e <adc_read>:

uint16_t adc_values[12];

uint16_t adc_read(int pin) {
	uint8_t lo, hi;
	uint8_t pinlo = pin & 0x1f;
     61e:	98 2f       	mov	r25, r24
     620:	9f 71       	andi	r25, 0x1F	; 31
	
	bool pinhi = pin & 0x20;
	if (pinhi) { //TODO optimize away the if
     622:	85 ff       	sbrs	r24, 5
     624:	04 c0       	rjmp	.+8      	; 0x62e <adc_read+0x10>
		ADCSRB |= (1<<MUX5);
     626:	80 91 7b 00 	lds	r24, 0x007B
     62a:	80 62       	ori	r24, 0x20	; 32
     62c:	03 c0       	rjmp	.+6      	; 0x634 <adc_read+0x16>
	} else {
		ADCSRB &= ~(1<<MUX5);
     62e:	80 91 7b 00 	lds	r24, 0x007B
     632:	8f 7d       	andi	r24, 0xDF	; 223
     634:	80 93 7b 00 	sts	0x007B, r24
	}
	
	//ADMUX &= 0xf8; //clear low pins
	//ADMUX |= pinlo;
	ADMUX = (ADMUX & 0xe0) | pinlo; //clear low pins
     638:	80 91 7c 00 	lds	r24, 0x007C
     63c:	80 7e       	andi	r24, 0xE0	; 224
     63e:	89 2b       	or	r24, r25
     640:	80 93 7c 00 	sts	0x007C, r24
	
	ADCSRA |= (1<<ADSC); //get an adc value
     644:	80 91 7a 00 	lds	r24, 0x007A
     648:	80 64       	ori	r24, 0x40	; 64
     64a:	80 93 7a 00 	sts	0x007A, r24
	while (ADCSRA & (1<<ADSC)); //Wait for it to do the adc
     64e:	80 91 7a 00 	lds	r24, 0x007A
     652:	86 fd       	sbrc	r24, 6
     654:	fc cf       	rjmp	.-8      	; 0x64e <adc_read+0x30>
	lo = ADCL;
     656:	80 91 78 00 	lds	r24, 0x0078
	hi = ADCH;
     65a:	90 91 79 00 	lds	r25, 0x0079
	return (hi << 8) | lo;
     65e:	39 2f       	mov	r19, r25
     660:	20 e0       	ldi	r18, 0x00	; 0
     662:	90 e0       	ldi	r25, 0x00	; 0
     664:	82 2b       	or	r24, r18
     666:	93 2b       	or	r25, r19
}
     668:	08 95       	ret

0000066a <adc_task>:

void adc_task(void) {
     66a:	0f 93       	push	r16
     66c:	1f 93       	push	r17
     66e:	cf 93       	push	r28
     670:	df 93       	push	r29
	int i;
	for (i = 0; i < 9; i++) {
     672:	0a e8       	ldi	r16, 0x8A	; 138
     674:	15 e0       	ldi	r17, 0x05	; 5
     676:	c0 e0       	ldi	r28, 0x00	; 0
     678:	d0 e0       	ldi	r29, 0x00	; 0
		adc_values[i] = adc_read(i);
     67a:	ce 01       	movw	r24, r28
     67c:	d0 df       	rcall	.-96     	; 0x61e <adc_read>
     67e:	f8 01       	movw	r30, r16
     680:	81 93       	st	Z+, r24
     682:	91 93       	st	Z+, r25
     684:	8f 01       	movw	r16, r30
     686:	21 96       	adiw	r28, 0x01	; 1
	return (hi << 8) | lo;
}

void adc_task(void) {
	int i;
	for (i = 0; i < 9; i++) {
     688:	c9 30       	cpi	r28, 0x09	; 9
     68a:	d1 05       	cpc	r29, r1
     68c:	b1 f7       	brne	.-20     	; 0x67a <adc_task+0x10>
     68e:	df 91       	pop	r29
		adc_values[i] = adc_read(i);
	}
}
     690:	cf 91       	pop	r28
     692:	1f 91       	pop	r17
     694:	0f 91       	pop	r16
     696:	08 95       	ret

00000698 <lung_module_init>:
     698:	cc d6       	rcall	.+3480   	; 0x1432 <millis>

lung_state lung_st = LUNG_ZERO_STATE;

void lung_module_init(void)
{
	gas_pressure_learning_started = millis();
     69a:	dc 01       	movw	r26, r24
     69c:	cb 01       	movw	r24, r22
     69e:	80 93 74 05 	sts	0x0574, r24
     6a2:	90 93 75 05 	sts	0x0575, r25
     6a6:	a0 93 76 05 	sts	0x0576, r26
     6aa:	b0 93 77 05 	sts	0x0577, r27
     6ae:	08 95       	ret

000006b0 <lung_module_task>:
}
     6b0:	c0 d6       	rcall	.+3456   	; 0x1432 <millis>
ms_time_t lung_flow_start_time;
#define GAS_IS_LUNGS
void lung_module_task(void)
{
	//learn for a while
	ms_time_t now = millis();
     6b2:	ab 01       	movw	r20, r22
     6b4:	bc 01       	movw	r22, r24
     6b6:	80 91 6e 05 	lds	r24, 0x056E
	if (!gas_pressure_learned && (now 
     6ba:	88 23       	and	r24, r24
     6bc:	31 f5       	brne	.+76     	; 0x70a <lung_module_task+0x5a>
     6be:	80 91 74 05 	lds	r24, 0x0574
		>= (gas_pressure_learning_started + GAS_PRESSURE_LEARN_TIME_MS))) {
     6c2:	90 91 75 05 	lds	r25, 0x0575
     6c6:	a0 91 76 05 	lds	r26, 0x0576
     6ca:	b0 91 77 05 	lds	r27, 0x0577
     6ce:	84 52       	subi	r24, 0x24	; 36
     6d0:	9a 4f       	sbci	r25, 0xFA	; 250
     6d2:	af 4f       	sbci	r26, 0xFF	; 255
     6d4:	bf 4f       	sbci	r27, 0xFF	; 255
     6d6:	48 17       	cp	r20, r24
#define GAS_IS_LUNGS
void lung_module_task(void)
{
	//learn for a while
	ms_time_t now = millis();
	if (!gas_pressure_learned && (now 
     6d8:	59 07       	cpc	r21, r25
     6da:	6a 07       	cpc	r22, r26
     6dc:	7b 07       	cpc	r23, r27
     6de:	a8 f0       	brcs	.+42     	; 0x70a <lung_module_task+0x5a>
     6e0:	81 e0       	ldi	r24, 0x01	; 1
		>= (gas_pressure_learning_started + GAS_PRESSURE_LEARN_TIME_MS))) {
		gas_pressure_learned = 1;
     6e2:	80 93 6e 05 	sts	0x056E, r24
     6e6:	80 91 98 05 	lds	r24, 0x0598
		gas_pressure_threshold_left = adc_values[left_bronchus_adc_pin] + 5;
     6ea:	90 91 99 05 	lds	r25, 0x0599
     6ee:	05 96       	adiw	r24, 0x05	; 5
     6f0:	90 93 0d 01 	sts	0x010D, r25
     6f4:	80 93 0c 01 	sts	0x010C, r24
     6f8:	80 91 94 05 	lds	r24, 0x0594
		gas_pressure_threshold_right = adc_values[right_bronchus_adc_pin] + 5;
     6fc:	90 91 95 05 	lds	r25, 0x0595
     700:	05 96       	adiw	r24, 0x05	; 5
     702:	90 93 0b 01 	sts	0x010B, r25
     706:	80 93 0a 01 	sts	0x010A, r24
     70a:	80 91 6e 05 	lds	r24, 0x056E
	}
	bool left_press = gas_pressure_learned ?
		  adc_values[left_bronchus_adc_pin] >= gas_pressure_threshold_left
		: 0;
     70e:	88 23       	and	r24, r24
     710:	d1 f0       	breq	.+52     	; 0x746 <lung_module_task+0x96>
     712:	f1 e0       	ldi	r31, 0x01	; 1
     714:	20 91 98 05 	lds	r18, 0x0598
     718:	30 91 99 05 	lds	r19, 0x0599
     71c:	80 91 0c 01 	lds	r24, 0x010C
     720:	90 91 0d 01 	lds	r25, 0x010D
     724:	28 17       	cp	r18, r24
     726:	39 07       	cpc	r19, r25
     728:	08 f4       	brcc	.+2      	; 0x72c <lung_module_task+0x7c>
     72a:	f0 e0       	ldi	r31, 0x00	; 0
     72c:	e1 e0       	ldi	r30, 0x01	; 1
	bool right_press = gas_pressure_learned ?
		  adc_values[right_bronchus_adc_pin] >= gas_pressure_threshold_right
		: 0;
     72e:	20 91 94 05 	lds	r18, 0x0594
     732:	30 91 95 05 	lds	r19, 0x0595
     736:	80 91 0a 01 	lds	r24, 0x010A
     73a:	90 91 0b 01 	lds	r25, 0x010B
     73e:	28 17       	cp	r18, r24
     740:	39 07       	cpc	r19, r25
     742:	18 f4       	brcc	.+6      	; 0x74a <lung_module_task+0x9a>
     744:	01 c0       	rjmp	.+2      	; 0x748 <lung_module_task+0x98>
     746:	f0 e0       	ldi	r31, 0x00	; 0
		gas_pressure_threshold_left = adc_values[left_bronchus_adc_pin] + 5;
		gas_pressure_threshold_right = adc_values[right_bronchus_adc_pin] + 5;
	}
	bool left_press = gas_pressure_learned ?
		  adc_values[left_bronchus_adc_pin] >= gas_pressure_threshold_left
		: 0;
     748:	e0 e0       	ldi	r30, 0x00	; 0
	bool right_press = gas_pressure_learned ?
		  adc_values[right_bronchus_adc_pin] >= gas_pressure_threshold_right
		: 0;
     74a:	80 91 52 05 	lds	r24, 0x0552
	bool anymsg = bvm_sitch || vent_sitch;
     74e:	88 23       	and	r24, r24
     750:	49 f4       	brne	.+18     	; 0x764 <lung_module_task+0xb4>
     752:	81 e0       	ldi	r24, 0x01	; 1
     754:	90 e0       	ldi	r25, 0x00	; 0
     756:	20 91 66 05 	lds	r18, 0x0566
     75a:	22 23       	and	r18, r18
     75c:	29 f4       	brne	.+10     	; 0x768 <lung_module_task+0xb8>
     75e:	80 e0       	ldi	r24, 0x00	; 0
     760:	90 e0       	ldi	r25, 0x00	; 0
     762:	02 c0       	rjmp	.+4      	; 0x768 <lung_module_task+0xb8>
     764:	81 e0       	ldi	r24, 0x01	; 1
     766:	90 e0       	ldi	r25, 0x00	; 0
     768:	20 91 3e 03 	lds	r18, 0x033E
	if (lung_st == WAIT_FOR_BVM_OFF_STATE) {
     76c:	23 30       	cpi	r18, 0x03	; 3
     76e:	29 f5       	brne	.+74     	; 0x7ba <lung_module_task+0x10a>
     770:	ff 23       	and	r31, r31
		//TODO need BVM_OFF_WAIT_TIME_MS of continuous no pressure before sending message
		if (!left_press && !right_press && !vent_sitch) {
     772:	09 f0       	breq	.+2      	; 0x776 <lung_module_task+0xc6>
     774:	86 c0       	rjmp	.+268    	; 0x882 <lung_module_task+0x1d2>
     776:	ee 23       	and	r30, r30
     778:	09 f0       	breq	.+2      	; 0x77c <lung_module_task+0xcc>
     77a:	83 c0       	rjmp	.+262    	; 0x882 <lung_module_task+0x1d2>
     77c:	80 91 66 05 	lds	r24, 0x0566
     780:	88 23       	and	r24, r24
     782:	09 f0       	breq	.+2      	; 0x786 <lung_module_task+0xd6>
     784:	7e c0       	rjmp	.+252    	; 0x882 <lung_module_task+0x1d2>
     786:	80 91 4e 04 	lds	r24, 0x044E
			if (now >= (lung_flow_stop_time + BVM_OFF_WAIT_TIME_MS)) {
     78a:	90 91 4f 04 	lds	r25, 0x044F
     78e:	a0 91 50 04 	lds	r26, 0x0450
     792:	b0 91 51 04 	lds	r27, 0x0451
     796:	88 57       	subi	r24, 0x78	; 120
     798:	9c 4e       	sbci	r25, 0xEC	; 236
     79a:	af 4f       	sbci	r26, 0xFF	; 255
     79c:	bf 4f       	sbci	r27, 0xFF	; 255
     79e:	48 17       	cp	r20, r24
     7a0:	59 07       	cpc	r21, r25
     7a2:	6a 07       	cpc	r22, r26
     7a4:	7b 07       	cpc	r23, r27
     7a6:	08 f4       	brcc	.+2      	; 0x7aa <lung_module_task+0xfa>
     7a8:	8d c0       	rjmp	.+282    	; 0x8c4 <lung_module_task+0x214>
     7aa:	81 e0       	ldi	r24, 0x01	; 1
				bvm_off_msg_waiting = 1;
     7ac:	80 93 65 05 	sts	0x0565, r24
     7b0:	10 92 52 05 	sts	0x0552, r1
				bvm_sitch = 0;
     7b4:	10 92 3e 03 	sts	0x033E, r1
				lung_st = LUNG_ZERO_STATE;
     7b8:	08 95       	ret
     7ba:	00 97       	sbiw	r24, 0x00	; 0
				//do nothing
			}
		} else {
			lung_flow_stop_time = now;
		}
	} else if (!anymsg) {
     7bc:	09 f4       	brne	.+2      	; 0x7c0 <lung_module_task+0x110>
     7be:	82 c0       	rjmp	.+260    	; 0x8c4 <lung_module_task+0x214>
     7c0:	21 50       	subi	r18, 0x01	; 1
	//if at any point both are on, send message, move to waiting state
	//if wait period is reached without change in pressure state, send appropriate message (possibyl none)
	//if pressures go down before end of wait state, send message as if that state was reached at the end of wait state and move to waiting for pressure to go down in order to send BVM_OFF message.
		if (/*we are not in the waiting state */ 
			(lung_st != RIGHT_PRESSURE_WAITING_STATE)
		&& (lung_st != LEFT_PRESSURE_WAITING_STATE)) {
     7c2:	22 30       	cpi	r18, 0x02	; 2
	} else {
	// if we have one pressure, move to a waiting state to see if pressure in the other appears
	//if at any point both are on, send message, move to waiting state
	//if wait period is reached without change in pressure state, send appropriate message (possibyl none)
	//if pressures go down before end of wait state, send message as if that state was reached at the end of wait state and move to waiting for pressure to go down in order to send BVM_OFF message.
		if (/*we are not in the waiting state */ 
     7c4:	40 f1       	brcs	.+80     	; 0x816 <lung_module_task+0x166>
     7c6:	ff 23       	and	r31, r31
			(lung_st != RIGHT_PRESSURE_WAITING_STATE)
		&& (lung_st != LEFT_PRESSURE_WAITING_STATE)) {
			if (!left_press && !right_press) {
     7c8:	19 f4       	brne	.+6      	; 0x7d0 <lung_module_task+0x120>
     7ca:	ee 23       	and	r30, r30
     7cc:	91 f4       	brne	.+36     	; 0x7f2 <lung_module_task+0x142>
     7ce:	08 95       	ret
     7d0:	ee 23       	and	r30, r30
				//stay in this state, no action
			} else if (left_press && !right_press) {
     7d2:	09 f0       	breq	.+2      	; 0x7d6 <lung_module_task+0x126>
     7d4:	45 c0       	rjmp	.+138    	; 0x860 <lung_module_task+0x1b0>
     7d6:	40 93 84 05 	sts	0x0584, r20
				//set waiting start variable
				lung_flow_start_time = now;
     7da:	50 93 85 05 	sts	0x0585, r21
     7de:	60 93 86 05 	sts	0x0586, r22
     7e2:	70 93 87 05 	sts	0x0587, r23
     7e6:	82 e0       	ldi	r24, 0x02	; 2
				//go to LEFT_PRESSURE_WAITING_STATE
				lung_st = LEFT_PRESSURE_WAITING_STATE;
     7e8:	80 93 3e 03 	sts	0x033E, r24
     7ec:	8f e6       	ldi	r24, 0x6F	; 111
				prevst_msg_waiting = &empty_msg_waiting;
     7ee:	95 e0       	ldi	r25, 0x05	; 5
     7f0:	0d c0       	rjmp	.+26     	; 0x80c <lung_module_task+0x15c>
     7f2:	40 93 84 05 	sts	0x0584, r20
			} else if (right_press && !left_press) {
				//set waiting start variable
				lung_flow_start_time = now;
     7f6:	50 93 85 05 	sts	0x0585, r21
     7fa:	60 93 86 05 	sts	0x0586, r22
     7fe:	70 93 87 05 	sts	0x0587, r23
     802:	81 e0       	ldi	r24, 0x01	; 1
				//go to RIGHT_PRESSURE_WAITING_STATE
				lung_st = RIGHT_PRESSURE_WAITING_STATE;
     804:	80 93 3e 03 	sts	0x033E, r24
     808:	88 e8       	ldi	r24, 0x88	; 136
				prevst_msg_waiting = &mainstem_msg_waiting;
     80a:	95 e0       	ldi	r25, 0x05	; 5
     80c:	90 93 09 01 	sts	0x0109, r25
     810:	80 93 08 01 	sts	0x0108, r24
     814:	08 95       	ret
     816:	80 91 84 05 	lds	r24, 0x0584
				lung_st = WAIT_FOR_BVM_OFF_STATE;
				lung_flow_stop_time = now;
			}
		} else { // so we are in the waiting state
			if (/*waiting state has expired*/
			now >= (lung_flow_start_time + GAS_EVENT_WAIT_TIME)) {
     81a:	90 91 85 05 	lds	r25, 0x0585
     81e:	a0 91 86 05 	lds	r26, 0x0586
     822:	b0 91 87 05 	lds	r27, 0x0587
     826:	88 51       	subi	r24, 0x18	; 24
     828:	9c 4f       	sbci	r25, 0xFC	; 252
     82a:	af 4f       	sbci	r26, 0xFF	; 255
     82c:	bf 4f       	sbci	r27, 0xFF	; 255
     82e:	48 17       	cp	r20, r24
				//move to pre-BVM_OFF message state
				lung_st = WAIT_FOR_BVM_OFF_STATE;
				lung_flow_stop_time = now;
			}
		} else { // so we are in the waiting state
			if (/*waiting state has expired*/
     830:	59 07       	cpc	r21, r25
     832:	6a 07       	cpc	r22, r26
     834:	7b 07       	cpc	r23, r27
     836:	c0 f0       	brcs	.+48     	; 0x868 <lung_module_task+0x1b8>
     838:	ff 23       	and	r31, r31
			now >= (lung_flow_start_time + GAS_EVENT_WAIT_TIME)) {
				if (!left_press && !right_press) {
     83a:	19 f4       	brne	.+6      	; 0x842 <lung_module_task+0x192>
     83c:	ee 23       	and	r30, r30
     83e:	21 f4       	brne	.+8      	; 0x848 <lung_module_task+0x198>
     840:	17 c0       	rjmp	.+46     	; 0x870 <lung_module_task+0x1c0>
     842:	ee 23       	and	r30, r30
					//send message from the state we left
					*prevst_msg_waiting = 1;
				} else if (left_press && !right_press) {
     844:	29 f4       	brne	.+10     	; 0x850 <lung_module_task+0x1a0>
     846:	1a c0       	rjmp	.+52     	; 0x87c <lung_module_task+0x1cc>
     848:	81 e0       	ldi	r24, 0x01	; 1
					//this is physically impossible
				} else if (right_press && !left_press) {
					//send mainstem intubation message
					mainstem_msg_waiting = 1;
     84a:	80 93 88 05 	sts	0x0588, r24
     84e:	16 c0       	rjmp	.+44     	; 0x87c <lung_module_task+0x1cc>
     850:	80 91 66 05 	lds	r24, 0x0566
				} else if (right_press && left_press) {
					//send successful intubation message
					if (vent_sitch) {
     854:	88 23       	and	r24, r24
     856:	21 f0       	breq	.+8      	; 0x860 <lung_module_task+0x1b0>
     858:	81 e0       	ldi	r24, 0x01	; 1
						vent_msg_waiting = 1;
     85a:	80 93 7d 05 	sts	0x057D, r24
     85e:	0e c0       	rjmp	.+28     	; 0x87c <lung_module_task+0x1cc>
     860:	81 e0       	ldi	r24, 0x01	; 1
					} else {
						hypervent_msg_waiting = 1;
     862:	80 93 53 05 	sts	0x0553, r24
     866:	0a c0       	rjmp	.+20     	; 0x87c <lung_module_task+0x1cc>
     868:	ff 23       	and	r31, r31
				}
				//move to pre-BVM_OFF message state
				lung_st = WAIT_FOR_BVM_OFF_STATE;
				lung_flow_stop_time = now;
			} else { // waiting state has not expired
				if (!left_press && !right_press) {
     86a:	a1 f4       	brne	.+40     	; 0x894 <lung_module_task+0x1e4>
     86c:	ee 23       	and	r30, r30
     86e:	51 f5       	brne	.+84     	; 0x8c4 <lung_module_task+0x214>
     870:	e0 91 08 01 	lds	r30, 0x0108
					//send message from the state we left
					*prevst_msg_waiting = 1;
     874:	f0 91 09 01 	lds	r31, 0x0109
     878:	81 e0       	ldi	r24, 0x01	; 1
     87a:	80 83       	st	Z, r24
     87c:	83 e0       	ldi	r24, 0x03	; 3
					//move to pre-BVM_OFF message state
					lung_st = WAIT_FOR_BVM_OFF_STATE;
     87e:	80 93 3e 03 	sts	0x033E, r24
     882:	40 93 4e 04 	sts	0x044E, r20
					lung_flow_stop_time = now;
     886:	50 93 4f 04 	sts	0x044F, r21
     88a:	60 93 50 04 	sts	0x0450, r22
     88e:	70 93 51 04 	sts	0x0451, r23
     892:	08 95       	ret
     894:	ee 23       	and	r30, r30
				} else if (left_press && !right_press) {
     896:	b1 f0       	breq	.+44     	; 0x8c4 <lung_module_task+0x214>
     898:	80 91 66 05 	lds	r24, 0x0566
				} else if (right_press && !left_press) {
					//remain in right pressure waiting state
					//we can do this by doing nothing
				} else if (right_press && left_press) {
					//send successful intubation message
					if (vent_sitch) {
     89c:	88 23       	and	r24, r24
     89e:	21 f0       	breq	.+8      	; 0x8a8 <lung_module_task+0x1f8>
     8a0:	81 e0       	ldi	r24, 0x01	; 1
						vent_msg_waiting = 1;
     8a2:	80 93 7d 05 	sts	0x057D, r24
     8a6:	03 c0       	rjmp	.+6      	; 0x8ae <lung_module_task+0x1fe>
     8a8:	81 e0       	ldi	r24, 0x01	; 1
					} else {
						hypervent_msg_waiting = 1;
     8aa:	80 93 53 05 	sts	0x0553, r24
     8ae:	83 e0       	ldi	r24, 0x03	; 3
					}
					//move to pre-BVM_OFF message state
					lung_st = WAIT_FOR_BVM_OFF_STATE;
     8b0:	80 93 3e 03 	sts	0x033E, r24
     8b4:	40 93 4e 04 	sts	0x044E, r20
					lung_flow_stop_time = now;
     8b8:	50 93 4f 04 	sts	0x044F, r21
     8bc:	60 93 50 04 	sts	0x0450, r22
     8c0:	70 93 51 04 	sts	0x0451, r23
     8c4:	08 95       	ret

000008c6 <SetupHardware>:
     8c6:	84 b7       	in	r24, 0x34	; 52
/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
#if (ARCH == ARCH_AVR8)
	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
     8c8:	87 7f       	andi	r24, 0xF7	; 247
     8ca:	84 bf       	out	0x34, r24	; 52
	wdt_disable();
     8cc:	88 e1       	ldi	r24, 0x18	; 24
     8ce:	0f b6       	in	r0, 0x3f	; 63
     8d0:	f8 94       	cli
     8d2:	80 93 60 00 	sts	0x0060, r24
     8d6:	10 92 60 00 	sts	0x0060, r1
     8da:	0f be       	out	0x3f, r0	; 63
	/* disable digital input buffer */
	DIDR1 &= ~(1<<AIN0D);
	DIDR0 |= 0xff;
#endif
	/* enable and configure ADC */
	ADCSRA |= (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0); /* sets clock division */ 
     8dc:	ea e7       	ldi	r30, 0x7A	; 122
     8de:	f0 e0       	ldi	r31, 0x00	; 0
     8e0:	80 81       	ld	r24, Z
     8e2:	87 60       	ori	r24, 0x07	; 7
     8e4:	80 83       	st	Z, r24
	ADCSRA |= (1<<ADEN); /*enable*/
     8e6:	80 81       	ld	r24, Z
     8e8:	80 68       	ori	r24, 0x80	; 128
     8ea:	80 83       	st	Z, r24
	/* to select channel, write to ADMUX */
	//ADCSRB |= MUX5;
	//ADMUX = 2; /* ADC channel 10? */

	ADMUX = (1<<REFS0) /*| (1<<REFS1)*/; /* set ref, arduino uses 1<<6 */
     8ec:	80 e4       	ldi	r24, 0x40	; 64
     8ee:	80 93 7c 00 	sts	0x007C, r24
The type of x is clock_div_t.
*/
void clock_prescale_set(clock_div_t __x)
{
    uint8_t __tmp = _BV(CLKPCE);
    __asm__ __volatile__ (
     8f2:	90 e0       	ldi	r25, 0x00	; 0
     8f4:	80 e8       	ldi	r24, 0x80	; 128
     8f6:	0f b6       	in	r0, 0x3f	; 63
     8f8:	f8 94       	cli
     8fa:	80 93 61 00 	sts	0x0061, r24
     8fe:	90 93 61 00 	sts	0x0061, r25
     902:	0f be       	out	0x3f, r0	; 63

	/* Disable clock division */
	clock_prescale_set(clock_div_1);
	ADCSRA |= (1<<ADSC); /* do the longer first conversion */
     904:	80 81       	ld	r24, Z
     906:	80 64       	ori	r24, 0x40	; 64
     908:	80 83       	st	Z, r24
	
	/* set pin 7 (on schematic: D7 = PE6) as input */
	/* all pins are input by default */
	/* enable pullup resistor */
	PORTE |= (1<<PE6);
     90a:	76 9a       	sbi	0x0e, 6	; 14
	
	/* enable pins as output */
	DDRB |= (1<<PB1) | (1<<PB2) | (1<<PB3);
     90c:	84 b1       	in	r24, 0x04	; 4
     90e:	8e 60       	ori	r24, 0x0E	; 14
     910:	84 b9       	out	0x04, r24	; 4
	//DDRC |= (1<<PC6) | (1<<PC7); 
	
	//from e arm, ove later
	DDRB |= (1<<PB6) | (1<<PB7);
     912:	84 b1       	in	r24, 0x04	; 4
     914:	80 6c       	ori	r24, 0xC0	; 192
     916:	84 b9       	out	0x04, r24	; 4

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				DDRB  |=  LEDS_PORTB_LEDS;
     918:	20 9a       	sbi	0x04, 0	; 4
				PORTB |=  LEDS_PORTB_LEDS;
     91a:	28 9a       	sbi	0x05, 0	; 5
				DDRD  |=  LEDS_PORTD_LEDS;
     91c:	55 9a       	sbi	0x0a, 5	; 10
				PORTD |=  LEDS_PORTD_LEDS;
     91e:	5d 9a       	sbi	0x0b, 5	; 11
				DDRC  |=  LEDS_PORTC_LEDS;
     920:	3f 9a       	sbi	0x07, 7	; 7
				PORTC &= ~LEDS_PORTC_LEDS;
     922:	47 98       	cbi	0x08, 7	; 8
	PMIC.CTRL = PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_HILVLEN_bm;
#endif

	/* Hardware Initialization */
	LEDs_Init();
	USB_Init();
     924:	0c 94 fb 0e 	jmp	0x1df6	; 0x1df6 <USB_Init>

00000928 <main>:
}
     928:	ce df       	rcall	.-100    	; 0x8c6 <SetupHardware>
/** Main program entry point. This routine contains the overall program flow, including initial
 *  setup of all components and the main program loop.
 */
int main(void)
{
	SetupHardware();
     92a:	50 d5       	rcall	.+2720   	; 0x13cc <setup_timer>
	setup_timer();
     92c:	81 e0       	ldi	r24, 0x01	; 1
     92e:	3c de       	rcall	.-904    	; 0x5a8 <LEDs_SetAllLEDs>
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
     930:	78 94       	sei
     932:	b2 de       	rcall	.-668    	; 0x698 <lung_module_init>
     934:	88 ea       	ldi	r24, 0xA8	; 168
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
     936:	91 e0       	ldi	r25, 0x01	; 1
	//setup_airwaysensor();
	//Serial_Init(9600, 0);
	//eschar_init();
	//pulse_init(); // moved, so that pulse does not start immediately
	//rfid_init();
	lung_module_init();
     938:	0e 94 b9 12 	call	0x2572	; 0x2572 <HID_Device_USBTask>

	for (;;)
	{
		HID_Device_USBTask(&Generic_HID_Interface);
     93c:	0e 94 4a 11 	call	0x2294	; 0x2294 <USB_USBTask>
     940:	94 de       	rcall	.-728    	; 0x66a <adc_task>
     942:	b6 de       	rcall	.-660    	; 0x6b0 <lung_module_task>
		USB_USBTask();
     944:	f7 cf       	rjmp	.-18     	; 0x934 <main+0xc>

00000946 <EVENT_USB_Device_Connect>:
     946:	80 ea       	ldi	r24, 0xA0	; 160
		adc_task();
     948:	2f ce       	rjmp	.-930    	; 0x5a8 <LEDs_SetAllLEDs>

0000094a <EVENT_USB_Device_Disconnect>:
     94a:	81 e0       	ldi	r24, 0x01	; 1
		//airwaysensor_task(adc_values, sensor_varnces, sensor_evt_thresh, &event_buffer);
		lung_module_task();
     94c:	2d ce       	rjmp	.-934    	; 0x5a8 <LEDs_SetAllLEDs>

0000094e <EVENT_USB_Device_ConfigurationChanged>:
     94e:	88 ea       	ldi	r24, 0xA8	; 168
     950:	91 e0       	ldi	r25, 0x01	; 1
/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
	bool ConfigSuccess = true;

	ConfigSuccess &= HID_Device_ConfigureEndpoints(&Generic_HID_Interface);
     952:	0e 94 a0 12 	call	0x2540	; 0x2540 <HID_Device_ConfigureEndpoints>
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
						break;
					case USB_INT_SOFI:
						UDIEN  |= (1 << SOFE);
     956:	90 91 e2 00 	lds	r25, 0x00E2
     95a:	94 60       	ori	r25, 0x04	; 4
     95c:	90 93 e2 00 	sts	0x00E2, r25

	USB_Device_EnableSOFEvents();

	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
     960:	88 23       	and	r24, r24
     962:	11 f0       	breq	.+4      	; 0x968 <EVENT_USB_Device_ConfigurationChanged+0x1a>
     964:	80 e2       	ldi	r24, 0x20	; 32
     966:	01 c0       	rjmp	.+2      	; 0x96a <EVENT_USB_Device_ConfigurationChanged+0x1c>
     968:	81 e8       	ldi	r24, 0x81	; 129
     96a:	1e ce       	rjmp	.-964    	; 0x5a8 <LEDs_SetAllLEDs>

0000096c <EVENT_USB_Device_ControlRequest>:
     96c:	88 ea       	ldi	r24, 0xA8	; 168
}
     96e:	91 e0       	ldi	r25, 0x01	; 1

/** Event handler for the library USB Control Request reception event. */
void EVENT_USB_Device_ControlRequest(void)
{
	HID_Device_ProcessControlRequest(&Generic_HID_Interface);
     970:	0c 94 66 11 	jmp	0x22cc	; 0x22cc <HID_Device_ProcessControlRequest>

00000974 <EVENT_USB_Device_StartOfFrame>:
}
     974:	80 91 b6 01 	lds	r24, 0x01B6
			 *  \param[in,out] HIDInterfaceInfo  Pointer to a structure containing a HID Class configuration and state.
			 */
			static inline void HID_Device_MillisecondElapsed(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo) ATTR_ALWAYS_INLINE ATTR_NON_NULL_PTR_ARG(1);
			static inline void HID_Device_MillisecondElapsed(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
			{
				if (HIDInterfaceInfo->State.IdleMSRemaining)
     978:	90 91 b7 01 	lds	r25, 0x01B7
     97c:	00 97       	sbiw	r24, 0x00	; 0
     97e:	29 f0       	breq	.+10     	; 0x98a <EVENT_USB_Device_StartOfFrame+0x16>
				  HIDInterfaceInfo->State.IdleMSRemaining--;
     980:	01 97       	sbiw	r24, 0x01	; 1
     982:	90 93 b7 01 	sts	0x01B7, r25
     986:	80 93 b6 01 	sts	0x01B6, r24
     98a:	08 95       	ret

0000098c <CALLBACK_HID_Device_CreateHIDReport>:
bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
                                         uint8_t* const ReportID,
                                         const uint8_t ReportType,
                                         void* ReportData,
                                         uint16_t* const ReportSize)
{
     98c:	8f 92       	push	r8
     98e:	9f 92       	push	r9
     990:	af 92       	push	r10
     992:	bf 92       	push	r11
     994:	cf 92       	push	r12
     996:	df 92       	push	r13
     998:	ef 92       	push	r14
     99a:	ff 92       	push	r15
     99c:	0f 93       	push	r16
     99e:	1f 93       	push	r17
     9a0:	cf 93       	push	r28
     9a2:	df 93       	push	r29
     9a4:	cd b7       	in	r28, 0x3d	; 61
     9a6:	de b7       	in	r29, 0x3e	; 62
     9a8:	2b 97       	sbiw	r28, 0x0b	; 11
     9aa:	0f b6       	in	r0, 0x3f	; 63
     9ac:	f8 94       	cli
     9ae:	de bf       	out	0x3e, r29	; 62
     9b0:	0f be       	out	0x3f, r0	; 63
     9b2:	cd bf       	out	0x3d, r28	; 61
     9b4:	5b 01       	movw	r10, r22
     9b6:	79 01       	movw	r14, r18
     9b8:	48 01       	movw	r8, r16
	//uint16_t cb_strlen;
	//uint16_t strlen_rem;
	TIME_t ms;
	UNUSED(HIDInterfaceInfo);
	const event_t* nextevt;
	switch (ReportType) {
     9ba:	44 23       	and	r20, r20
     9bc:	09 f4       	brne	.+2      	; 0x9c0 <CALLBACK_HID_Device_CreateHIDReport+0x34>
     9be:	5e c0       	rjmp	.+188    	; 0xa7c <CALLBACK_HID_Device_CreateHIDReport+0xf0>
     9c0:	42 30       	cpi	r20, 0x02	; 2
     9c2:	09 f0       	breq	.+2      	; 0x9c6 <CALLBACK_HID_Device_CreateHIDReport+0x3a>
     9c4:	65 c3       	rjmp	.+1738   	; 0x1090 <__stack+0x591>
				
				*ReportSize = STRING_DESC_REPORT_HACK_SIZE;
				stm_state = STRINGSTM_STATE_BASE;
				return true;
			} else */
			if (*ReportID == TIMESTAMP_OFFSET_FR_ID) {
     9c6:	db 01       	movw	r26, r22
     9c8:	8c 91       	ld	r24, X
     9ca:	84 30       	cpi	r24, 0x04	; 4
     9cc:	31 f4       	brne	.+12     	; 0x9da <CALLBACK_HID_Device_CreateHIDReport+0x4e>
				//return the current timestamp
				ms = host_millis();
     9ce:	40 d5       	rcall	.+2688   	; 0x1450 <host_millis>
     9d0:	87 01       	movw	r16, r14
				time_to_wire(ms, Data);
     9d2:	27 d6       	rcall	.+3150   	; 0x1622 <time_to_wire>
     9d4:	88 e0       	ldi	r24, 0x08	; 8
     9d6:	90 e0       	ldi	r25, 0x00	; 0
				*ReportSize = TIMESTAMP_FR_SIZE;
     9d8:	18 c0       	rjmp	.+48     	; 0xa0a <CALLBACK_HID_Device_CreateHIDReport+0x7e>
     9da:	86 30       	cpi	r24, 0x06	; 6
     9dc:	d9 f4       	brne	.+54     	; 0xa14 <CALLBACK_HID_Device_CreateHIDReport+0x88>
				return true;
			} else if (*ReportID == SET_SENS_THRESH_REPORT_ID) {
     9de:	58 e9       	ldi	r21, 0x98	; 152
     9e0:	c5 2e       	mov	r12, r21
     9e2:	51 e0       	ldi	r21, 0x01	; 1
     9e4:	d5 2e       	mov	r13, r21
     9e6:	89 01       	movw	r16, r18
     9e8:	d6 01       	movw	r26, r12
     9ea:	6d 91       	ld	r22, X+
				for (int i = 0; i < 4; i++) {
					float_to_wire(sensor_evt_thresh[i], Data + 4*i);
     9ec:	7d 91       	ld	r23, X+
     9ee:	8d 91       	ld	r24, X+
     9f0:	9d 91       	ld	r25, X+
     9f2:	6d 01       	movw	r12, r26
     9f4:	a8 01       	movw	r20, r16
     9f6:	aa d4       	rcall	.+2388   	; 0x134c <float_to_wire>
     9f8:	0c 5f       	subi	r16, 0xFC	; 252
     9fa:	1f 4f       	sbci	r17, 0xFF	; 255
     9fc:	b8 ea       	ldi	r27, 0xA8	; 168
     9fe:	cb 16       	cp	r12, r27
     a00:	b1 e0       	ldi	r27, 0x01	; 1
				ms = host_millis();
				time_to_wire(ms, Data);
				*ReportSize = TIMESTAMP_FR_SIZE;
				return true;
			} else if (*ReportID == SET_SENS_THRESH_REPORT_ID) {
				for (int i = 0; i < 4; i++) {
     a02:	db 06       	cpc	r13, r27
     a04:	89 f7       	brne	.-30     	; 0x9e8 <CALLBACK_HID_Device_CreateHIDReport+0x5c>
     a06:	80 e1       	ldi	r24, 0x10	; 16
     a08:	90 e0       	ldi	r25, 0x00	; 0
     a0a:	f4 01       	movw	r30, r8
					float_to_wire(sensor_evt_thresh[i], Data + 4*i);
				}
				*ReportSize = SET_SENS_THRESH_REPORT_SIZE;
     a0c:	91 83       	std	Z+1, r25	; 0x01
     a0e:	80 83       	st	Z, r24
     a10:	81 e0       	ldi	r24, 0x01	; 1
     a12:	3f c3       	rjmp	.+1662   	; 0x1092 <__stack+0x593>
     a14:	81 30       	cpi	r24, 0x01	; 1
				return true;
     a16:	a9 f4       	brne	.+42     	; 0xa42 <CALLBACK_HID_Device_CreateHIDReport+0xb6>
     a18:	d9 01       	movw	r26, r18
			} else if (*ReportID == REPORT_MAP_STRING_ID) {
     a1a:	81 e1       	ldi	r24, 0x11	; 17
     a1c:	8d 93       	st	X+, r24
				int len = bio_report_string.len;
				len = len > 0xfe ? 0xfe : len;
				Data[0] = len;
     a1e:	80 e0       	ldi	r24, 0x00	; 0
     a20:	90 e0       	ldi	r25, 0x00	; 0
     a22:	01 96       	adiw	r24, 0x01	; 1
 *  \param[out]    ReportData  Pointer to a buffer where the created report should be stored
 *  \param[out]    ReportSize  Number of bytes written in the report (or zero if no report is to be sent)
 *
 *  \return Boolean \c true to force the sending of the report, \c false to let the library determine if it needs to be sent
 */
bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
     a24:	fc 01       	movw	r30, r24
     a26:	ea 51       	subi	r30, 0x1A	; 26
			} else if (*ReportID == REPORT_MAP_STRING_ID) {
				int len = bio_report_string.len;
				len = len > 0xfe ? 0xfe : len;
				Data[0] = len;
				for (int i = 0; i < len; i++) {
					Data[1+i] = pgm_read_byte(bio_report_string.content + i);
     a28:	fe 4f       	sbci	r31, 0xFE	; 254
     a2a:	e4 91       	lpm	r30, Z
     a2c:	ed 93       	st	X+, r30
     a2e:	81 31       	cpi	r24, 0x11	; 17
     a30:	91 05       	cpc	r25, r1
     a32:	b9 f7       	brne	.-18     	; 0xa22 <CALLBACK_HID_Device_CreateHIDReport+0x96>
				return true;
			} else if (*ReportID == REPORT_MAP_STRING_ID) {
				int len = bio_report_string.len;
				len = len > 0xfe ? 0xfe : len;
				Data[0] = len;
				for (int i = 0; i < len; i++) {
     a34:	8e ef       	ldi	r24, 0xFE	; 254
     a36:	90 e0       	ldi	r25, 0x00	; 0
     a38:	d4 01       	movw	r26, r8
					Data[1+i] = pgm_read_byte(bio_report_string.content + i);
				}
				*ReportSize = REPORT_MAP_STRING_SIZE;
     a3a:	11 96       	adiw	r26, 0x01	; 1
     a3c:	9c 93       	st	X, r25
     a3e:	8e 93       	st	-X, r24
     a40:	e7 cf       	rjmp	.-50     	; 0xa10 <CALLBACK_HID_Device_CreateHIDReport+0x84>
     a42:	82 30       	cpi	r24, 0x02	; 2
     a44:	89 f4       	brne	.+34     	; 0xa68 <CALLBACK_HID_Device_CreateHIDReport+0xdc>
     a46:	d9 01       	movw	r26, r18
				return true;
			} else if (*ReportID == DEVICE_NAME_REPORT_ID) {
     a48:	86 e0       	ldi	r24, 0x06	; 6
     a4a:	8d 93       	st	X+, r24
				int len = device_name_string.len;
				len = len > 0xfe ? 0xfe : len;
				Data[0] = len;
     a4c:	80 e0       	ldi	r24, 0x00	; 0
     a4e:	90 e0       	ldi	r25, 0x00	; 0
     a50:	01 96       	adiw	r24, 0x01	; 1
 *  \param[out]    ReportData  Pointer to a buffer where the created report should be stored
 *  \param[out]    ReportSize  Number of bytes written in the report (or zero if no report is to be sent)
 *
 *  \return Boolean \c true to force the sending of the report, \c false to let the library determine if it needs to be sent
 */
bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
     a52:	fc 01       	movw	r30, r24
     a54:	e1 5d       	subi	r30, 0xD1	; 209
			} else if (*ReportID == DEVICE_NAME_REPORT_ID) {
				int len = device_name_string.len;
				len = len > 0xfe ? 0xfe : len;
				Data[0] = len;
				for (int i = 0; i < len; i++) {
					Data[1+i] = pgm_read_byte(device_name_string.content + i);
     a56:	fe 4f       	sbci	r31, 0xFE	; 254
     a58:	e4 91       	lpm	r30, Z
     a5a:	ed 93       	st	X+, r30
     a5c:	86 30       	cpi	r24, 0x06	; 6
     a5e:	91 05       	cpc	r25, r1
     a60:	b9 f7       	brne	.-18     	; 0xa50 <CALLBACK_HID_Device_CreateHIDReport+0xc4>
				return true;
			} else if (*ReportID == DEVICE_NAME_REPORT_ID) {
				int len = device_name_string.len;
				len = len > 0xfe ? 0xfe : len;
				Data[0] = len;
				for (int i = 0; i < len; i++) {
     a62:	8f ef       	ldi	r24, 0xFF	; 255
     a64:	90 e0       	ldi	r25, 0x00	; 0
     a66:	d1 cf       	rjmp	.-94     	; 0xa0a <CALLBACK_HID_Device_CreateHIDReport+0x7e>
					Data[1+i] = pgm_read_byte(device_name_string.content + i);
				}
				*ReportSize = DEVICE_NAME_REPORT_SIZE;
     a68:	8f 30       	cpi	r24, 0x0F	; 15
     a6a:	09 f0       	breq	.+2      	; 0xa6e <CALLBACK_HID_Device_CreateHIDReport+0xe2>
     a6c:	11 c3       	rjmp	.+1570   	; 0x1090 <__stack+0x591>
				return true;
			} else if (*ReportID == NO_DATA_REPORT_ID) {
     a6e:	80 91 3e 03 	lds	r24, 0x033E
     a72:	d9 01       	movw	r26, r18
				Data[0] = lung_st;
     a74:	8c 93       	st	X, r24
     a76:	84 e0       	ldi	r24, 0x04	; 4
     a78:	90 e0       	ldi	r25, 0x00	; 0
     a7a:	c7 cf       	rjmp	.-114    	; 0xa0a <CALLBACK_HID_Device_CreateHIDReport+0x7e>
				*ReportSize = NO_DATA_REPORT_SIZE;
     a7c:	db 01       	movw	r26, r22
     a7e:	0c 91       	ld	r16, X
     a80:	07 30       	cpi	r16, 0x07	; 7
		However, every report id must also have a clause for if it is specicifically requested. 
		*/
		//TODO use a table of functions that might set the report, call each in turn
		//this will allow better operation with multiple reports, and allow each module's variables to be encapsulated in their files
			
			if ((*ReportID == GET_SENSOR_EVENT_REPORT_ID) /*(*ReportID == 0)*/) {
     a82:	a1 f4       	brne	.+40     	; 0xaac <CALLBACK_HID_Device_CreateHIDReport+0x120>
     a84:	80 91 14 01 	lds	r24, 0x0114
     a88:	90 91 15 01 	lds	r25, 0x0115
				//FIXME duplicated code here. Not sure how to handle this duplication as this code must be on the control path when this specific report is requested.
				if (event_buffer.occupancy) { // nextevt != NULL) {
     a8c:	00 97       	sbiw	r24, 0x00	; 0
     a8e:	09 f4       	brne	.+2      	; 0xa92 <CALLBACK_HID_Device_CreateHIDReport+0x106>
     a90:	ff c2       	rjmp	.+1534   	; 0x1090 <__stack+0x591>
     a92:	8e e0       	ldi	r24, 0x0E	; 14
     a94:	91 e0       	ldi	r25, 0x01	; 1
     a96:	08 d4       	rcall	.+2064   	; 0x12a8 <deq_event>
					
					nextevt = deq_event(&event_buffer);
     a98:	b7 01       	movw	r22, r14
     a9a:	34 d4       	rcall	.+2152   	; 0x1304 <event_to_wire>
     a9c:	8d e0       	ldi	r24, 0x0D	; 13
     a9e:	90 e0       	ldi	r25, 0x00	; 0
					event_to_wire(nextevt, Data);
     aa0:	f4 01       	movw	r30, r8
     aa2:	91 83       	std	Z+1, r25	; 0x01
     aa4:	80 83       	st	Z, r24
					*ReportSize = GET_SENSOR_EVENT_REPORT_SIZE;
     aa6:	d5 01       	movw	r26, r10
     aa8:	0c 93       	st	X, r16
     aaa:	b2 cf       	rjmp	.-156    	; 0xa10 <CALLBACK_HID_Device_CreateHIDReport+0x84>
     aac:	03 30       	cpi	r16, 0x03	; 3
     aae:	09 f0       	breq	.+2      	; 0xab2 <CALLBACK_HID_Device_CreateHIDReport+0x126>
					*ReportID = GET_SENSOR_EVENT_REPORT_ID;
     ab0:	3f c0       	rjmp	.+126    	; 0xb30 <__stack+0x31>
     ab2:	fe 01       	movw	r30, r28
     ab4:	34 96       	adiw	r30, 0x04	; 4
					return true;
				} else {
					return false;
				}
			} else if ((*ReportID == 3) /*|| (*ReportID == 0)*/) { //show adc output
     ab6:	a0 e0       	ldi	r26, 0x00	; 0
     ab8:	b1 e0       	ldi	r27, 0x01	; 1
     aba:	88 e0       	ldi	r24, 0x08	; 8
				int desired[] = {1, 4, 6, 7}; // 1467 is real, use bogus only for checking
     abc:	0d 90       	ld	r0, X+
     abe:	01 92       	st	Z+, r0
     ac0:	81 50       	subi	r24, 0x01	; 1
     ac2:	e1 f7       	brne	.-8      	; 0xabc <CALLBACK_HID_Device_CreateHIDReport+0x130>
     ac4:	ce 01       	movw	r24, r28
     ac6:	04 96       	adiw	r24, 0x04	; 4
     ac8:	b7 01       	movw	r22, r14
     aca:	9e 01       	movw	r18, r28
     acc:	24 5f       	subi	r18, 0xF4	; 244
     ace:	3f 4f       	sbci	r19, 0xFF	; 255
     ad0:	dc 01       	movw	r26, r24
     ad2:	ed 91       	ld	r30, X+
 *  \param[out]    ReportData  Pointer to a buffer where the created report should be stored
 *  \param[out]    ReportSize  Number of bytes written in the report (or zero if no report is to be sent)
 *
 *  \return Boolean \c true to force the sending of the report, \c false to let the library determine if it needs to be sent
 */
bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
     ad4:	fd 91       	ld	r31, X+
     ad6:	cd 01       	movw	r24, r26
     ad8:	ee 0f       	add	r30, r30
					return false;
				}
			} else if ((*ReportID == 3) /*|| (*ReportID == 0)*/) { //show adc output
				int desired[] = {1, 4, 6, 7}; // 1467 is real, use bogus only for checking
				for (int adcix = 0; adcix < 4; adcix++) {
					Data[2*adcix + 1] = (adc_values[desired[adcix]] >> 8);
     ada:	ff 1f       	adc	r31, r31
     adc:	e6 57       	subi	r30, 0x76	; 118
     ade:	fa 4f       	sbci	r31, 0xFA	; 250
     ae0:	41 81       	ldd	r20, Z+1	; 0x01
     ae2:	db 01       	movw	r26, r22
     ae4:	11 96       	adiw	r26, 0x01	; 1
     ae6:	4c 93       	st	X, r20
     ae8:	11 97       	sbiw	r26, 0x01	; 1
     aea:	40 81       	ld	r20, Z
     aec:	4c 93       	st	X, r20
     aee:	6e 5f       	subi	r22, 0xFE	; 254
     af0:	7f 4f       	sbci	r23, 0xFF	; 255
     af2:	82 17       	cp	r24, r18
					Data[2*adcix] = adc_values[desired[adcix]] & 0xff;
     af4:	93 07       	cpc	r25, r19
     af6:	61 f7       	brne	.-40     	; 0xad0 <CALLBACK_HID_Device_CreateHIDReport+0x144>
     af8:	84 e5       	ldi	r24, 0x54	; 84
     afa:	c8 2e       	mov	r12, r24
				} else {
					return false;
				}
			} else if ((*ReportID == 3) /*|| (*ReportID == 0)*/) { //show adc output
				int desired[] = {1, 4, 6, 7}; // 1467 is real, use bogus only for checking
				for (int adcix = 0; adcix < 4; adcix++) {
     afc:	85 e0       	ldi	r24, 0x05	; 5
     afe:	d8 2e       	mov	r13, r24
     b00:	87 01       	movw	r16, r14
     b02:	08 5f       	subi	r16, 0xF8	; 248
     b04:	1f 4f       	sbci	r17, 0xFF	; 255
     b06:	f6 01       	movw	r30, r12
     b08:	61 91       	ld	r22, Z+
 *  \param[out]    ReportData  Pointer to a buffer where the created report should be stored
 *  \param[out]    ReportSize  Number of bytes written in the report (or zero if no report is to be sent)
 *
 *  \return Boolean \c true to force the sending of the report, \c false to let the library determine if it needs to be sent
 */
bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
     b0a:	71 91       	ld	r23, Z+
     b0c:	81 91       	ld	r24, Z+
     b0e:	91 91       	ld	r25, Z+
				for (int adcix = 0; adcix < 4; adcix++) {
					Data[2*adcix + 1] = (adc_values[desired[adcix]] >> 8);
					Data[2*adcix] = adc_values[desired[adcix]] & 0xff;
				}
				for (int i = 0; i < 4; i ++) {
					float_to_wire(sensor_varnces[i],Data+8+4*i);
     b10:	6f 01       	movw	r12, r30
     b12:	a8 01       	movw	r20, r16
     b14:	1b d4       	rcall	.+2102   	; 0x134c <float_to_wire>
     b16:	0c 5f       	subi	r16, 0xFC	; 252
     b18:	1f 4f       	sbci	r17, 0xFF	; 255
     b1a:	f4 e6       	ldi	r31, 0x64	; 100
     b1c:	cf 16       	cp	r12, r31
     b1e:	f5 e0       	ldi	r31, 0x05	; 5
     b20:	df 06       	cpc	r13, r31
     b22:	89 f7       	brne	.-30     	; 0xb06 <__stack+0x7>
     b24:	83 e0       	ldi	r24, 0x03	; 3
				int desired[] = {1, 4, 6, 7}; // 1467 is real, use bogus only for checking
				for (int adcix = 0; adcix < 4; adcix++) {
					Data[2*adcix + 1] = (adc_values[desired[adcix]] >> 8);
					Data[2*adcix] = adc_values[desired[adcix]] & 0xff;
				}
				for (int i = 0; i < 4; i ++) {
     b26:	d5 01       	movw	r26, r10
     b28:	8c 93       	st	X, r24
     b2a:	88 e1       	ldi	r24, 0x18	; 24
     b2c:	90 e0       	ldi	r25, 0x00	; 0
     b2e:	6d cf       	rjmp	.-294    	; 0xa0a <CALLBACK_HID_Device_CreateHIDReport+0x7e>
					float_to_wire(sensor_varnces[i],Data+8+4*i);
				}
				*ReportID = 3;
     b30:	00 23       	and	r16, r16
     b32:	09 f0       	breq	.+2      	; 0xb36 <__stack+0x37>
     b34:	ad c2       	rjmp	.+1370   	; 0x1090 <__stack+0x591>
				*ReportSize = 24;
     b36:	80 91 69 05 	lds	r24, 0x0569
     b3a:	88 23       	and	r24, r24
				return true;
			} else  if (*ReportID == 0) {
     b3c:	09 f4       	brne	.+2      	; 0xb40 <__stack+0x41>
     b3e:	3a c0       	rjmp	.+116    	; 0xbb4 <__stack+0xb5>
     b40:	e0 91 e6 02 	lds	r30, 0x02E6
				
				if (rfid_usable_to_send) {
     b44:	f0 91 e7 02 	lds	r31, 0x02E7
     b48:	80 81       	ld	r24, Z
     b4a:	84 34       	cpi	r24, 0x44	; 68
					char *msgbuf;
					msgbuf = *usable_message;
     b4c:	09 f0       	breq	.+2      	; 0xb50 <__stack+0x51>
     b4e:	a0 c2       	rjmp	.+1344   	; 0x1090 <__stack+0x591>
     b50:	81 81       	ldd	r24, Z+1	; 0x01
     b52:	86 31       	cpi	r24, 0x16	; 22
					if (msgbuf[0] == 0x44 && msgbuf[1] == 0x16) {
     b54:	09 f0       	breq	.+2      	; 0xb58 <__stack+0x59>
     b56:	9c c2       	rjmp	.+1336   	; 0x1090 <__stack+0x591>
     b58:	1b 82       	std	Y+3, r1	; 0x03
     b5a:	1a 82       	std	Y+2, r1	; 0x02
     b5c:	cf 01       	movw	r24, r30
     b5e:	0a 96       	adiw	r24, 0x0a	; 10
     b60:	be 01       	movw	r22, r28
     b62:	6f 5f       	subi	r22, 0xFF	; 255
						unsigned char* tagstart = (unsigned char*) msgbuf+10;
						unsigned char pstr_len;
						const char* pstr_msg = NULL;
     b64:	7f 4f       	sbci	r23, 0xFF	; 255
     b66:	ae 01       	movw	r20, r28
						
						if (classify_tag(tagstart, &pstr_len, &pstr_msg)) {
     b68:	4e 5f       	subi	r20, 0xFE	; 254
     b6a:	5f 4f       	sbci	r21, 0xFF	; 255
     b6c:	c0 d5       	rcall	.+2944   	; 0x16ee <classify_tag>
     b6e:	88 23       	and	r24, r24
     b70:	09 f4       	brne	.+2      	; 0xb74 <__stack+0x75>
     b72:	8e c2       	rjmp	.+1308   	; 0x1090 <__stack+0x591>
     b74:	8a 81       	ldd	r24, Y+2	; 0x02
     b76:	9b 81       	ldd	r25, Y+3	; 0x03
     b78:	00 97       	sbiw	r24, 0x00	; 0
     b7a:	09 f4       	brne	.+2      	; 0xb7e <__stack+0x7f>
     b7c:	89 c2       	rjmp	.+1298   	; 0x1090 <__stack+0x591>
     b7e:	1e d6       	rcall	.+3132   	; 0x17bc <rfid_enable_buzzer>
     b80:	99 81       	ldd	r25, Y+1	; 0x01
							if (pstr_msg == NULL) {
     b82:	8a 81       	ldd	r24, Y+2	; 0x02
     b84:	2b 81       	ldd	r18, Y+3	; 0x03
     b86:	d7 01       	movw	r26, r14
     b88:	9d 93       	st	X+, r25
     b8a:	e8 2f       	mov	r30, r24
								//Recognized, but sent recently. take no action.
								return false;
							} else {
								rfid_enable_buzzer();
     b8c:	f2 2f       	mov	r31, r18
     b8e:	03 c0       	rjmp	.+6      	; 0xb96 <__stack+0x97>
								SEND_PROX_UGLY_HACK(pstr_len,pstr_msg);
     b90:	24 91       	lpm	r18, Z
     b92:	2d 93       	st	X+, r18
     b94:	31 96       	adiw	r30, 0x01	; 1
     b96:	2e 2f       	mov	r18, r30
     b98:	28 1b       	sub	r18, r24
     b9a:	29 17       	cp	r18, r25
     b9c:	c8 f3       	brcs	.-14     	; 0xb90 <__stack+0x91>
     b9e:	83 e1       	ldi	r24, 0x13	; 19
     ba0:	d5 01       	movw	r26, r10
     ba2:	8c 93       	st	X, r24
     ba4:	8f ef       	ldi	r24, 0xFF	; 255
     ba6:	90 e0       	ldi	r25, 0x00	; 0
     ba8:	f4 01       	movw	r30, r8
     baa:	91 83       	std	Z+1, r25	; 0x01
     bac:	80 83       	st	Z, r24
     bae:	10 92 69 05 	sts	0x0569, r1
     bb2:	2e cf       	rjmp	.-420    	; 0xa10 <CALLBACK_HID_Device_CreateHIDReport+0x84>
     bb4:	80 91 7d 05 	lds	r24, 0x057D
     bb8:	88 23       	and	r24, r24
     bba:	c9 f0       	breq	.+50     	; 0xbee <__stack+0xef>
     bbc:	d9 01       	movw	r26, r18
								rfid_usable_to_send = 0;
     bbe:	83 e1       	ldi	r24, 0x13	; 19
     bc0:	8d 93       	st	X+, r24
     bc2:	80 e0       	ldi	r24, 0x00	; 0
					*ReportSize = BIO_EVENT_REPORT_SIZE;
					prox2act_msg_waiting = 0;
					return true;
				}
#endif
				else if (vent_msg_waiting) {
     bc4:	90 e0       	ldi	r25, 0x00	; 0
     bc6:	01 96       	adiw	r24, 0x01	; 1
     bc8:	fc 01       	movw	r30, r24
     bca:	ef 52       	subi	r30, 0x2F	; 47
					SEND_ACT(vent_msg_str);
     bcc:	fe 4f       	sbci	r31, 0xFE	; 254
     bce:	e4 91       	lpm	r30, Z
     bd0:	ed 93       	st	X+, r30
 *  \param[out]    ReportData  Pointer to a buffer where the created report should be stored
 *  \param[out]    ReportSize  Number of bytes written in the report (or zero if no report is to be sent)
 *
 *  \return Boolean \c true to force the sending of the report, \c false to let the library determine if it needs to be sent
 */
bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
     bd2:	83 31       	cpi	r24, 0x13	; 19
     bd4:	91 05       	cpc	r25, r1
					prox2act_msg_waiting = 0;
					return true;
				}
#endif
				else if (vent_msg_waiting) {
					SEND_ACT(vent_msg_str);
     bd6:	b9 f7       	brne	.-18     	; 0xbc6 <__stack+0xc7>
     bd8:	82 e1       	ldi	r24, 0x12	; 18
     bda:	d5 01       	movw	r26, r10
     bdc:	8c 93       	st	X, r24
     bde:	8f ef       	ldi	r24, 0xFF	; 255
     be0:	90 e0       	ldi	r25, 0x00	; 0
     be2:	f4 01       	movw	r30, r8
     be4:	91 83       	std	Z+1, r25	; 0x01
     be6:	80 83       	st	Z, r24
     be8:	10 92 7d 05 	sts	0x057D, r1
     bec:	11 cf       	rjmp	.-478    	; 0xa10 <CALLBACK_HID_Device_CreateHIDReport+0x84>
     bee:	80 91 65 05 	lds	r24, 0x0565
     bf2:	88 23       	and	r24, r24
     bf4:	c9 f0       	breq	.+50     	; 0xc28 <__stack+0x129>
     bf6:	d9 01       	movw	r26, r18
					vent_msg_waiting = 0;
     bf8:	87 e0       	ldi	r24, 0x07	; 7
     bfa:	8d 93       	st	X+, r24
     bfc:	80 e0       	ldi	r24, 0x00	; 0
					return true;
				} else if (bvm_off_msg_waiting) {
     bfe:	90 e0       	ldi	r25, 0x00	; 0
     c00:	01 96       	adiw	r24, 0x01	; 1
     c02:	fc 01       	movw	r30, r24
     c04:	e8 53       	subi	r30, 0x38	; 56
					SEND_ACT(bvm_off_msg_str);
     c06:	fe 4f       	sbci	r31, 0xFE	; 254
     c08:	e4 91       	lpm	r30, Z
     c0a:	ed 93       	st	X+, r30
 *  \param[out]    ReportData  Pointer to a buffer where the created report should be stored
 *  \param[out]    ReportSize  Number of bytes written in the report (or zero if no report is to be sent)
 *
 *  \return Boolean \c true to force the sending of the report, \c false to let the library determine if it needs to be sent
 */
bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
     c0c:	87 30       	cpi	r24, 0x07	; 7
     c0e:	91 05       	cpc	r25, r1
				else if (vent_msg_waiting) {
					SEND_ACT(vent_msg_str);
					vent_msg_waiting = 0;
					return true;
				} else if (bvm_off_msg_waiting) {
					SEND_ACT(bvm_off_msg_str);
     c10:	b9 f7       	brne	.-18     	; 0xc00 <__stack+0x101>
     c12:	82 e1       	ldi	r24, 0x12	; 18
     c14:	d5 01       	movw	r26, r10
     c16:	8c 93       	st	X, r24
     c18:	8f ef       	ldi	r24, 0xFF	; 255
     c1a:	90 e0       	ldi	r25, 0x00	; 0
     c1c:	f4 01       	movw	r30, r8
     c1e:	91 83       	std	Z+1, r25	; 0x01
     c20:	80 83       	st	Z, r24
     c22:	10 92 65 05 	sts	0x0565, r1
     c26:	f4 ce       	rjmp	.-536    	; 0xa10 <CALLBACK_HID_Device_CreateHIDReport+0x84>
     c28:	80 91 88 05 	lds	r24, 0x0588
     c2c:	88 23       	and	r24, r24
     c2e:	c9 f0       	breq	.+50     	; 0xc62 <__stack+0x163>
     c30:	d9 01       	movw	r26, r18
					bvm_off_msg_waiting = 0;
     c32:	8c e1       	ldi	r24, 0x1C	; 28
     c34:	8d 93       	st	X+, r24
     c36:	80 e0       	ldi	r24, 0x00	; 0
					return true;
				} else if (mainstem_msg_waiting) {
     c38:	90 e0       	ldi	r25, 0x00	; 0
     c3a:	01 96       	adiw	r24, 0x01	; 1
     c3c:	fc 01       	movw	r30, r24
     c3e:	e6 55       	subi	r30, 0x56	; 86
					SEND_ACT(mainstem_msg_str);
     c40:	fe 4f       	sbci	r31, 0xFE	; 254
     c42:	e4 91       	lpm	r30, Z
     c44:	ed 93       	st	X+, r30
 *  \param[out]    ReportData  Pointer to a buffer where the created report should be stored
 *  \param[out]    ReportSize  Number of bytes written in the report (or zero if no report is to be sent)
 *
 *  \return Boolean \c true to force the sending of the report, \c false to let the library determine if it needs to be sent
 */
bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
     c46:	8c 31       	cpi	r24, 0x1C	; 28
     c48:	91 05       	cpc	r25, r1
				} else if (bvm_off_msg_waiting) {
					SEND_ACT(bvm_off_msg_str);
					bvm_off_msg_waiting = 0;
					return true;
				} else if (mainstem_msg_waiting) {
					SEND_ACT(mainstem_msg_str);
     c4a:	b9 f7       	brne	.-18     	; 0xc3a <__stack+0x13b>
     c4c:	82 e1       	ldi	r24, 0x12	; 18
     c4e:	d5 01       	movw	r26, r10
     c50:	8c 93       	st	X, r24
     c52:	8f ef       	ldi	r24, 0xFF	; 255
     c54:	90 e0       	ldi	r25, 0x00	; 0
     c56:	f4 01       	movw	r30, r8
     c58:	91 83       	std	Z+1, r25	; 0x01
     c5a:	80 83       	st	Z, r24
     c5c:	10 92 88 05 	sts	0x0588, r1
     c60:	d7 ce       	rjmp	.-594    	; 0xa10 <CALLBACK_HID_Device_CreateHIDReport+0x84>
     c62:	80 91 53 05 	lds	r24, 0x0553
     c66:	88 23       	and	r24, r24
     c68:	c9 f0       	breq	.+50     	; 0xc9c <__stack+0x19d>
     c6a:	d9 01       	movw	r26, r18
					mainstem_msg_waiting = 0;
     c6c:	8e e0       	ldi	r24, 0x0E	; 14
     c6e:	8d 93       	st	X+, r24
     c70:	80 e0       	ldi	r24, 0x00	; 0
					return true;
				} else if (hypervent_msg_waiting) {
     c72:	90 e0       	ldi	r25, 0x00	; 0
     c74:	01 96       	adiw	r24, 0x01	; 1
     c76:	fc 01       	movw	r30, r24
     c78:	e6 56       	subi	r30, 0x66	; 102
					SEND_ACT(hypervent_msg_str);
     c7a:	fe 4f       	sbci	r31, 0xFE	; 254
     c7c:	e4 91       	lpm	r30, Z
     c7e:	ed 93       	st	X+, r30
 *  \param[out]    ReportData  Pointer to a buffer where the created report should be stored
 *  \param[out]    ReportSize  Number of bytes written in the report (or zero if no report is to be sent)
 *
 *  \return Boolean \c true to force the sending of the report, \c false to let the library determine if it needs to be sent
 */
bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
     c80:	8e 30       	cpi	r24, 0x0E	; 14
     c82:	91 05       	cpc	r25, r1
				} else if (mainstem_msg_waiting) {
					SEND_ACT(mainstem_msg_str);
					mainstem_msg_waiting = 0;
					return true;
				} else if (hypervent_msg_waiting) {
					SEND_ACT(hypervent_msg_str);
     c84:	b9 f7       	brne	.-18     	; 0xc74 <__stack+0x175>
     c86:	82 e1       	ldi	r24, 0x12	; 18
     c88:	d5 01       	movw	r26, r10
     c8a:	8c 93       	st	X, r24
     c8c:	8f ef       	ldi	r24, 0xFF	; 255
     c8e:	90 e0       	ldi	r25, 0x00	; 0
     c90:	f4 01       	movw	r30, r8
     c92:	91 83       	std	Z+1, r25	; 0x01
     c94:	80 83       	st	Z, r24
     c96:	10 92 53 05 	sts	0x0553, r1
     c9a:	ba ce       	rjmp	.-652    	; 0xa10 <CALLBACK_HID_Device_CreateHIDReport+0x84>
     c9c:	80 91 82 05 	lds	r24, 0x0582
     ca0:	88 23       	and	r24, r24
     ca2:	c9 f0       	breq	.+50     	; 0xcd6 <__stack+0x1d7>
     ca4:	82 e0       	ldi	r24, 0x02	; 2
					hypervent_msg_waiting = 0;
     ca6:	d9 01       	movw	r26, r18
     ca8:	8c 93       	st	X, r24
     caa:	e7 e9       	ldi	r30, 0x97	; 151
					return true;
				} else if (o2_msg_waiting) {
     cac:	f1 e0       	ldi	r31, 0x01	; 1
     cae:	84 91       	lpm	r24, Z
     cb0:	11 96       	adiw	r26, 0x01	; 1
     cb2:	8c 93       	st	X, r24
					SEND_ACT(o2_msg_str);
     cb4:	11 97       	sbiw	r26, 0x01	; 1
     cb6:	31 96       	adiw	r30, 0x01	; 1
     cb8:	e4 91       	lpm	r30, Z
     cba:	12 96       	adiw	r26, 0x02	; 2
     cbc:	ec 93       	st	X, r30
     cbe:	82 e1       	ldi	r24, 0x12	; 18
     cc0:	fb 01       	movw	r30, r22
     cc2:	80 83       	st	Z, r24
     cc4:	8f ef       	ldi	r24, 0xFF	; 255
     cc6:	90 e0       	ldi	r25, 0x00	; 0
     cc8:	d4 01       	movw	r26, r8
     cca:	11 96       	adiw	r26, 0x01	; 1
     ccc:	9c 93       	st	X, r25
     cce:	8e 93       	st	-X, r24
     cd0:	10 92 82 05 	sts	0x0582, r1
     cd4:	9d ce       	rjmp	.-710    	; 0xa10 <CALLBACK_HID_Device_CreateHIDReport+0x84>
     cd6:	80 91 78 05 	lds	r24, 0x0578
     cda:	88 23       	and	r24, r24
     cdc:	d1 f0       	breq	.+52     	; 0xd12 <__stack+0x213>
     cde:	d9 01       	movw	r26, r18
					o2_msg_waiting = 0;
     ce0:	84 e0       	ldi	r24, 0x04	; 4
     ce2:	8d 93       	st	X+, r24
     ce4:	80 e0       	ldi	r24, 0x00	; 0
					return true;
				} else if (blip_msg_waiting) {
     ce6:	90 e0       	ldi	r25, 0x00	; 0
     ce8:	01 96       	adiw	r24, 0x01	; 1
     cea:	fc 01       	movw	r30, r24
     cec:	e7 5d       	subi	r30, 0xD7	; 215
					SEND_ACT(blip_str);
     cee:	fe 4f       	sbci	r31, 0xFE	; 254
     cf0:	e4 91       	lpm	r30, Z
     cf2:	ed 93       	st	X+, r30
 *  \param[out]    ReportData  Pointer to a buffer where the created report should be stored
 *  \param[out]    ReportSize  Number of bytes written in the report (or zero if no report is to be sent)
 *
 *  \return Boolean \c true to force the sending of the report, \c false to let the library determine if it needs to be sent
 */
bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
     cf4:	84 30       	cpi	r24, 0x04	; 4
     cf6:	91 05       	cpc	r25, r1
				} else if (o2_msg_waiting) {
					SEND_ACT(o2_msg_str);
					o2_msg_waiting = 0;
					return true;
				} else if (blip_msg_waiting) {
					SEND_ACT(blip_str);
     cf8:	b9 f7       	brne	.-18     	; 0xce8 <__stack+0x1e9>
     cfa:	82 e1       	ldi	r24, 0x12	; 18
     cfc:	f5 01       	movw	r30, r10
     cfe:	80 83       	st	Z, r24
     d00:	8f ef       	ldi	r24, 0xFF	; 255
     d02:	90 e0       	ldi	r25, 0x00	; 0
     d04:	d4 01       	movw	r26, r8
     d06:	11 96       	adiw	r26, 0x01	; 1
     d08:	9c 93       	st	X, r25
     d0a:	8e 93       	st	-X, r24
     d0c:	10 92 78 05 	sts	0x0578, r1
     d10:	7f ce       	rjmp	.-770    	; 0xa10 <CALLBACK_HID_Device_CreateHIDReport+0x84>
     d12:	80 91 68 05 	lds	r24, 0x0568
     d16:	88 23       	and	r24, r24
     d18:	d1 f0       	breq	.+52     	; 0xd4e <__stack+0x24f>
     d1a:	d9 01       	movw	r26, r18
					blip_msg_waiting = 0;
     d1c:	84 e0       	ldi	r24, 0x04	; 4
     d1e:	8d 93       	st	X+, r24
     d20:	80 e0       	ldi	r24, 0x00	; 0
					return true;
				} else if (heat_msg_waiting) {
     d22:	90 e0       	ldi	r25, 0x00	; 0
     d24:	01 96       	adiw	r24, 0x01	; 1
     d26:	fc 01       	movw	r30, r24
     d28:	ed 5d       	subi	r30, 0xDD	; 221
					SEND_ACT(heat_str);
     d2a:	fe 4f       	sbci	r31, 0xFE	; 254
     d2c:	e4 91       	lpm	r30, Z
     d2e:	ed 93       	st	X+, r30
 *  \param[out]    ReportData  Pointer to a buffer where the created report should be stored
 *  \param[out]    ReportSize  Number of bytes written in the report (or zero if no report is to be sent)
 *
 *  \return Boolean \c true to force the sending of the report, \c false to let the library determine if it needs to be sent
 */
bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
     d30:	84 30       	cpi	r24, 0x04	; 4
     d32:	91 05       	cpc	r25, r1
				} else if (blip_msg_waiting) {
					SEND_ACT(blip_str);
					blip_msg_waiting = 0;
					return true;
				} else if (heat_msg_waiting) {
					SEND_ACT(heat_str);
     d34:	b9 f7       	brne	.-18     	; 0xd24 <__stack+0x225>
     d36:	82 e1       	ldi	r24, 0x12	; 18
     d38:	f5 01       	movw	r30, r10
     d3a:	80 83       	st	Z, r24
     d3c:	8f ef       	ldi	r24, 0xFF	; 255
     d3e:	90 e0       	ldi	r25, 0x00	; 0
     d40:	d4 01       	movw	r26, r8
     d42:	11 96       	adiw	r26, 0x01	; 1
     d44:	9c 93       	st	X, r25
     d46:	8e 93       	st	-X, r24
     d48:	10 92 68 05 	sts	0x0568, r1
     d4c:	61 ce       	rjmp	.-830    	; 0xa10 <CALLBACK_HID_Device_CreateHIDReport+0x84>
     d4e:	80 91 70 05 	lds	r24, 0x0570
     d52:	88 23       	and	r24, r24
     d54:	d1 f0       	breq	.+52     	; 0xd8a <__stack+0x28b>
     d56:	d9 01       	movw	r26, r18
					heat_msg_waiting = 0;
     d58:	8e e0       	ldi	r24, 0x0E	; 14
     d5a:	8d 93       	st	X+, r24
     d5c:	80 e0       	ldi	r24, 0x00	; 0
	if (s##_msg_waiting) {\
		SEND_ACT(pstr_##s);\
		s##_msg_waiting = 0;\
		return true;\
	}
				FLOW_ACT_MESSAGE_TABLE(AS_ACT_SENDER);
     d5e:	90 e0       	ldi	r25, 0x00	; 0
     d60:	01 96       	adiw	r24, 0x01	; 1
     d62:	fc 01       	movw	r30, r24
     d64:	ed 5e       	subi	r30, 0xED	; 237
     d66:	fe 4f       	sbci	r31, 0xFE	; 254
     d68:	e4 91       	lpm	r30, Z
     d6a:	ed 93       	st	X+, r30
 *  \param[out]    ReportData  Pointer to a buffer where the created report should be stored
 *  \param[out]    ReportSize  Number of bytes written in the report (or zero if no report is to be sent)
 *
 *  \return Boolean \c true to force the sending of the report, \c false to let the library determine if it needs to be sent
 */
bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
     d6c:	8e 30       	cpi	r24, 0x0E	; 14
     d6e:	91 05       	cpc	r25, r1
	if (s##_msg_waiting) {\
		SEND_ACT(pstr_##s);\
		s##_msg_waiting = 0;\
		return true;\
	}
				FLOW_ACT_MESSAGE_TABLE(AS_ACT_SENDER);
     d70:	b9 f7       	brne	.-18     	; 0xd60 <__stack+0x261>
     d72:	82 e1       	ldi	r24, 0x12	; 18
     d74:	f5 01       	movw	r30, r10
     d76:	80 83       	st	Z, r24
     d78:	8f ef       	ldi	r24, 0xFF	; 255
     d7a:	90 e0       	ldi	r25, 0x00	; 0
     d7c:	d4 01       	movw	r26, r8
     d7e:	11 96       	adiw	r26, 0x01	; 1
     d80:	9c 93       	st	X, r25
     d82:	8e 93       	st	-X, r24
     d84:	10 92 70 05 	sts	0x0570, r1
     d88:	43 ce       	rjmp	.-890    	; 0xa10 <CALLBACK_HID_Device_CreateHIDReport+0x84>
     d8a:	80 91 73 05 	lds	r24, 0x0573
     d8e:	88 23       	and	r24, r24
     d90:	d1 f0       	breq	.+52     	; 0xdc6 <__stack+0x2c7>
     d92:	d9 01       	movw	r26, r18
     d94:	8d e0       	ldi	r24, 0x0D	; 13
     d96:	8d 93       	st	X+, r24
     d98:	80 e0       	ldi	r24, 0x00	; 0
     d9a:	90 e0       	ldi	r25, 0x00	; 0
     d9c:	01 96       	adiw	r24, 0x01	; 1
     d9e:	fc 01       	movw	r30, r24
     da0:	ec 5f       	subi	r30, 0xFC	; 252
     da2:	fe 4f       	sbci	r31, 0xFE	; 254
     da4:	e4 91       	lpm	r30, Z
     da6:	ed 93       	st	X+, r30
 *  \param[out]    ReportData  Pointer to a buffer where the created report should be stored
 *  \param[out]    ReportSize  Number of bytes written in the report (or zero if no report is to be sent)
 *
 *  \return Boolean \c true to force the sending of the report, \c false to let the library determine if it needs to be sent
 */
bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
     da8:	8d 30       	cpi	r24, 0x0D	; 13
     daa:	91 05       	cpc	r25, r1
	if (s##_msg_waiting) {\
		SEND_ACT(pstr_##s);\
		s##_msg_waiting = 0;\
		return true;\
	}
				FLOW_ACT_MESSAGE_TABLE(AS_ACT_SENDER);
     dac:	b9 f7       	brne	.-18     	; 0xd9c <__stack+0x29d>
     dae:	82 e1       	ldi	r24, 0x12	; 18
     db0:	f5 01       	movw	r30, r10
     db2:	80 83       	st	Z, r24
     db4:	8f ef       	ldi	r24, 0xFF	; 255
     db6:	90 e0       	ldi	r25, 0x00	; 0
     db8:	d4 01       	movw	r26, r8
     dba:	11 96       	adiw	r26, 0x01	; 1
     dbc:	9c 93       	st	X, r25
     dbe:	8e 93       	st	-X, r24
     dc0:	10 92 73 05 	sts	0x0573, r1
     dc4:	25 ce       	rjmp	.-950    	; 0xa10 <CALLBACK_HID_Device_CreateHIDReport+0x84>
     dc6:	80 91 81 05 	lds	r24, 0x0581
     dca:	88 23       	and	r24, r24
     dcc:	d1 f0       	breq	.+52     	; 0xe02 <__stack+0x303>
     dce:	d9 01       	movw	r26, r18
     dd0:	8d e0       	ldi	r24, 0x0D	; 13
     dd2:	8d 93       	st	X+, r24
     dd4:	80 e0       	ldi	r24, 0x00	; 0
     dd6:	90 e0       	ldi	r25, 0x00	; 0
     dd8:	01 96       	adiw	r24, 0x01	; 1
     dda:	fc 01       	movw	r30, r24
     ddc:	eb 50       	subi	r30, 0x0B	; 11
     dde:	ff 4f       	sbci	r31, 0xFF	; 255
     de0:	e4 91       	lpm	r30, Z
     de2:	ed 93       	st	X+, r30
 *  \param[out]    ReportData  Pointer to a buffer where the created report should be stored
 *  \param[out]    ReportSize  Number of bytes written in the report (or zero if no report is to be sent)
 *
 *  \return Boolean \c true to force the sending of the report, \c false to let the library determine if it needs to be sent
 */
bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
     de4:	8d 30       	cpi	r24, 0x0D	; 13
     de6:	91 05       	cpc	r25, r1
	if (s##_msg_waiting) {\
		SEND_ACT(pstr_##s);\
		s##_msg_waiting = 0;\
		return true;\
	}
				FLOW_ACT_MESSAGE_TABLE(AS_ACT_SENDER);
     de8:	b9 f7       	brne	.-18     	; 0xdd8 <__stack+0x2d9>
     dea:	82 e1       	ldi	r24, 0x12	; 18
     dec:	f5 01       	movw	r30, r10
     dee:	80 83       	st	Z, r24
     df0:	8f ef       	ldi	r24, 0xFF	; 255
     df2:	90 e0       	ldi	r25, 0x00	; 0
     df4:	d4 01       	movw	r26, r8
     df6:	11 96       	adiw	r26, 0x01	; 1
     df8:	9c 93       	st	X, r25
     dfa:	8e 93       	st	-X, r24
     dfc:	10 92 81 05 	sts	0x0581, r1
     e00:	07 ce       	rjmp	.-1010   	; 0xa10 <CALLBACK_HID_Device_CreateHIDReport+0x84>
     e02:	80 91 64 05 	lds	r24, 0x0564
     e06:	88 23       	and	r24, r24
     e08:	d1 f0       	breq	.+52     	; 0xe3e <__stack+0x33f>
     e0a:	d9 01       	movw	r26, r18
     e0c:	8d e0       	ldi	r24, 0x0D	; 13
     e0e:	8d 93       	st	X+, r24
     e10:	80 e0       	ldi	r24, 0x00	; 0
     e12:	90 e0       	ldi	r25, 0x00	; 0
     e14:	01 96       	adiw	r24, 0x01	; 1
     e16:	fc 01       	movw	r30, r24
     e18:	ea 51       	subi	r30, 0x1A	; 26
     e1a:	ff 4f       	sbci	r31, 0xFF	; 255
     e1c:	e4 91       	lpm	r30, Z
     e1e:	ed 93       	st	X+, r30
 *  \param[out]    ReportData  Pointer to a buffer where the created report should be stored
 *  \param[out]    ReportSize  Number of bytes written in the report (or zero if no report is to be sent)
 *
 *  \return Boolean \c true to force the sending of the report, \c false to let the library determine if it needs to be sent
 */
bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
     e20:	8d 30       	cpi	r24, 0x0D	; 13
     e22:	91 05       	cpc	r25, r1
	if (s##_msg_waiting) {\
		SEND_ACT(pstr_##s);\
		s##_msg_waiting = 0;\
		return true;\
	}
				FLOW_ACT_MESSAGE_TABLE(AS_ACT_SENDER);
     e24:	b9 f7       	brne	.-18     	; 0xe14 <__stack+0x315>
     e26:	82 e1       	ldi	r24, 0x12	; 18
     e28:	f5 01       	movw	r30, r10
     e2a:	80 83       	st	Z, r24
     e2c:	8f ef       	ldi	r24, 0xFF	; 255
     e2e:	90 e0       	ldi	r25, 0x00	; 0
     e30:	d4 01       	movw	r26, r8
     e32:	11 96       	adiw	r26, 0x01	; 1
     e34:	9c 93       	st	X, r25
     e36:	8e 93       	st	-X, r24
     e38:	10 92 64 05 	sts	0x0564, r1
     e3c:	e9 cd       	rjmp	.-1070   	; 0xa10 <CALLBACK_HID_Device_CreateHIDReport+0x84>
     e3e:	80 91 83 05 	lds	r24, 0x0583
     e42:	88 23       	and	r24, r24
     e44:	d1 f0       	breq	.+52     	; 0xe7a <__stack+0x37b>
     e46:	d9 01       	movw	r26, r18
     e48:	80 e1       	ldi	r24, 0x10	; 16
     e4a:	8d 93       	st	X+, r24
     e4c:	80 e0       	ldi	r24, 0x00	; 0
     e4e:	90 e0       	ldi	r25, 0x00	; 0
     e50:	01 96       	adiw	r24, 0x01	; 1
     e52:	fc 01       	movw	r30, r24
     e54:	ec 52       	subi	r30, 0x2C	; 44
     e56:	ff 4f       	sbci	r31, 0xFF	; 255
     e58:	e4 91       	lpm	r30, Z
     e5a:	ed 93       	st	X+, r30
 *  \param[out]    ReportData  Pointer to a buffer where the created report should be stored
 *  \param[out]    ReportSize  Number of bytes written in the report (or zero if no report is to be sent)
 *
 *  \return Boolean \c true to force the sending of the report, \c false to let the library determine if it needs to be sent
 */
bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
     e5c:	80 31       	cpi	r24, 0x10	; 16
     e5e:	91 05       	cpc	r25, r1
	if (s##_msg_waiting) {\
		SEND_ACT(pstr_##s);\
		s##_msg_waiting = 0;\
		return true;\
	}
				FLOW_ACT_MESSAGE_TABLE(AS_ACT_SENDER);
     e60:	b9 f7       	brne	.-18     	; 0xe50 <__stack+0x351>
     e62:	82 e1       	ldi	r24, 0x12	; 18
     e64:	f5 01       	movw	r30, r10
     e66:	80 83       	st	Z, r24
     e68:	8f ef       	ldi	r24, 0xFF	; 255
     e6a:	90 e0       	ldi	r25, 0x00	; 0
     e6c:	d4 01       	movw	r26, r8
     e6e:	11 96       	adiw	r26, 0x01	; 1
     e70:	9c 93       	st	X, r25
     e72:	8e 93       	st	-X, r24
     e74:	10 92 83 05 	sts	0x0583, r1
     e78:	cb cd       	rjmp	.-1130   	; 0xa10 <CALLBACK_HID_Device_CreateHIDReport+0x84>
     e7a:	80 91 7b 05 	lds	r24, 0x057B
     e7e:	88 23       	and	r24, r24
     e80:	d1 f0       	breq	.+52     	; 0xeb6 <__stack+0x3b7>
     e82:	d9 01       	movw	r26, r18
     e84:	8d e0       	ldi	r24, 0x0D	; 13
     e86:	8d 93       	st	X+, r24
     e88:	80 e0       	ldi	r24, 0x00	; 0
     e8a:	90 e0       	ldi	r25, 0x00	; 0
     e8c:	01 96       	adiw	r24, 0x01	; 1
     e8e:	fc 01       	movw	r30, r24
     e90:	eb 53       	subi	r30, 0x3B	; 59
     e92:	ff 4f       	sbci	r31, 0xFF	; 255
     e94:	e4 91       	lpm	r30, Z
     e96:	ed 93       	st	X+, r30
 *  \param[out]    ReportData  Pointer to a buffer where the created report should be stored
 *  \param[out]    ReportSize  Number of bytes written in the report (or zero if no report is to be sent)
 *
 *  \return Boolean \c true to force the sending of the report, \c false to let the library determine if it needs to be sent
 */
bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
     e98:	8d 30       	cpi	r24, 0x0D	; 13
     e9a:	91 05       	cpc	r25, r1
	if (s##_msg_waiting) {\
		SEND_ACT(pstr_##s);\
		s##_msg_waiting = 0;\
		return true;\
	}
				FLOW_ACT_MESSAGE_TABLE(AS_ACT_SENDER);
     e9c:	b9 f7       	brne	.-18     	; 0xe8c <__stack+0x38d>
     e9e:	82 e1       	ldi	r24, 0x12	; 18
     ea0:	f5 01       	movw	r30, r10
     ea2:	80 83       	st	Z, r24
     ea4:	8f ef       	ldi	r24, 0xFF	; 255
     ea6:	90 e0       	ldi	r25, 0x00	; 0
     ea8:	d4 01       	movw	r26, r8
     eaa:	11 96       	adiw	r26, 0x01	; 1
     eac:	9c 93       	st	X, r25
     eae:	8e 93       	st	-X, r24
     eb0:	10 92 7b 05 	sts	0x057B, r1
     eb4:	ad cd       	rjmp	.-1190   	; 0xa10 <CALLBACK_HID_Device_CreateHIDReport+0x84>
     eb6:	80 91 89 05 	lds	r24, 0x0589
     eba:	88 23       	and	r24, r24
     ebc:	d1 f0       	breq	.+52     	; 0xef2 <__stack+0x3f3>
     ebe:	d9 01       	movw	r26, r18
     ec0:	8d e0       	ldi	r24, 0x0D	; 13
     ec2:	8d 93       	st	X+, r24
     ec4:	80 e0       	ldi	r24, 0x00	; 0
     ec6:	90 e0       	ldi	r25, 0x00	; 0
     ec8:	01 96       	adiw	r24, 0x01	; 1
     eca:	fc 01       	movw	r30, r24
     ecc:	ea 54       	subi	r30, 0x4A	; 74
     ece:	ff 4f       	sbci	r31, 0xFF	; 255
     ed0:	e4 91       	lpm	r30, Z
     ed2:	ed 93       	st	X+, r30
 *  \param[out]    ReportData  Pointer to a buffer where the created report should be stored
 *  \param[out]    ReportSize  Number of bytes written in the report (or zero if no report is to be sent)
 *
 *  \return Boolean \c true to force the sending of the report, \c false to let the library determine if it needs to be sent
 */
bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
     ed4:	8d 30       	cpi	r24, 0x0D	; 13
     ed6:	91 05       	cpc	r25, r1
	if (s##_msg_waiting) {\
		SEND_ACT(pstr_##s);\
		s##_msg_waiting = 0;\
		return true;\
	}
				FLOW_ACT_MESSAGE_TABLE(AS_ACT_SENDER);
     ed8:	b9 f7       	brne	.-18     	; 0xec8 <__stack+0x3c9>
     eda:	82 e1       	ldi	r24, 0x12	; 18
     edc:	f5 01       	movw	r30, r10
     ede:	80 83       	st	Z, r24
     ee0:	8f ef       	ldi	r24, 0xFF	; 255
     ee2:	90 e0       	ldi	r25, 0x00	; 0
     ee4:	d4 01       	movw	r26, r8
     ee6:	11 96       	adiw	r26, 0x01	; 1
     ee8:	9c 93       	st	X, r25
     eea:	8e 93       	st	-X, r24
     eec:	10 92 89 05 	sts	0x0589, r1
     ef0:	8f cd       	rjmp	.-1250   	; 0xa10 <CALLBACK_HID_Device_CreateHIDReport+0x84>
     ef2:	80 91 7a 05 	lds	r24, 0x057A
     ef6:	88 23       	and	r24, r24
     ef8:	d1 f0       	breq	.+52     	; 0xf2e <__stack+0x42f>
     efa:	d9 01       	movw	r26, r18
     efc:	88 e0       	ldi	r24, 0x08	; 8
     efe:	8d 93       	st	X+, r24
     f00:	80 e0       	ldi	r24, 0x00	; 0
     f02:	90 e0       	ldi	r25, 0x00	; 0
     f04:	01 96       	adiw	r24, 0x01	; 1
     f06:	fc 01       	movw	r30, r24
     f08:	e4 55       	subi	r30, 0x54	; 84
     f0a:	ff 4f       	sbci	r31, 0xFF	; 255
     f0c:	e4 91       	lpm	r30, Z
     f0e:	ed 93       	st	X+, r30
 *  \param[out]    ReportData  Pointer to a buffer where the created report should be stored
 *  \param[out]    ReportSize  Number of bytes written in the report (or zero if no report is to be sent)
 *
 *  \return Boolean \c true to force the sending of the report, \c false to let the library determine if it needs to be sent
 */
bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
     f10:	88 30       	cpi	r24, 0x08	; 8
     f12:	91 05       	cpc	r25, r1
	if (s##_msg_waiting) {\
		SEND_ACT(pstr_##s);\
		s##_msg_waiting = 0;\
		return true;\
	}
				FLOW_ACT_MESSAGE_TABLE(AS_ACT_SENDER);
     f14:	b9 f7       	brne	.-18     	; 0xf04 <__stack+0x405>
     f16:	82 e1       	ldi	r24, 0x12	; 18
     f18:	f5 01       	movw	r30, r10
     f1a:	80 83       	st	Z, r24
     f1c:	8f ef       	ldi	r24, 0xFF	; 255
     f1e:	90 e0       	ldi	r25, 0x00	; 0
     f20:	d4 01       	movw	r26, r8
     f22:	11 96       	adiw	r26, 0x01	; 1
     f24:	9c 93       	st	X, r25
     f26:	8e 93       	st	-X, r24
     f28:	10 92 7a 05 	sts	0x057A, r1
     f2c:	71 cd       	rjmp	.-1310   	; 0xa10 <CALLBACK_HID_Device_CreateHIDReport+0x84>
     f2e:	80 91 67 05 	lds	r24, 0x0567
     f32:	81 30       	cpi	r24, 0x01	; 1
     f34:	d9 f4       	brne	.+54     	; 0xf6c <__stack+0x46d>
     f36:	d9 01       	movw	r26, r18
     f38:	8e e0       	ldi	r24, 0x0E	; 14
     f3a:	8d 93       	st	X+, r24
     f3c:	80 e0       	ldi	r24, 0x00	; 0
#define ESCHAR_RESPONSE_MACRO(x) if (eschar_msg_state_##x == ESCHAR_MSG_WAITING) {\
					SEND_ACT(eschar_msg_##x);\
					eschar_msg_state_##x = ESCHAR_MSG_SENT;\
					return true;\
				}
				ESCHAR_RESPONSE_MACRO(1)
     f3e:	90 e0       	ldi	r25, 0x00	; 0
     f40:	01 96       	adiw	r24, 0x01	; 1
     f42:	fc 01       	movw	r30, r24
     f44:	ea 57       	subi	r30, 0x7A	; 122
     f46:	fe 4f       	sbci	r31, 0xFE	; 254
     f48:	e4 91       	lpm	r30, Z
     f4a:	ed 93       	st	X+, r30
 *  \param[out]    ReportData  Pointer to a buffer where the created report should be stored
 *  \param[out]    ReportSize  Number of bytes written in the report (or zero if no report is to be sent)
 *
 *  \return Boolean \c true to force the sending of the report, \c false to let the library determine if it needs to be sent
 */
bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
     f4c:	8e 30       	cpi	r24, 0x0E	; 14
     f4e:	91 05       	cpc	r25, r1
#define ESCHAR_RESPONSE_MACRO(x) if (eschar_msg_state_##x == ESCHAR_MSG_WAITING) {\
					SEND_ACT(eschar_msg_##x);\
					eschar_msg_state_##x = ESCHAR_MSG_SENT;\
					return true;\
				}
				ESCHAR_RESPONSE_MACRO(1)
     f50:	b9 f7       	brne	.-18     	; 0xf40 <__stack+0x441>
     f52:	82 e1       	ldi	r24, 0x12	; 18
     f54:	f5 01       	movw	r30, r10
     f56:	80 83       	st	Z, r24
     f58:	8f ef       	ldi	r24, 0xFF	; 255
     f5a:	90 e0       	ldi	r25, 0x00	; 0
     f5c:	d4 01       	movw	r26, r8
     f5e:	11 96       	adiw	r26, 0x01	; 1
     f60:	9c 93       	st	X, r25
     f62:	8e 93       	st	-X, r24
     f64:	82 e0       	ldi	r24, 0x02	; 2
     f66:	80 93 67 05 	sts	0x0567, r24
     f6a:	52 cd       	rjmp	.-1372   	; 0xa10 <CALLBACK_HID_Device_CreateHIDReport+0x84>
     f6c:	80 91 7e 05 	lds	r24, 0x057E
     f70:	81 30       	cpi	r24, 0x01	; 1
     f72:	d9 f4       	brne	.+54     	; 0xfaa <__stack+0x4ab>
     f74:	d9 01       	movw	r26, r18
     f76:	8e e0       	ldi	r24, 0x0E	; 14
     f78:	8d 93       	st	X+, r24
     f7a:	80 e0       	ldi	r24, 0x00	; 0
				ESCHAR_RESPONSE_MACRO(2)
     f7c:	90 e0       	ldi	r25, 0x00	; 0
     f7e:	01 96       	adiw	r24, 0x01	; 1
     f80:	fc 01       	movw	r30, r24
     f82:	ea 58       	subi	r30, 0x8A	; 138
     f84:	fe 4f       	sbci	r31, 0xFE	; 254
     f86:	e4 91       	lpm	r30, Z
     f88:	ed 93       	st	X+, r30
 *  \param[out]    ReportData  Pointer to a buffer where the created report should be stored
 *  \param[out]    ReportSize  Number of bytes written in the report (or zero if no report is to be sent)
 *
 *  \return Boolean \c true to force the sending of the report, \c false to let the library determine if it needs to be sent
 */
bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
     f8a:	8e 30       	cpi	r24, 0x0E	; 14
     f8c:	91 05       	cpc	r25, r1
					SEND_ACT(eschar_msg_##x);\
					eschar_msg_state_##x = ESCHAR_MSG_SENT;\
					return true;\
				}
				ESCHAR_RESPONSE_MACRO(1)
				ESCHAR_RESPONSE_MACRO(2)
     f8e:	b9 f7       	brne	.-18     	; 0xf7e <__stack+0x47f>
     f90:	82 e1       	ldi	r24, 0x12	; 18
     f92:	f5 01       	movw	r30, r10
     f94:	80 83       	st	Z, r24
     f96:	8f ef       	ldi	r24, 0xFF	; 255
     f98:	90 e0       	ldi	r25, 0x00	; 0
     f9a:	d4 01       	movw	r26, r8
     f9c:	11 96       	adiw	r26, 0x01	; 1
     f9e:	9c 93       	st	X, r25
     fa0:	8e 93       	st	-X, r24
     fa2:	82 e0       	ldi	r24, 0x02	; 2
     fa4:	80 93 7e 05 	sts	0x057E, r24
     fa8:	33 cd       	rjmp	.-1434   	; 0xa10 <CALLBACK_HID_Device_CreateHIDReport+0x84>
     faa:	80 91 7c 05 	lds	r24, 0x057C
     fae:	81 30       	cpi	r24, 0x01	; 1
     fb0:	d9 f4       	brne	.+54     	; 0xfe8 <__stack+0x4e9>
     fb2:	d9 01       	movw	r26, r18
     fb4:	8e e0       	ldi	r24, 0x0E	; 14
     fb6:	8d 93       	st	X+, r24
     fb8:	80 e0       	ldi	r24, 0x00	; 0
				ESCHAR_RESPONSE_MACRO(3)
     fba:	90 e0       	ldi	r25, 0x00	; 0
     fbc:	01 96       	adiw	r24, 0x01	; 1
     fbe:	fc 01       	movw	r30, r24
     fc0:	ea 59       	subi	r30, 0x9A	; 154
     fc2:	fe 4f       	sbci	r31, 0xFE	; 254
     fc4:	e4 91       	lpm	r30, Z
     fc6:	ed 93       	st	X+, r30
 *  \param[out]    ReportData  Pointer to a buffer where the created report should be stored
 *  \param[out]    ReportSize  Number of bytes written in the report (or zero if no report is to be sent)
 *
 *  \return Boolean \c true to force the sending of the report, \c false to let the library determine if it needs to be sent
 */
bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
     fc8:	8e 30       	cpi	r24, 0x0E	; 14
     fca:	91 05       	cpc	r25, r1
					eschar_msg_state_##x = ESCHAR_MSG_SENT;\
					return true;\
				}
				ESCHAR_RESPONSE_MACRO(1)
				ESCHAR_RESPONSE_MACRO(2)
				ESCHAR_RESPONSE_MACRO(3)
     fcc:	b9 f7       	brne	.-18     	; 0xfbc <__stack+0x4bd>
     fce:	82 e1       	ldi	r24, 0x12	; 18
     fd0:	f5 01       	movw	r30, r10
     fd2:	80 83       	st	Z, r24
     fd4:	8f ef       	ldi	r24, 0xFF	; 255
     fd6:	90 e0       	ldi	r25, 0x00	; 0
     fd8:	d4 01       	movw	r26, r8
     fda:	11 96       	adiw	r26, 0x01	; 1
     fdc:	9c 93       	st	X, r25
     fde:	8e 93       	st	-X, r24
     fe0:	82 e0       	ldi	r24, 0x02	; 2
     fe2:	80 93 7c 05 	sts	0x057C, r24
     fe6:	14 cd       	rjmp	.-1496   	; 0xa10 <CALLBACK_HID_Device_CreateHIDReport+0x84>
     fe8:	80 91 52 04 	lds	r24, 0x0452
     fec:	81 30       	cpi	r24, 0x01	; 1
     fee:	d9 f4       	brne	.+54     	; 0x1026 <__stack+0x527>
     ff0:	d9 01       	movw	r26, r18
     ff2:	8e e0       	ldi	r24, 0x0E	; 14
     ff4:	8d 93       	st	X+, r24
     ff6:	80 e0       	ldi	r24, 0x00	; 0
				ESCHAR_RESPONSE_MACRO(4)
     ff8:	90 e0       	ldi	r25, 0x00	; 0
     ffa:	01 96       	adiw	r24, 0x01	; 1
     ffc:	fc 01       	movw	r30, r24
     ffe:	ea 5a       	subi	r30, 0xAA	; 170
    1000:	fe 4f       	sbci	r31, 0xFE	; 254
    1002:	e4 91       	lpm	r30, Z
    1004:	ed 93       	st	X+, r30
 *  \param[out]    ReportData  Pointer to a buffer where the created report should be stored
 *  \param[out]    ReportSize  Number of bytes written in the report (or zero if no report is to be sent)
 *
 *  \return Boolean \c true to force the sending of the report, \c false to let the library determine if it needs to be sent
 */
bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
    1006:	8e 30       	cpi	r24, 0x0E	; 14
    1008:	91 05       	cpc	r25, r1
					return true;\
				}
				ESCHAR_RESPONSE_MACRO(1)
				ESCHAR_RESPONSE_MACRO(2)
				ESCHAR_RESPONSE_MACRO(3)
				ESCHAR_RESPONSE_MACRO(4)
    100a:	b9 f7       	brne	.-18     	; 0xffa <__stack+0x4fb>
    100c:	82 e1       	ldi	r24, 0x12	; 18
    100e:	f5 01       	movw	r30, r10
    1010:	80 83       	st	Z, r24
    1012:	8f ef       	ldi	r24, 0xFF	; 255
    1014:	90 e0       	ldi	r25, 0x00	; 0
    1016:	d4 01       	movw	r26, r8
    1018:	11 96       	adiw	r26, 0x01	; 1
    101a:	9c 93       	st	X, r25
    101c:	8e 93       	st	-X, r24
    101e:	82 e0       	ldi	r24, 0x02	; 2
    1020:	80 93 52 04 	sts	0x0452, r24
    1024:	f5 cc       	rjmp	.-1558   	; 0xa10 <CALLBACK_HID_Device_CreateHIDReport+0x84>
    1026:	80 91 79 05 	lds	r24, 0x0579
    102a:	81 30       	cpi	r24, 0x01	; 1
    102c:	d9 f4       	brne	.+54     	; 0x1064 <__stack+0x565>
    102e:	d9 01       	movw	r26, r18
    1030:	8e e0       	ldi	r24, 0x0E	; 14
    1032:	8d 93       	st	X+, r24
    1034:	80 e0       	ldi	r24, 0x00	; 0
				ESCHAR_RESPONSE_MACRO(5)
    1036:	90 e0       	ldi	r25, 0x00	; 0
    1038:	01 96       	adiw	r24, 0x01	; 1
    103a:	fc 01       	movw	r30, r24
    103c:	ea 5b       	subi	r30, 0xBA	; 186
    103e:	fe 4f       	sbci	r31, 0xFE	; 254
    1040:	e4 91       	lpm	r30, Z
    1042:	ed 93       	st	X+, r30
 *  \param[out]    ReportData  Pointer to a buffer where the created report should be stored
 *  \param[out]    ReportSize  Number of bytes written in the report (or zero if no report is to be sent)
 *
 *  \return Boolean \c true to force the sending of the report, \c false to let the library determine if it needs to be sent
 */
bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
    1044:	8e 30       	cpi	r24, 0x0E	; 14
    1046:	91 05       	cpc	r25, r1
				}
				ESCHAR_RESPONSE_MACRO(1)
				ESCHAR_RESPONSE_MACRO(2)
				ESCHAR_RESPONSE_MACRO(3)
				ESCHAR_RESPONSE_MACRO(4)
				ESCHAR_RESPONSE_MACRO(5)
    1048:	b9 f7       	brne	.-18     	; 0x1038 <__stack+0x539>
    104a:	82 e1       	ldi	r24, 0x12	; 18
    104c:	f5 01       	movw	r30, r10
    104e:	80 83       	st	Z, r24
    1050:	8f ef       	ldi	r24, 0xFF	; 255
    1052:	90 e0       	ldi	r25, 0x00	; 0
    1054:	d4 01       	movw	r26, r8
    1056:	11 96       	adiw	r26, 0x01	; 1
    1058:	9c 93       	st	X, r25
    105a:	8e 93       	st	-X, r24
    105c:	82 e0       	ldi	r24, 0x02	; 2
    105e:	80 93 79 05 	sts	0x0579, r24
    1062:	d6 cc       	rjmp	.-1620   	; 0xa10 <CALLBACK_HID_Device_CreateHIDReport+0x84>
    1064:	80 91 14 01 	lds	r24, 0x0114
    1068:	90 91 15 01 	lds	r25, 0x0115
    106c:	00 97       	sbiw	r24, 0x00	; 0
    106e:	81 f0       	breq	.+32     	; 0x1090 <__stack+0x591>
    1070:	8e e0       	ldi	r24, 0x0E	; 14
    1072:	91 e0       	ldi	r25, 0x01	; 1
				
				//send the sensor spike event
				if (event_buffer.occupancy) {
    1074:	19 d1       	rcall	.+562    	; 0x12a8 <deq_event>
    1076:	b7 01       	movw	r22, r14
    1078:	45 d1       	rcall	.+650    	; 0x1304 <event_to_wire>
    107a:	8d e0       	ldi	r24, 0x0D	; 13
    107c:	90 e0       	ldi	r25, 0x00	; 0
    107e:	f4 01       	movw	r30, r8
					if (RV_IS_IV_ARM) {
						deq_event(&event_buffer); //intentionally discard
						SEND_ACT(iv_arm_msg);
						return true;
					} else { // some other thing that uses the rv code FIXME list them
						nextevt = deq_event(&event_buffer);
    1080:	91 83       	std	Z+1, r25	; 0x01
    1082:	80 83       	st	Z, r24
    1084:	87 e0       	ldi	r24, 0x07	; 7
    1086:	d5 01       	movw	r26, r10
						event_to_wire(nextevt, Data);
    1088:	8c 93       	st	X, r24
    108a:	81 e8       	ldi	r24, 0x81	; 129
    108c:	8d da       	rcall	.-2790   	; 0x5a8 <LEDs_SetAllLEDs>
						*ReportSize = GET_SENSOR_EVENT_REPORT_SIZE;
    108e:	c0 cc       	rjmp	.-1664   	; 0xa10 <CALLBACK_HID_Device_CreateHIDReport+0x84>
    1090:	80 e0       	ldi	r24, 0x00	; 0
    1092:	2b 96       	adiw	r28, 0x0b	; 11
    1094:	0f b6       	in	r0, 0x3f	; 63
    1096:	f8 94       	cli
						*ReportID = GET_SENSOR_EVENT_REPORT_ID;
    1098:	de bf       	out	0x3e, r29	; 62
    109a:	0f be       	out	0x3f, r0	; 63
    109c:	cd bf       	out	0x3d, r28	; 61
						LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
    109e:	df 91       	pop	r29
    10a0:	cf 91       	pop	r28
    10a2:	1f 91       	pop	r17
    10a4:	0f 91       	pop	r16
					return true;
				}
				*/
			}
	}
	return false;
    10a6:	ff 90       	pop	r15
}
    10a8:	ef 90       	pop	r14
    10aa:	df 90       	pop	r13
    10ac:	cf 90       	pop	r12
    10ae:	bf 90       	pop	r11
    10b0:	af 90       	pop	r10
    10b2:	9f 90       	pop	r9
    10b4:	8f 90       	pop	r8
    10b6:	08 95       	ret

000010b8 <CALLBACK_HID_Device_ProcessHIDReport>:
    10b8:	0f 93       	push	r16
    10ba:	1f 93       	push	r17
    10bc:	cf 93       	push	r28
    10be:	df 93       	push	r29
    10c0:	e9 01       	movw	r28, r18
    10c2:	41 30       	cpi	r20, 0x01	; 1
    10c4:	b1 f1       	breq	.+108    	; 0x1132 <CALLBACK_HID_Device_ProcessHIDReport+0x7a>
    10c6:	42 30       	cpi	r20, 0x02	; 2
    10c8:	09 f0       	breq	.+2      	; 0x10cc <CALLBACK_HID_Device_ProcessHIDReport+0x14>
    10ca:	ac c0       	rjmp	.+344    	; 0x1224 <CALLBACK_HID_Device_ProcessHIDReport+0x16c>
    10cc:	62 30       	cpi	r22, 0x02	; 2
	UNUSED(ReportSize);
	switch (ReportType) {
		case HID_REPORT_ITEM_Feature:
		//store string id and offset in alotted bytes
		//use the getDescriptor callback to get the string pointer and length
			if (ReportID == STRING_DESC_HACK_REPORT_ID) {
    10ce:	51 f4       	brne	.+20     	; 0x10e4 <CALLBACK_HID_Device_ProcessHIDReport+0x2c>
				stm_state = STRINGSTM_STRING_REQUESTED;
    10d0:	81 e0       	ldi	r24, 0x01	; 1
    10d2:	80 93 41 03 	sts	0x0341, r24
				stm_reqd_stringid = Data[0];
    10d6:	88 81       	ld	r24, Y
    10d8:	80 93 40 03 	sts	0x0340, r24
				stm_reqd_offset = Data[1];
    10dc:	89 81       	ldd	r24, Y+1	; 0x01
    10de:	80 93 3f 03 	sts	0x033F, r24
    10e2:	a0 c0       	rjmp	.+320    	; 0x1224 <CALLBACK_HID_Device_ProcessHIDReport+0x16c>
			} else if (ReportID == TIMESTAMP_OFFSET_FR_ID) {
    10e4:	64 30       	cpi	r22, 0x04	; 4
    10e6:	21 f4       	brne	.+8      	; 0x10f0 <CALLBACK_HID_Device_ProcessHIDReport+0x38>
				TIME_t oset;
				oset = time_from_wire(Data);
    10e8:	c9 01       	movw	r24, r18
    10ea:	c4 d2       	rcall	.+1416   	; 0x1674 <time_from_wire>
    10ec:	2a d2       	rcall	.+1108   	; 0x1542 <set_time_oset>
				set_time_oset(oset);
    10ee:	9a c0       	rjmp	.+308    	; 0x1224 <CALLBACK_HID_Device_ProcessHIDReport+0x16c>
    10f0:	66 30       	cpi	r22, 0x06	; 6
    10f2:	91 f4       	brne	.+36     	; 0x1118 <CALLBACK_HID_Device_ProcessHIDReport+0x60>
			} else if (ReportID == SET_SENS_THRESH_REPORT_ID) {
    10f4:	08 e9       	ldi	r16, 0x98	; 152
    10f6:	11 e0       	ldi	r17, 0x01	; 1
    10f8:	ce 01       	movw	r24, r28
    10fa:	46 d1       	rcall	.+652    	; 0x1388 <float_from_wire>
				for (int i=0; i < 4; i++) {
					sensor_evt_thresh[i] = float_from_wire(Data + 4*i);
    10fc:	dc 01       	movw	r26, r24
    10fe:	cb 01       	movw	r24, r22
    1100:	f8 01       	movw	r30, r16
    1102:	81 93       	st	Z+, r24
    1104:	91 93       	st	Z+, r25
    1106:	a1 93       	st	Z+, r26
    1108:	b1 93       	st	Z+, r27
    110a:	8f 01       	movw	r16, r30
    110c:	24 96       	adiw	r28, 0x04	; 4
    110e:	f1 e0       	ldi	r31, 0x01	; 1
    1110:	08 3a       	cpi	r16, 0xA8	; 168
    1112:	1f 07       	cpc	r17, r31
			} else if (ReportID == TIMESTAMP_OFFSET_FR_ID) {
				TIME_t oset;
				oset = time_from_wire(Data);
				set_time_oset(oset);
			} else if (ReportID == SET_SENS_THRESH_REPORT_ID) {
				for (int i=0; i < 4; i++) {
    1114:	89 f7       	brne	.-30     	; 0x10f8 <CALLBACK_HID_Device_ProcessHIDReport+0x40>
    1116:	86 c0       	rjmp	.+268    	; 0x1224 <CALLBACK_HID_Device_ProcessHIDReport+0x16c>
    1118:	6f 3f       	cpi	r22, 0xFF	; 255
    111a:	19 f4       	brne	.+6      	; 0x1122 <CALLBACK_HID_Device_ProcessHIDReport+0x6a>
    111c:	81 ea       	ldi	r24, 0xA1	; 161
					sensor_evt_thresh[i] = float_from_wire(Data + 4*i);
				}
			} else if (ReportID == START_BOOTLOADER_REPORT_ID) {
    111e:	44 da       	rcall	.-2936   	; 0x5a8 <LEDs_SetAllLEDs>
    1120:	57 da       	rcall	.-2898   	; 0x5d0 <Jump_To_Bootloader>
				//check that proper code was supplied
				//FIXME lol always succeed
				//start bootloader
				LEDs_SetAllLEDs(LEDS_LED1|LEDS_LED2|LEDS_LED3);
    1122:	6f 30       	cpi	r22, 0x0F	; 15
    1124:	09 f0       	breq	.+2      	; 0x1128 <CALLBACK_HID_Device_ProcessHIDReport+0x70>
    1126:	7e c0       	rjmp	.+252    	; 0x1224 <CALLBACK_HID_Device_ProcessHIDReport+0x16c>
				Jump_To_Bootloader();
    1128:	56 d3       	rcall	.+1708   	; 0x17d6 <heat_enable>
    112a:	81 e0       	ldi	r24, 0x01	; 1
			} else if (ReportID == NO_DATA_REPORT_ID) {
    112c:	80 93 68 05 	sts	0x0568, r24
    1130:	79 c0       	rjmp	.+242    	; 0x1224 <CALLBACK_HID_Device_ProcessHIDReport+0x16c>
				heat_enable();
    1132:	61 31       	cpi	r22, 0x11	; 17
    1134:	61 f0       	breq	.+24     	; 0x114e <CALLBACK_HID_Device_ProcessHIDReport+0x96>
				heat_msg_waiting = 1;
    1136:	62 31       	cpi	r22, 0x12	; 18
    1138:	20 f4       	brcc	.+8      	; 0x1142 <CALLBACK_HID_Device_ProcessHIDReport+0x8a>
    113a:	6d 30       	cpi	r22, 0x0D	; 13
    113c:	09 f0       	breq	.+2      	; 0x1140 <CALLBACK_HID_Device_ProcessHIDReport+0x88>
			}
			break;
		case HID_REPORT_ITEM_Out:
		//TODO have these handlers update the value sent on the corresponding INPUT reports.
		
		switch (ReportID) {
    113e:	72 c0       	rjmp	.+228    	; 0x1224 <CALLBACK_HID_Device_ProcessHIDReport+0x16c>
    1140:	56 c0       	rjmp	.+172    	; 0x11ee <CALLBACK_HID_Device_ProcessHIDReport+0x136>
    1142:	62 31       	cpi	r22, 0x12	; 18
    1144:	71 f1       	breq	.+92     	; 0x11a2 <CALLBACK_HID_Device_ProcessHIDReport+0xea>
    1146:	63 31       	cpi	r22, 0x13	; 19
    1148:	09 f0       	breq	.+2      	; 0x114c <CALLBACK_HID_Device_ProcessHIDReport+0x94>
    114a:	6c c0       	rjmp	.+216    	; 0x1224 <CALLBACK_HID_Device_ProcessHIDReport+0x16c>
    114c:	06 c0       	rjmp	.+12     	; 0x115a <CALLBACK_HID_Device_ProcessHIDReport+0xa2>
    114e:	88 81       	ld	r24, Y
    1150:	88 23       	and	r24, r24
    1152:	09 f0       	breq	.+2      	; 0x1156 <CALLBACK_HID_Device_ProcessHIDReport+0x9e>
    1154:	67 c0       	rjmp	.+206    	; 0x1224 <CALLBACK_HID_Device_ProcessHIDReport+0x16c>
    1156:	b5 d2       	rcall	.+1386   	; 0x16c2 <rfid_sendcommand_readtags>
    1158:	65 c0       	rjmp	.+202    	; 0x1224 <CALLBACK_HID_Device_ProcessHIDReport+0x16c>
			
			case RFID_TAG_SCAN_COMMAND_REPORT_ID:
			//rfid_parser_clearbuffers();
			if (Data[0] == 0) {
    115a:	89 81       	ldd	r24, Y+1	; 0x01
    115c:	86 35       	cpi	r24, 0x56	; 86
    115e:	61 f4       	brne	.+24     	; 0x1178 <CALLBACK_HID_Device_ProcessHIDReport+0xc0>
    1160:	8a 81       	ldd	r24, Y+2	; 0x02
				rfid_sendcommand_readtags();
    1162:	85 34       	cpi	r24, 0x45	; 69
    1164:	d9 f4       	brne	.+54     	; 0x119c <CALLBACK_HID_Device_ProcessHIDReport+0xe4>
    1166:	8b 81       	ldd	r24, Y+3	; 0x03
			for (int i = 0; i <= len; i++) {
				prox2act[i] = Data[i];
			}
			prox2act_msg_waiting = 1;
#endif
			if (Data[1] == 'V' && Data[2] == 'E' && Data[3] == 'N' && Data[4] == 'T') { // VENT
    1168:	8e 34       	cpi	r24, 0x4E	; 78
    116a:	c1 f4       	brne	.+48     	; 0x119c <CALLBACK_HID_Device_ProcessHIDReport+0xe4>
    116c:	8c 81       	ldd	r24, Y+4	; 0x04
    116e:	84 35       	cpi	r24, 0x54	; 84
    1170:	a9 f4       	brne	.+42     	; 0x119c <CALLBACK_HID_Device_ProcessHIDReport+0xe4>
    1172:	40 93 66 05 	sts	0x0566, r20
    1176:	12 c0       	rjmp	.+36     	; 0x119c <CALLBACK_HID_Device_ProcessHIDReport+0xe4>
    1178:	82 34       	cpi	r24, 0x42	; 66
    117a:	49 f4       	brne	.+18     	; 0x118e <CALLBACK_HID_Device_ProcessHIDReport+0xd6>
    117c:	8a 81       	ldd	r24, Y+2	; 0x02
    117e:	86 35       	cpi	r24, 0x56	; 86
				//TODO what is the appropriate action here
				vent_sitch = ACT_MSG_ST_RCVD;
    1180:	69 f4       	brne	.+26     	; 0x119c <CALLBACK_HID_Device_ProcessHIDReport+0xe4>
    1182:	8b 81       	ldd	r24, Y+3	; 0x03
    1184:	8d 34       	cpi	r24, 0x4D	; 77
			} else if (Data[1] == 'B' && Data[2] == 'V' && Data[3] == 'M') { // BVM
    1186:	51 f4       	brne	.+20     	; 0x119c <CALLBACK_HID_Device_ProcessHIDReport+0xe4>
    1188:	40 93 52 05 	sts	0x0552, r20
    118c:	07 c0       	rjmp	.+14     	; 0x119c <CALLBACK_HID_Device_ProcessHIDReport+0xe4>
    118e:	8f 34       	cpi	r24, 0x4F	; 79
    1190:	29 f4       	brne	.+10     	; 0x119c <CALLBACK_HID_Device_ProcessHIDReport+0xe4>
    1192:	8a 81       	ldd	r24, Y+2	; 0x02
    1194:	82 33       	cpi	r24, 0x32	; 50
				//TODO what is the appropriate action here
				//do not send any airway messages if the BVM message has not been received
				bvm_sitch = ACT_MSG_ST_RCVD;
    1196:	11 f4       	brne	.+4      	; 0x119c <CALLBACK_HID_Device_ProcessHIDReport+0xe4>
    1198:	40 93 82 05 	sts	0x0582, r20
				//debug_msg_waiting = 1;
			} else if (Data[1] == 'O' && Data[2] == '2') {
    119c:	ce 01       	movw	r24, r28
    119e:	47 d3       	rcall	.+1678   	; 0x182e <flow_sensor_handle_PROX>
    11a0:	41 c0       	rjmp	.+130    	; 0x1224 <CALLBACK_HID_Device_ProcessHIDReport+0x16c>
    11a2:	89 81       	ldd	r24, Y+1	; 0x01
    11a4:	83 35       	cpi	r24, 0x53	; 83
				//airway emits an O2 message on ACT, echoing it
				//makes rfid code simpler
				o2_msg_waiting = 1;
    11a6:	01 f5       	brne	.+64     	; 0x11e8 <CALLBACK_HID_Device_ProcessHIDReport+0x130>
    11a8:	8a 81       	ldd	r24, Y+2	; 0x02
			}
			flow_sensor_handle_PROX((char*)Data);
    11aa:	84 35       	cpi	r24, 0x54	; 84
    11ac:	e9 f4       	brne	.+58     	; 0x11e8 <CALLBACK_HID_Device_ProcessHIDReport+0x130>
    11ae:	8b 81       	ldd	r24, Y+3	; 0x03
			break;
    11b0:	8f 34       	cpi	r24, 0x4F	; 79
				Escharotomy arm
				IV arm
				Rugged arm
				or rather, all the arms that have a pulse.
			*/
			if (Data[1]=='S' && Data[2]=='T' && Data[3]=='O' && Data[4]=='P') { // skip length, check first character
    11b2:	d1 f4       	brne	.+52     	; 0x11e8 <CALLBACK_HID_Device_ProcessHIDReport+0x130>
    11b4:	8c 81       	ldd	r24, Y+4	; 0x04
    11b6:	80 35       	cpi	r24, 0x50	; 80
    11b8:	b9 f4       	brne	.+46     	; 0x11e8 <CALLBACK_HID_Device_ProcessHIDReport+0x130>
    11ba:	0f d3       	rcall	.+1566   	; 0x17da <pulse_stop>
    11bc:	10 92 3e 03 	sts	0x033E, r1
    11c0:	10 92 52 05 	sts	0x0552, r1
    11c4:	10 92 66 05 	sts	0x0566, r1
    11c8:	10 92 84 05 	sts	0x0584, r1
				pulse_stop();
    11cc:	10 92 85 05 	sts	0x0585, r1
				lung_st = LUNG_ZERO_STATE;
    11d0:	10 92 86 05 	sts	0x0586, r1
				bvm_sitch = 0;
    11d4:	10 92 87 05 	sts	0x0587, r1
				vent_sitch = 0;
    11d8:	10 92 4e 04 	sts	0x044E, r1
				lung_flow_start_time = 0;
    11dc:	10 92 4f 04 	sts	0x044F, r1
    11e0:	10 92 50 04 	sts	0x0450, r1
    11e4:	10 92 51 04 	sts	0x0451, r1
    11e8:	ce 01       	movw	r24, r28
				lung_flow_stop_time = 0;
    11ea:	8a d3       	rcall	.+1812   	; 0x1900 <flow_sensor_handle_ACT>
    11ec:	1b c0       	rjmp	.+54     	; 0x1224 <CALLBACK_HID_Device_ProcessHIDReport+0x16c>
    11ee:	c9 01       	movw	r24, r18
    11f0:	cb d0       	rcall	.+406    	; 0x1388 <float_from_wire>
    11f2:	20 e0       	ldi	r18, 0x00	; 0
    11f4:	30 e0       	ldi	r19, 0x00	; 0
    11f6:	40 e7       	ldi	r20, 0x70	; 112
    11f8:	52 e4       	ldi	r21, 0x42	; 66
			}
			flow_sensor_handle_ACT((char*) Data);
    11fa:	0e 94 80 13 	call	0x2700	; 0x2700 <__divsf3>
    11fe:	9b 01       	movw	r18, r22
			break;
    1200:	ac 01       	movw	r20, r24
				IV Arm
			*/
			int pulse_delay_ms;
			float hr;
			//read float from message
			hr = float_from_wire(Data); // b/m
    1202:	60 e0       	ldi	r22, 0x00	; 0
    1204:	70 e0       	ldi	r23, 0x00	; 0
    1206:	80 e8       	ldi	r24, 0x80	; 128
			float bps = hr / 60.0; /* b/m * m/s = b/s */
    1208:	9f e3       	ldi	r25, 0x3F	; 63
    120a:	0e 94 80 13 	call	0x2700	; 0x2700 <__divsf3>
    120e:	20 e0       	ldi	r18, 0x00	; 0
    1210:	30 e0       	ldi	r19, 0x00	; 0
    1212:	4a e7       	ldi	r20, 0x7A	; 122
    1214:	54 e4       	ldi	r21, 0x44	; 68
    1216:	0e 94 6a 14 	call	0x28d4	; 0x28d4 <__mulsf3>
			float spb = 1.0/bps;
    121a:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <__fixsfsi>
    121e:	dc 01       	movw	r26, r24
    1220:	cb 01       	movw	r24, r22
    1222:	de d2       	rcall	.+1468   	; 0x17e0 <pulse_set_delay>
			float ms_p_b = 1000*spb;
    1224:	df 91       	pop	r29
    1226:	cf 91       	pop	r28
    1228:	1f 91       	pop	r17
    122a:	0f 91       	pop	r16
    122c:	08 95       	ret

0000122e <CALLBACK_USB_GetDescriptor>:
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;
	UNUSED(wIndex);
	switch (DescriptorType)
    122e:	93 30       	cpi	r25, 0x03	; 3
    1230:	89 f0       	breq	.+34     	; 0x1254 <CALLBACK_USB_GetDescriptor+0x26>
    1232:	94 30       	cpi	r25, 0x04	; 4
    1234:	28 f4       	brcc	.+10     	; 0x1240 <CALLBACK_USB_GetDescriptor+0x12>
    1236:	91 30       	cpi	r25, 0x01	; 1
    1238:	49 f1       	breq	.+82     	; 0x128c <CALLBACK_USB_GetDescriptor+0x5e>
    123a:	92 30       	cpi	r25, 0x02	; 2
    123c:	61 f5       	brne	.+88     	; 0x1296 <CALLBACK_USB_GetDescriptor+0x68>
    123e:	05 c0       	rjmp	.+10     	; 0x124a <CALLBACK_USB_GetDescriptor+0x1c>
    1240:	91 32       	cpi	r25, 0x21	; 33
    1242:	d1 f0       	breq	.+52     	; 0x1278 <CALLBACK_USB_GetDescriptor+0x4a>
    1244:	92 32       	cpi	r25, 0x22	; 34
    1246:	39 f5       	brne	.+78     	; 0x1296 <CALLBACK_USB_GetDescriptor+0x68>
    1248:	1c c0       	rjmp	.+56     	; 0x1282 <CALLBACK_USB_GetDescriptor+0x54>
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
    124a:	82 e2       	ldi	r24, 0x22	; 34
    124c:	90 e0       	ldi	r25, 0x00	; 0
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
    124e:	e5 e4       	ldi	r30, 0x45	; 69
    1250:	f2 e0       	ldi	r31, 0x02	; 2
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
    1252:	25 c0       	rjmp	.+74     	; 0x129e <CALLBACK_USB_GetDescriptor+0x70>
		case DTYPE_String:
			switch (DescriptorNumber)
    1254:	81 30       	cpi	r24, 0x01	; 1
    1256:	41 f0       	breq	.+16     	; 0x1268 <CALLBACK_USB_GetDescriptor+0x3a>
    1258:	81 30       	cpi	r24, 0x01	; 1
    125a:	18 f0       	brcs	.+6      	; 0x1262 <CALLBACK_USB_GetDescriptor+0x34>
    125c:	82 30       	cpi	r24, 0x02	; 2
    125e:	d9 f4       	brne	.+54     	; 0x1296 <CALLBACK_USB_GetDescriptor+0x68>
    1260:	06 c0       	rjmp	.+12     	; 0x126e <CALLBACK_USB_GetDescriptor+0x40>
			{
				case STRING_ID_Language:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
    1262:	e1 e4       	ldi	r30, 0x41	; 65
    1264:	f2 e0       	ldi	r31, 0x02	; 2
    1266:	05 c0       	rjmp	.+10     	; 0x1272 <CALLBACK_USB_GetDescriptor+0x44>
					break;
				case STRING_ID_Manufacturer:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
    1268:	e7 e2       	ldi	r30, 0x27	; 39
    126a:	f2 e0       	ldi	r31, 0x02	; 2
    126c:	02 c0       	rjmp	.+4      	; 0x1272 <CALLBACK_USB_GetDescriptor+0x44>
					break;
				case STRING_ID_Product:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
    126e:	e9 ef       	ldi	r30, 0xF9	; 249
    1270:	f1 e0       	ldi	r31, 0x01	; 1
    1272:	84 91       	lpm	r24, Z
    1274:	90 e0       	ldi	r25, 0x00	; 0
					break;
    1276:	13 c0       	rjmp	.+38     	; 0x129e <CALLBACK_USB_GetDescriptor+0x70>
			}

			break;
		case HID_DTYPE_HID:
			Address = &ConfigurationDescriptor.HID_GenericHID;
			Size    = sizeof(USB_HID_Descriptor_HID_t);
    1278:	89 e0       	ldi	r24, 0x09	; 9
    127a:	90 e0       	ldi	r25, 0x00	; 0
					break;
			}

			break;
		case HID_DTYPE_HID:
			Address = &ConfigurationDescriptor.HID_GenericHID;
    127c:	e7 e5       	ldi	r30, 0x57	; 87
    127e:	f2 e0       	ldi	r31, 0x02	; 2
			Size    = sizeof(USB_HID_Descriptor_HID_t);
			break;
    1280:	0e c0       	rjmp	.+28     	; 0x129e <CALLBACK_USB_GetDescriptor+0x70>
		case HID_DTYPE_Report:
			Address = &GenericReport;
			Size    = sizeof(GenericReport);
    1282:	8a ec       	ldi	r24, 0xCA	; 202
    1284:	91 e0       	ldi	r25, 0x01	; 1
		case HID_DTYPE_HID:
			Address = &ConfigurationDescriptor.HID_GenericHID;
			Size    = sizeof(USB_HID_Descriptor_HID_t);
			break;
		case HID_DTYPE_Report:
			Address = &GenericReport;
    1286:	e9 e7       	ldi	r30, 0x79	; 121
    1288:	f2 e0       	ldi	r31, 0x02	; 2
			Size    = sizeof(GenericReport);
			break;
    128a:	09 c0       	rjmp	.+18     	; 0x129e <CALLBACK_USB_GetDescriptor+0x70>
	UNUSED(wIndex);
	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
    128c:	82 e1       	ldi	r24, 0x12	; 18
    128e:	90 e0       	ldi	r25, 0x00	; 0
	uint16_t    Size    = NO_DESCRIPTOR;
	UNUSED(wIndex);
	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
    1290:	e7 e6       	ldi	r30, 0x67	; 103
    1292:	f2 e0       	ldi	r31, 0x02	; 2
    1294:	04 c0       	rjmp	.+8      	; 0x129e <CALLBACK_USB_GetDescriptor+0x70>
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;
    1296:	80 e0       	ldi	r24, 0x00	; 0
    1298:	90 e0       	ldi	r25, 0x00	; 0
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
    129a:	e0 e0       	ldi	r30, 0x00	; 0
    129c:	f0 e0       	ldi	r31, 0x00	; 0
			Address = &GenericReport;
			Size    = sizeof(GenericReport);
			break;
	}

	*DescriptorAddress = Address;
    129e:	da 01       	movw	r26, r20
    12a0:	11 96       	adiw	r26, 0x01	; 1
    12a2:	fc 93       	st	X, r31
    12a4:	ee 93       	st	-X, r30
	return Size;
}
    12a6:	08 95       	ret

000012a8 <deq_event>:
		ebuf->occupancy = ebuf->buflen;
	}
}

const event_t* deq_event(event_buf_t* ebuf)
{
    12a8:	cf 93       	push	r28
    12aa:	df 93       	push	r29
    12ac:	fc 01       	movw	r30, r24
	if (ebuf->occupancy) {
    12ae:	26 81       	ldd	r18, Z+6	; 0x06
    12b0:	37 81       	ldd	r19, Z+7	; 0x07
    12b2:	21 15       	cp	r18, r1
    12b4:	31 05       	cpc	r19, r1
    12b6:	d9 f0       	breq	.+54     	; 0x12ee <deq_event+0x46>
		int lr = ebuf->last_real;
    12b8:	c4 81       	ldd	r28, Z+4	; 0x04
    12ba:	d5 81       	ldd	r29, Z+5	; 0x05
		event_t* out = &(ebuf->evtbuf[lr]);
		ebuf->last_real = (lr + 1) % (ebuf->buflen);
    12bc:	ce 01       	movw	r24, r28
    12be:	01 96       	adiw	r24, 0x01	; 1
    12c0:	60 81       	ld	r22, Z
    12c2:	71 81       	ldd	r23, Z+1	; 0x01
    12c4:	0e 94 cd 14 	call	0x299a	; 0x299a <__udivmodhi4>
    12c8:	95 83       	std	Z+5, r25	; 0x05
    12ca:	84 83       	std	Z+4, r24	; 0x04
		(ebuf->occupancy)--;
    12cc:	21 50       	subi	r18, 0x01	; 1
    12ce:	30 40       	sbci	r19, 0x00	; 0
    12d0:	37 83       	std	Z+7, r19	; 0x07
    12d2:	26 83       	std	Z+6, r18	; 0x06
		return out;
    12d4:	2d e0       	ldi	r18, 0x0D	; 13
    12d6:	30 e0       	ldi	r19, 0x00	; 0
    12d8:	c2 9f       	mul	r28, r18
    12da:	c0 01       	movw	r24, r0
    12dc:	c3 9f       	mul	r28, r19
    12de:	90 0d       	add	r25, r0
    12e0:	d2 9f       	mul	r29, r18
    12e2:	90 0d       	add	r25, r0
    12e4:	11 24       	eor	r1, r1
    12e6:	08 96       	adiw	r24, 0x08	; 8
    12e8:	8e 0f       	add	r24, r30
    12ea:	9f 1f       	adc	r25, r31
    12ec:	02 c0       	rjmp	.+4      	; 0x12f2 <deq_event+0x4a>
	}
	return NULL;
    12ee:	80 e0       	ldi	r24, 0x00	; 0
    12f0:	90 e0       	ldi	r25, 0x00	; 0
}
    12f2:	df 91       	pop	r29
    12f4:	cf 91       	pop	r28
    12f6:	08 95       	ret

000012f8 <uint32_to_wire>:
union uint32_byteview {
	uint32_t val;
	uint8_t u8s[4];
};
void uint32_to_wire(uint32_t v, uint8_t w[])
{
    12f8:	fa 01       	movw	r30, r20
	union uint32_byteview ubv;
	ubv.val = v;
	for (int i = 0; i < 4; i++) {
		w[i] = ubv.u8s[3-i];
    12fa:	90 83       	st	Z, r25
    12fc:	81 83       	std	Z+1, r24	; 0x01
    12fe:	72 83       	std	Z+2, r23	; 0x02
    1300:	63 83       	std	Z+3, r22	; 0x03
	}
}
    1302:	08 95       	ret

00001304 <event_to_wire>:
		return runvar_curmean(&(o->snd));
	}
}

void event_to_wire(const event_t* e, uint8_t w[])
{
    1304:	ef 92       	push	r14
    1306:	ff 92       	push	r15
    1308:	0f 93       	push	r16
    130a:	1f 93       	push	r17
    130c:	cf 93       	push	r28
    130e:	df 93       	push	r29
    1310:	ec 01       	movw	r28, r24
    1312:	7b 01       	movw	r14, r22
	time_to_wire(e->host_time_start, w);
    1314:	28 81       	ld	r18, Y
    1316:	39 81       	ldd	r19, Y+1	; 0x01
    1318:	4a 81       	ldd	r20, Y+2	; 0x02
    131a:	5b 81       	ldd	r21, Y+3	; 0x03
    131c:	6c 81       	ldd	r22, Y+4	; 0x04
    131e:	7d 81       	ldd	r23, Y+5	; 0x05
    1320:	8e 81       	ldd	r24, Y+6	; 0x06
    1322:	9f 81       	ldd	r25, Y+7	; 0x07
    1324:	87 01       	movw	r16, r14
    1326:	7d d1       	rcall	.+762    	; 0x1622 <time_to_wire>
    1328:	68 85       	ldd	r22, Y+8	; 0x08
	uint32_to_wire(e->evt_dur, w+8);
    132a:	79 85       	ldd	r23, Y+9	; 0x09
    132c:	8a 85       	ldd	r24, Y+10	; 0x0a
    132e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1330:	a7 01       	movw	r20, r14
    1332:	48 5f       	subi	r20, 0xF8	; 248
    1334:	5f 4f       	sbci	r21, 0xFF	; 255
    1336:	e0 df       	rcall	.-64     	; 0x12f8 <uint32_to_wire>
    1338:	8c 85       	ldd	r24, Y+12	; 0x0c
    133a:	f7 01       	movw	r30, r14
	w[12] = e->location;
    133c:	84 87       	std	Z+12, r24	; 0x0c
    133e:	df 91       	pop	r29
    1340:	cf 91       	pop	r28
}
    1342:	1f 91       	pop	r17
    1344:	0f 91       	pop	r16
    1346:	ff 90       	pop	r15
    1348:	ef 90       	pop	r14
    134a:	08 95       	ret

0000134c <float_to_wire>:
    134c:	cf 93       	push	r28
    134e:	df 93       	push	r29
union float_byteview {
	float val;
	uint8_t u8s[4];
};
void float_to_wire(float f, uint8_t w[])
{
    1350:	00 d0       	rcall	.+0      	; 0x1352 <float_to_wire+0x6>
    1352:	00 d0       	rcall	.+0      	; 0x1354 <float_to_wire+0x8>
    1354:	cd b7       	in	r28, 0x3d	; 61
    1356:	de b7       	in	r29, 0x3e	; 62
    1358:	dc 01       	movw	r26, r24
    135a:	cb 01       	movw	r24, r22
	union float_byteview fbv;
	fbv.val = f;
    135c:	89 83       	std	Y+1, r24	; 0x01
    135e:	9a 83       	std	Y+2, r25	; 0x02
    1360:	ab 83       	std	Y+3, r26	; 0x03
    1362:	bc 83       	std	Y+4, r27	; 0x04
    1364:	de 01       	movw	r26, r28
    1366:	11 96       	adiw	r26, 0x01	; 1
    1368:	fa 01       	movw	r30, r20
	for (int i = 0; i < 4; i++) {
    136a:	80 e0       	ldi	r24, 0x00	; 0
    136c:	90 e0       	ldi	r25, 0x00	; 0
		w[i] = fbv.u8s[i];
    136e:	2d 91       	ld	r18, X+
    1370:	21 93       	st	Z+, r18
};
void float_to_wire(float f, uint8_t w[])
{
	union float_byteview fbv;
	fbv.val = f;
	for (int i = 0; i < 4; i++) {
    1372:	01 96       	adiw	r24, 0x01	; 1
    1374:	84 30       	cpi	r24, 0x04	; 4
    1376:	91 05       	cpc	r25, r1
    1378:	d1 f7       	brne	.-12     	; 0x136e <float_to_wire+0x22>
		w[i] = fbv.u8s[i];
	}
}
    137a:	0f 90       	pop	r0
    137c:	0f 90       	pop	r0
    137e:	0f 90       	pop	r0
    1380:	0f 90       	pop	r0
    1382:	df 91       	pop	r29
    1384:	cf 91       	pop	r28
    1386:	08 95       	ret

00001388 <float_from_wire>:
float float_from_wire(const uint8_t w[])
{
    1388:	cf 93       	push	r28
    138a:	df 93       	push	r29
    138c:	00 d0       	rcall	.+0      	; 0x138e <float_from_wire+0x6>
    138e:	00 d0       	rcall	.+0      	; 0x1390 <float_from_wire+0x8>
    1390:	cd b7       	in	r28, 0x3d	; 61
    1392:	de b7       	in	r29, 0x3e	; 62
	union float_byteview fbv;
	for (int i = 0; i < 4; i++) {
    1394:	fc 01       	movw	r30, r24
    1396:	de 01       	movw	r26, r28
    1398:	11 96       	adiw	r26, 0x01	; 1
    139a:	80 e0       	ldi	r24, 0x00	; 0
    139c:	90 e0       	ldi	r25, 0x00	; 0
		fbv.u8s[i] = w[i];
    139e:	21 91       	ld	r18, Z+
    13a0:	2d 93       	st	X+, r18
	}
}
float float_from_wire(const uint8_t w[])
{
	union float_byteview fbv;
	for (int i = 0; i < 4; i++) {
    13a2:	01 96       	adiw	r24, 0x01	; 1
    13a4:	84 30       	cpi	r24, 0x04	; 4
    13a6:	91 05       	cpc	r25, r1
    13a8:	d1 f7       	brne	.-12     	; 0x139e <float_from_wire+0x16>
		fbv.u8s[i] = w[i];
	}
	return fbv.val;
    13aa:	59 81       	ldd	r21, Y+1	; 0x01
    13ac:	4a 81       	ldd	r20, Y+2	; 0x02
    13ae:	3b 81       	ldd	r19, Y+3	; 0x03
    13b0:	2c 81       	ldd	r18, Y+4	; 0x04
    13b2:	85 2f       	mov	r24, r21
    13b4:	94 2f       	mov	r25, r20
    13b6:	a3 2f       	mov	r26, r19
    13b8:	b2 2f       	mov	r27, r18
    13ba:	bc 01       	movw	r22, r24
    13bc:	cd 01       	movw	r24, r26
    13be:	0f 90       	pop	r0
    13c0:	0f 90       	pop	r0
    13c2:	0f 90       	pop	r0
    13c4:	0f 90       	pop	r0
    13c6:	df 91       	pop	r29
    13c8:	cf 91       	pop	r28
    13ca:	08 95       	ret

000013cc <setup_timer>:
		256		61.5
		1024	14.625
	*/
	
	/* set timer 1 to CTC mode */
	TCCR0A |= (1<<WGM01);
    13cc:	84 b5       	in	r24, 0x24	; 36
    13ce:	82 60       	ori	r24, 0x02	; 2
    13d0:	84 bd       	out	0x24, r24	; 36
	/* enable interrupts for */
	TIMSK0 |= (1<<OCIE0A);
    13d2:	ee e6       	ldi	r30, 0x6E	; 110
    13d4:	f0 e0       	ldi	r31, 0x00	; 0
    13d6:	80 81       	ld	r24, Z
    13d8:	82 60       	ori	r24, 0x02	; 2
    13da:	80 83       	st	Z, r24
	
	/* set CTC value to 1ms */
	OCR0A = 249; /* 249;*/
    13dc:	89 ef       	ldi	r24, 0xF9	; 249
    13de:	87 bd       	out	0x27, r24	; 39
	
	/* set timer 1 to a prescaler of 64 */
	TCCR0B |= (1<<CS01)|(1<<CS00);
    13e0:	85 b5       	in	r24, 0x25	; 37
    13e2:	83 60       	ori	r24, 0x03	; 3
    13e4:	85 bd       	out	0x25, r24	; 37
	
	
	//when timer hits 249 OCF1A is set. to clear it set it to 1
	/* 16000000 / 1024 = 250 ticks in a second, set overflow check to 249 */
	
}
    13e6:	08 95       	ret

000013e8 <__vector_21>:

ISR(TIMER0_COMPA_vect)
{
    13e8:	1f 92       	push	r1
    13ea:	0f 92       	push	r0
    13ec:	0f b6       	in	r0, 0x3f	; 63
    13ee:	0f 92       	push	r0
    13f0:	11 24       	eor	r1, r1
    13f2:	8f 93       	push	r24
    13f4:	9f 93       	push	r25
    13f6:	af 93       	push	r26
    13f8:	bf 93       	push	r27
	cur_millis++;
    13fa:	80 91 49 04 	lds	r24, 0x0449
    13fe:	90 91 4a 04 	lds	r25, 0x044A
    1402:	a0 91 4b 04 	lds	r26, 0x044B
    1406:	b0 91 4c 04 	lds	r27, 0x044C
    140a:	01 96       	adiw	r24, 0x01	; 1
    140c:	a1 1d       	adc	r26, r1
    140e:	b1 1d       	adc	r27, r1
    1410:	80 93 49 04 	sts	0x0449, r24
    1414:	90 93 4a 04 	sts	0x044A, r25
    1418:	a0 93 4b 04 	sts	0x044B, r26
    141c:	b0 93 4c 04 	sts	0x044C, r27
}
    1420:	bf 91       	pop	r27
    1422:	af 91       	pop	r26
    1424:	9f 91       	pop	r25
    1426:	8f 91       	pop	r24
    1428:	0f 90       	pop	r0
    142a:	0f be       	out	0x3f, r0	; 63
    142c:	0f 90       	pop	r0
    142e:	1f 90       	pop	r1
    1430:	18 95       	reti

00001432 <millis>:

ms_time_t millis(void)
{
    1432:	0f 93       	push	r16
    1434:	1f 93       	push	r17
	ms_time_t ms = cur_millis;
    1436:	00 91 49 04 	lds	r16, 0x0449
    143a:	10 91 4a 04 	lds	r17, 0x044A
    143e:	20 91 4b 04 	lds	r18, 0x044B
    1442:	30 91 4c 04 	lds	r19, 0x044C
	return ms;
}
    1446:	b8 01       	movw	r22, r16
    1448:	c9 01       	movw	r24, r18
    144a:	1f 91       	pop	r17
    144c:	0f 91       	pop	r16
    144e:	08 95       	ret

00001450 <host_millis>:

TIME_t host_millis(void) {
    1450:	df 92       	push	r13
    1452:	ef 92       	push	r14
    1454:	ff 92       	push	r15
    1456:	0f 93       	push	r16
    1458:	1f 93       	push	r17
    145a:	cf 93       	push	r28
    145c:	df 93       	push	r29
	return time_oset + cur_millis;
    145e:	00 91 49 04 	lds	r16, 0x0449
    1462:	10 91 4a 04 	lds	r17, 0x044A
    1466:	20 91 4b 04 	lds	r18, 0x044B
    146a:	30 91 4c 04 	lds	r19, 0x044C
    146e:	40 e0       	ldi	r20, 0x00	; 0
    1470:	50 e0       	ldi	r21, 0x00	; 0
    1472:	ba 01       	movw	r22, r20
    1474:	f0 90 41 04 	lds	r15, 0x0441
    1478:	b0 91 42 04 	lds	r27, 0x0442
    147c:	a0 91 43 04 	lds	r26, 0x0443
    1480:	d0 90 44 04 	lds	r13, 0x0444
    1484:	80 91 45 04 	lds	r24, 0x0445
    1488:	90 91 46 04 	lds	r25, 0x0446
    148c:	e0 90 47 04 	lds	r14, 0x0447
    1490:	e0 91 48 04 	lds	r30, 0x0448
    1494:	f0 0e       	add	r15, r16
    1496:	d1 e0       	ldi	r29, 0x01	; 1
    1498:	f0 16       	cp	r15, r16
    149a:	08 f0       	brcs	.+2      	; 0x149e <host_millis+0x4e>
    149c:	d0 e0       	ldi	r29, 0x00	; 0
    149e:	b1 0f       	add	r27, r17
    14a0:	c1 e0       	ldi	r28, 0x01	; 1
    14a2:	b1 17       	cp	r27, r17
    14a4:	08 f0       	brcs	.+2      	; 0x14a8 <host_millis+0x58>
    14a6:	c0 e0       	ldi	r28, 0x00	; 0
    14a8:	db 0f       	add	r29, r27
    14aa:	f1 e0       	ldi	r31, 0x01	; 1
    14ac:	db 17       	cp	r29, r27
    14ae:	08 f0       	brcs	.+2      	; 0x14b2 <host_millis+0x62>
    14b0:	f0 e0       	ldi	r31, 0x00	; 0
    14b2:	cf 2b       	or	r28, r31
    14b4:	a2 0f       	add	r26, r18
    14b6:	b1 e0       	ldi	r27, 0x01	; 1
    14b8:	a2 17       	cp	r26, r18
    14ba:	08 f0       	brcs	.+2      	; 0x14be <host_millis+0x6e>
    14bc:	b0 e0       	ldi	r27, 0x00	; 0
    14be:	ca 0f       	add	r28, r26
    14c0:	f1 e0       	ldi	r31, 0x01	; 1
    14c2:	ca 17       	cp	r28, r26
    14c4:	08 f0       	brcs	.+2      	; 0x14c8 <host_millis+0x78>
    14c6:	f0 e0       	ldi	r31, 0x00	; 0
    14c8:	bf 2b       	or	r27, r31
    14ca:	f3 2f       	mov	r31, r19
    14cc:	fd 0d       	add	r31, r13
    14ce:	a1 e0       	ldi	r26, 0x01	; 1
    14d0:	f3 17       	cp	r31, r19
    14d2:	08 f0       	brcs	.+2      	; 0x14d6 <host_millis+0x86>
    14d4:	a0 e0       	ldi	r26, 0x00	; 0
    14d6:	bf 0f       	add	r27, r31
    14d8:	dd 24       	eor	r13, r13
    14da:	d3 94       	inc	r13
    14dc:	bf 17       	cp	r27, r31
    14de:	08 f0       	brcs	.+2      	; 0x14e2 <host_millis+0x92>
    14e0:	dd 24       	eor	r13, r13
    14e2:	ad 29       	or	r26, r13
    14e4:	f1 e0       	ldi	r31, 0x01	; 1
    14e6:	84 17       	cp	r24, r20
    14e8:	08 f0       	brcs	.+2      	; 0x14ec <host_millis+0x9c>
    14ea:	f0 e0       	ldi	r31, 0x00	; 0
    14ec:	a8 0f       	add	r26, r24
    14ee:	dd 24       	eor	r13, r13
    14f0:	d3 94       	inc	r13
    14f2:	a8 17       	cp	r26, r24
    14f4:	08 f0       	brcs	.+2      	; 0x14f8 <host_millis+0xa8>
    14f6:	dd 24       	eor	r13, r13
    14f8:	fd 29       	or	r31, r13
    14fa:	81 e0       	ldi	r24, 0x01	; 1
    14fc:	95 17       	cp	r25, r21
    14fe:	08 f0       	brcs	.+2      	; 0x1502 <host_millis+0xb2>
    1500:	80 e0       	ldi	r24, 0x00	; 0
    1502:	f9 0f       	add	r31, r25
    1504:	dd 24       	eor	r13, r13
    1506:	d3 94       	inc	r13
    1508:	f9 17       	cp	r31, r25
    150a:	08 f0       	brcs	.+2      	; 0x150e <host_millis+0xbe>
    150c:	dd 24       	eor	r13, r13
    150e:	8d 29       	or	r24, r13
    1510:	91 e0       	ldi	r25, 0x01	; 1
    1512:	e6 16       	cp	r14, r22
    1514:	08 f0       	brcs	.+2      	; 0x1518 <host_millis+0xc8>
    1516:	90 e0       	ldi	r25, 0x00	; 0
    1518:	8e 0d       	add	r24, r14
    151a:	21 e0       	ldi	r18, 0x01	; 1
    151c:	8e 15       	cp	r24, r14
    151e:	08 f0       	brcs	.+2      	; 0x1522 <host_millis+0xd2>
    1520:	20 e0       	ldi	r18, 0x00	; 0
    1522:	92 2b       	or	r25, r18
}
    1524:	2f 2d       	mov	r18, r15
    1526:	3d 2f       	mov	r19, r29
    1528:	4c 2f       	mov	r20, r28
    152a:	5b 2f       	mov	r21, r27
    152c:	6a 2f       	mov	r22, r26
    152e:	7f 2f       	mov	r23, r31
    1530:	9e 0f       	add	r25, r30
    1532:	df 91       	pop	r29
    1534:	cf 91       	pop	r28
    1536:	1f 91       	pop	r17
    1538:	0f 91       	pop	r16
    153a:	ff 90       	pop	r15
    153c:	ef 90       	pop	r14
    153e:	df 90       	pop	r13
    1540:	08 95       	ret

00001542 <set_time_oset>:

void set_time_oset(TIME_t t)
{
    1542:	df 92       	push	r13
    1544:	ef 92       	push	r14
    1546:	ff 92       	push	r15
    1548:	0f 93       	push	r16
    154a:	1f 93       	push	r17
    154c:	cf 93       	push	r28
    154e:	df 93       	push	r29
    1550:	f9 01       	movw	r30, r18
    1552:	da 01       	movw	r26, r20
    1554:	eb 01       	movw	r28, r22
	ms_time_t cur = cur_millis;
    1556:	00 91 49 04 	lds	r16, 0x0449
    155a:	10 91 4a 04 	lds	r17, 0x044A
    155e:	20 91 4b 04 	lds	r18, 0x044B
    1562:	30 91 4c 04 	lds	r19, 0x044C
	time_oset = t - cur;
    1566:	de 2e       	mov	r13, r30
    1568:	d0 1a       	sub	r13, r16
    156a:	ee 24       	eor	r14, r14
    156c:	e3 94       	inc	r14
    156e:	ed 15       	cp	r30, r13
    1570:	08 f0       	brcs	.+2      	; 0x1574 <set_time_oset+0x32>
    1572:	ee 24       	eor	r14, r14
    1574:	ef 2f       	mov	r30, r31
    1576:	e1 1b       	sub	r30, r17
    1578:	ff 24       	eor	r15, r15
    157a:	f3 94       	inc	r15
    157c:	fe 17       	cp	r31, r30
    157e:	08 f0       	brcs	.+2      	; 0x1582 <set_time_oset+0x40>
    1580:	ff 24       	eor	r15, r15
    1582:	fe 2f       	mov	r31, r30
    1584:	fe 19       	sub	r31, r14
    1586:	ef 2e       	mov	r14, r31
    1588:	f1 e0       	ldi	r31, 0x01	; 1
    158a:	ee 15       	cp	r30, r14
    158c:	08 f0       	brcs	.+2      	; 0x1590 <set_time_oset+0x4e>
    158e:	f0 e0       	ldi	r31, 0x00	; 0
    1590:	ff 2a       	or	r15, r31
    1592:	fa 2f       	mov	r31, r26
    1594:	f2 1b       	sub	r31, r18
    1596:	e1 e0       	ldi	r30, 0x01	; 1
    1598:	af 17       	cp	r26, r31
    159a:	08 f0       	brcs	.+2      	; 0x159e <set_time_oset+0x5c>
    159c:	e0 e0       	ldi	r30, 0x00	; 0
    159e:	af 2f       	mov	r26, r31
    15a0:	af 19       	sub	r26, r15
    15a2:	ff 24       	eor	r15, r15
    15a4:	f3 94       	inc	r15
    15a6:	fa 17       	cp	r31, r26
    15a8:	08 f0       	brcs	.+2      	; 0x15ac <set_time_oset+0x6a>
    15aa:	ff 24       	eor	r15, r15
    15ac:	ef 29       	or	r30, r15
    15ae:	fb 2f       	mov	r31, r27
    15b0:	f3 1b       	sub	r31, r19
    15b2:	3f 2f       	mov	r19, r31
    15b4:	21 e0       	ldi	r18, 0x01	; 1
    15b6:	bf 17       	cp	r27, r31
    15b8:	08 f0       	brcs	.+2      	; 0x15bc <set_time_oset+0x7a>
    15ba:	20 e0       	ldi	r18, 0x00	; 0
    15bc:	53 2f       	mov	r21, r19
    15be:	5e 1b       	sub	r21, r30
    15c0:	41 e0       	ldi	r20, 0x01	; 1
    15c2:	35 17       	cp	r19, r21
    15c4:	08 f0       	brcs	.+2      	; 0x15c8 <set_time_oset+0x86>
    15c6:	40 e0       	ldi	r20, 0x00	; 0
    15c8:	24 2b       	or	r18, r20
    15ca:	4c 2f       	mov	r20, r28
    15cc:	42 1b       	sub	r20, r18
    15ce:	21 e0       	ldi	r18, 0x01	; 1
    15d0:	c4 17       	cp	r28, r20
    15d2:	08 f0       	brcs	.+2      	; 0x15d6 <set_time_oset+0x94>
    15d4:	20 e0       	ldi	r18, 0x00	; 0
    15d6:	3d 2f       	mov	r19, r29
    15d8:	32 1b       	sub	r19, r18
    15da:	21 e0       	ldi	r18, 0x01	; 1
    15dc:	d3 17       	cp	r29, r19
    15de:	08 f0       	brcs	.+2      	; 0x15e2 <set_time_oset+0xa0>
    15e0:	20 e0       	ldi	r18, 0x00	; 0
    15e2:	68 2f       	mov	r22, r24
    15e4:	62 1b       	sub	r22, r18
    15e6:	26 2f       	mov	r18, r22
    15e8:	61 e0       	ldi	r22, 0x01	; 1
    15ea:	82 17       	cp	r24, r18
    15ec:	08 f0       	brcs	.+2      	; 0x15f0 <set_time_oset+0xae>
    15ee:	60 e0       	ldi	r22, 0x00	; 0
    15f0:	96 1b       	sub	r25, r22
    15f2:	d0 92 41 04 	sts	0x0441, r13
    15f6:	e0 92 42 04 	sts	0x0442, r14
    15fa:	a0 93 43 04 	sts	0x0443, r26
    15fe:	50 93 44 04 	sts	0x0444, r21
    1602:	40 93 45 04 	sts	0x0445, r20
    1606:	30 93 46 04 	sts	0x0446, r19
    160a:	20 93 47 04 	sts	0x0447, r18
    160e:	90 93 48 04 	sts	0x0448, r25
}
    1612:	df 91       	pop	r29
    1614:	cf 91       	pop	r28
    1616:	1f 91       	pop	r17
    1618:	0f 91       	pop	r16
    161a:	ff 90       	pop	r15
    161c:	ef 90       	pop	r14
    161e:	df 90       	pop	r13
    1620:	08 95       	ret

00001622 <time_to_wire>:
union ui64_byteview {
	uint64_t u64_val;
	uint8_t u8s[8];
};
void time_to_wire(TIME_t ms, uint8_t w[])
{
    1622:	0f 93       	push	r16
    1624:	1f 93       	push	r17
    1626:	cf 93       	push	r28
    1628:	df 93       	push	r29
    162a:	cd b7       	in	r28, 0x3d	; 61
    162c:	de b7       	in	r29, 0x3e	; 62
    162e:	28 97       	sbiw	r28, 0x08	; 8
    1630:	0f b6       	in	r0, 0x3f	; 63
    1632:	f8 94       	cli
    1634:	de bf       	out	0x3e, r29	; 62
    1636:	0f be       	out	0x3f, r0	; 63
    1638:	cd bf       	out	0x3d, r28	; 61
	union ui64_byteview val;
	val.u64_val = ms;
    163a:	29 83       	std	Y+1, r18	; 0x01
    163c:	3a 83       	std	Y+2, r19	; 0x02
    163e:	4b 83       	std	Y+3, r20	; 0x03
    1640:	5c 83       	std	Y+4, r21	; 0x04
    1642:	6d 83       	std	Y+5, r22	; 0x05
    1644:	7e 83       	std	Y+6, r23	; 0x06
    1646:	8f 83       	std	Y+7, r24	; 0x07
    1648:	98 87       	std	Y+8, r25	; 0x08
    164a:	de 01       	movw	r26, r28
    164c:	19 96       	adiw	r26, 0x09	; 9
    164e:	f8 01       	movw	r30, r16

union ui64_byteview {
	uint64_t u64_val;
	uint8_t u8s[8];
};
void time_to_wire(TIME_t ms, uint8_t w[])
    1650:	ce 01       	movw	r24, r28
    1652:	01 96       	adiw	r24, 0x01	; 1
{
	union ui64_byteview val;
	val.u64_val = ms;
	for (int i = 0; i < 8; i++) {
		w[i] = val.u8s[7-i];
    1654:	2e 91       	ld	r18, -X
    1656:	21 93       	st	Z+, r18
};
void time_to_wire(TIME_t ms, uint8_t w[])
{
	union ui64_byteview val;
	val.u64_val = ms;
	for (int i = 0; i < 8; i++) {
    1658:	a8 17       	cp	r26, r24
    165a:	b9 07       	cpc	r27, r25
    165c:	d9 f7       	brne	.-10     	; 0x1654 <time_to_wire+0x32>
		w[i] = val.u8s[7-i];
	}
}
    165e:	28 96       	adiw	r28, 0x08	; 8
    1660:	0f b6       	in	r0, 0x3f	; 63
    1662:	f8 94       	cli
    1664:	de bf       	out	0x3e, r29	; 62
    1666:	0f be       	out	0x3f, r0	; 63
    1668:	cd bf       	out	0x3d, r28	; 61
    166a:	df 91       	pop	r29
    166c:	cf 91       	pop	r28
    166e:	1f 91       	pop	r17
    1670:	0f 91       	pop	r16
    1672:	08 95       	ret

00001674 <time_from_wire>:

TIME_t time_from_wire(const uint8_t w[])
{
    1674:	cf 93       	push	r28
    1676:	df 93       	push	r29
    1678:	cd b7       	in	r28, 0x3d	; 61
    167a:	de b7       	in	r29, 0x3e	; 62
    167c:	28 97       	sbiw	r28, 0x08	; 8
    167e:	0f b6       	in	r0, 0x3f	; 63
    1680:	f8 94       	cli
    1682:	de bf       	out	0x3e, r29	; 62
    1684:	0f be       	out	0x3f, r0	; 63
    1686:	cd bf       	out	0x3d, r28	; 61
	for (int i = 0; i < 8; i++) {
		w[i] = val.u8s[7-i];
	}
}

TIME_t time_from_wire(const uint8_t w[])
    1688:	dc 01       	movw	r26, r24
    168a:	18 96       	adiw	r26, 0x08	; 8
{
	/* little-endian */
	union ui64_byteview val;
	for (int i = 0; i < 8; i++) {
    168c:	fe 01       	movw	r30, r28
    168e:	31 96       	adiw	r30, 0x01	; 1
    1690:	80 e0       	ldi	r24, 0x00	; 0
    1692:	90 e0       	ldi	r25, 0x00	; 0
		val.u8s[i] = w[7-i];
    1694:	2e 91       	ld	r18, -X
    1696:	21 93       	st	Z+, r18

TIME_t time_from_wire(const uint8_t w[])
{
	/* little-endian */
	union ui64_byteview val;
	for (int i = 0; i < 8; i++) {
    1698:	01 96       	adiw	r24, 0x01	; 1
    169a:	88 30       	cpi	r24, 0x08	; 8
    169c:	91 05       	cpc	r25, r1
    169e:	d1 f7       	brne	.-12     	; 0x1694 <time_from_wire+0x20>
		val.u8s[i] = w[7-i];
	}
	
	return val.u64_val;
    16a0:	29 81       	ldd	r18, Y+1	; 0x01
    16a2:	3a 81       	ldd	r19, Y+2	; 0x02
    16a4:	4b 81       	ldd	r20, Y+3	; 0x03
    16a6:	5c 81       	ldd	r21, Y+4	; 0x04
    16a8:	6d 81       	ldd	r22, Y+5	; 0x05
    16aa:	7e 81       	ldd	r23, Y+6	; 0x06
    16ac:	8f 81       	ldd	r24, Y+7	; 0x07
    16ae:	98 85       	ldd	r25, Y+8	; 0x08
    16b0:	28 96       	adiw	r28, 0x08	; 8
    16b2:	0f b6       	in	r0, 0x3f	; 63
    16b4:	f8 94       	cli
    16b6:	de bf       	out	0x3e, r29	; 62
    16b8:	0f be       	out	0x3f, r0	; 63
    16ba:	cd bf       	out	0x3d, r28	; 61
    16bc:	df 91       	pop	r29
    16be:	cf 91       	pop	r28
    16c0:	08 95       	ret

000016c2 <rfid_sendcommand_readtags>:
			 *  \return Boolean \c true if a character can be queued for transmission immediately, \c false otherwise.
			 */
			static inline bool Serial_IsSendReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Serial_IsSendReady(void)
			{
				return ((UCSR1A & (1 << UDRE1)) ? true : false);
    16c2:	80 91 c8 00 	lds	r24, 0x00C8
			 *  \param[in] DataByte  Byte to transmit through the USART.
			 */
			static inline void Serial_SendByte(const char DataByte) ATTR_ALWAYS_INLINE;
			static inline void Serial_SendByte(const char DataByte)
			{
				while (!(Serial_IsSendReady()));
    16c6:	85 ff       	sbrs	r24, 5
    16c8:	fc cf       	rjmp	.-8      	; 0x16c2 <rfid_sendcommand_readtags>
				UDR1 = DataByte;
    16ca:	83 e4       	ldi	r24, 0x43	; 67
    16cc:	80 93 ce 00 	sts	0x00CE, r24
			 *  \return Boolean \c true if a character can be queued for transmission immediately, \c false otherwise.
			 */
			static inline bool Serial_IsSendReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Serial_IsSendReady(void)
			{
				return ((UCSR1A & (1 << UDRE1)) ? true : false);
    16d0:	80 91 c8 00 	lds	r24, 0x00C8
			 *  \param[in] DataByte  Byte to transmit through the USART.
			 */
			static inline void Serial_SendByte(const char DataByte) ATTR_ALWAYS_INLINE;
			static inline void Serial_SendByte(const char DataByte)
			{
				while (!(Serial_IsSendReady()));
    16d4:	85 ff       	sbrs	r24, 5
    16d6:	fc cf       	rjmp	.-8      	; 0x16d0 <rfid_sendcommand_readtags+0xe>
				UDR1 = DataByte;
    16d8:	83 e0       	ldi	r24, 0x03	; 3
    16da:	80 93 ce 00 	sts	0x00CE, r24
			 *  \return Boolean \c true if a character can be queued for transmission immediately, \c false otherwise.
			 */
			static inline bool Serial_IsSendReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Serial_IsSendReady(void)
			{
				return ((UCSR1A & (1 << UDRE1)) ? true : false);
    16de:	80 91 c8 00 	lds	r24, 0x00C8
			 *  \param[in] DataByte  Byte to transmit through the USART.
			 */
			static inline void Serial_SendByte(const char DataByte) ATTR_ALWAYS_INLINE;
			static inline void Serial_SendByte(const char DataByte)
			{
				while (!(Serial_IsSendReady()));
    16e2:	85 ff       	sbrs	r24, 5
    16e4:	fc cf       	rjmp	.-8      	; 0x16de <rfid_sendcommand_readtags+0x1c>
				UDR1 = DataByte;
    16e6:	81 e0       	ldi	r24, 0x01	; 1
    16e8:	80 93 ce 00 	sts	0x00CE, r24
void rfid_sendcommand_readtags(void)
{
	Serial_SendByte(0x43);
	Serial_SendByte(0x03);
	Serial_SendByte(0x01);
}
    16ec:	08 95       	ret

000016ee <classify_tag>:
};



bool classify_tag(const unsigned char* tagbuf, unsigned char* out_len, const char** out_str)
{
    16ee:	4f 92       	push	r4
    16f0:	5f 92       	push	r5
    16f2:	6f 92       	push	r6
    16f4:	7f 92       	push	r7
    16f6:	8f 92       	push	r8
    16f8:	9f 92       	push	r9
    16fa:	af 92       	push	r10
    16fc:	bf 92       	push	r11
    16fe:	cf 92       	push	r12
    1700:	df 92       	push	r13
    1702:	ef 92       	push	r14
    1704:	ff 92       	push	r15
    1706:	0f 93       	push	r16
    1708:	1f 93       	push	r17
    170a:	cf 93       	push	r28
    170c:	df 93       	push	r29
    170e:	5c 01       	movw	r10, r24
    1710:	3b 01       	movw	r6, r22
    1712:	2a 01       	movw	r4, r20
	int c;
	ms_time_t now = millis();
    1714:	8e de       	rcall	.-740    	; 0x1432 <millis>
    1716:	6b 01       	movw	r12, r22
    1718:	7c 01       	movw	r14, r24
    171a:	00 e0       	ldi	r16, 0x00	; 0
	for (unsigned int i = 0; i < TAG_MAGIC_COUNT;i++) {
    171c:	10 e0       	ldi	r17, 0x00	; 0
    171e:	24 e1       	ldi	r18, 0x14	; 20
		c = memcmp((void*)tagbuf,(void*) tags[i].tag,TAG_LEN);
    1720:	82 2e       	mov	r8, r18
    1722:	91 2c       	mov	r9, r1
    1724:	08 9d       	mul	r16, r8
    1726:	e0 01       	movw	r28, r0
    1728:	09 9d       	mul	r16, r9
    172a:	d0 0d       	add	r29, r0
    172c:	18 9d       	mul	r17, r8
    172e:	d0 0d       	add	r29, r0
    1730:	11 24       	eor	r1, r1
    1732:	c8 54       	subi	r28, 0x48	; 72
    1734:	de 4f       	sbci	r29, 0xFE	; 254
    1736:	c5 01       	movw	r24, r10
    1738:	be 01       	movw	r22, r28
    173a:	4c e0       	ldi	r20, 0x0C	; 12
    173c:	50 e0       	ldi	r21, 0x00	; 0
    173e:	0e 94 e1 14 	call	0x29c2	; 0x29c2 <memcmp>
    1742:	00 97       	sbiw	r24, 0x00	; 0
		if (!c) {
    1744:	21 f5       	brne	.+72     	; 0x178e <classify_tag+0xa0>
    1746:	88 89       	ldd	r24, Y+16	; 0x10
			if ((now-tags[i].last_send_time) > DEBOUNCE_MS) {
    1748:	99 89       	ldd	r25, Y+17	; 0x11
    174a:	aa 89       	ldd	r26, Y+18	; 0x12
    174c:	bb 89       	ldd	r27, Y+19	; 0x13
    174e:	a7 01       	movw	r20, r14
    1750:	96 01       	movw	r18, r12
    1752:	28 1b       	sub	r18, r24
    1754:	39 0b       	sbc	r19, r25
    1756:	4a 0b       	sbc	r20, r26
    1758:	5b 0b       	sbc	r21, r27
    175a:	da 01       	movw	r26, r20
    175c:	c9 01       	movw	r24, r18
    175e:	c8 8a       	std	Y+16, r12	; 0x10
				tags[i].last_send_time = now;
    1760:	d9 8a       	std	Y+17, r13	; 0x11
    1762:	ea 8a       	std	Y+18, r14	; 0x12
    1764:	fb 8a       	std	Y+19, r15	; 0x13
    1766:	89 38       	cpi	r24, 0x89	; 137
	int c;
	ms_time_t now = millis();
	for (unsigned int i = 0; i < TAG_MAGIC_COUNT;i++) {
		c = memcmp((void*)tagbuf,(void*) tags[i].tag,TAG_LEN);
		if (!c) {
			if ((now-tags[i].last_send_time) > DEBOUNCE_MS) {
    1768:	33 e1       	ldi	r19, 0x13	; 19
    176a:	93 07       	cpc	r25, r19
    176c:	30 e0       	ldi	r19, 0x00	; 0
    176e:	a3 07       	cpc	r26, r19
    1770:	30 e0       	ldi	r19, 0x00	; 0
    1772:	b3 07       	cpc	r27, r19
    1774:	50 f0       	brcs	.+20     	; 0x178a <classify_tag+0x9c>
    1776:	ec 85       	ldd	r30, Y+12	; 0x0c
				tags[i].last_send_time = now;
				*out_len = pgm_read_byte(tags[i].msglen);
    1778:	fd 85       	ldd	r31, Y+13	; 0x0d
    177a:	e4 91       	lpm	r30, Z
    177c:	d3 01       	movw	r26, r6
    177e:	ec 93       	st	X, r30
    1780:	8e 85       	ldd	r24, Y+14	; 0x0e
				*out_str = tags[i].msg;
    1782:	9f 85       	ldd	r25, Y+15	; 0x0f
    1784:	f2 01       	movw	r30, r4
    1786:	91 83       	std	Z+1, r25	; 0x01
    1788:	80 83       	st	Z, r24
    178a:	81 e0       	ldi	r24, 0x01	; 1
				return 1; // str not null, true
			} else {
				tags[i].last_send_time = now;
				return 1;
    178c:	06 c0       	rjmp	.+12     	; 0x179a <classify_tag+0xac>
    178e:	0f 5f       	subi	r16, 0xFF	; 255

bool classify_tag(const unsigned char* tagbuf, unsigned char* out_len, const char** out_str)
{
	int c;
	ms_time_t now = millis();
	for (unsigned int i = 0; i < TAG_MAGIC_COUNT;i++) {
    1790:	1f 4f       	sbci	r17, 0xFF	; 255
    1792:	0f 30       	cpi	r16, 0x0F	; 15
    1794:	11 05       	cpc	r17, r1
    1796:	31 f6       	brne	.-116    	; 0x1724 <classify_tag+0x36>
    1798:	80 e0       	ldi	r24, 0x00	; 0
				tags[i].last_send_time = now;
				return 1;
			}
		}
	}
	return 0;
    179a:	df 91       	pop	r29
}
    179c:	cf 91       	pop	r28
    179e:	1f 91       	pop	r17
    17a0:	0f 91       	pop	r16
    17a2:	ff 90       	pop	r15
    17a4:	ef 90       	pop	r14
    17a6:	df 90       	pop	r13
    17a8:	cf 90       	pop	r12
    17aa:	bf 90       	pop	r11
    17ac:	af 90       	pop	r10
    17ae:	9f 90       	pop	r9
    17b0:	8f 90       	pop	r8
    17b2:	7f 90       	pop	r7
    17b4:	6f 90       	pop	r6
    17b6:	5f 90       	pop	r5
    17b8:	4f 90       	pop	r4
    17ba:	08 95       	ret

000017bc <rfid_enable_buzzer>:
    17bc:	3a de       	rcall	.-908    	; 0x1432 <millis>
	
}

void rfid_enable_buzzer(void)
{
	last_buzzer_enable = millis();
    17be:	dc 01       	movw	r26, r24
    17c0:	cb 01       	movw	r24, r22
    17c2:	80 93 e6 05 	sts	0x05E6, r24
    17c6:	90 93 e7 05 	sts	0x05E7, r25
    17ca:	a0 93 e8 05 	sts	0x05E8, r26
    17ce:	b0 93 e9 05 	sts	0x05E9, r27
    17d2:	2f 9a       	sbi	0x05, 7	; 5
	PORTB |= (1<<PB7);
    17d4:	08 95       	ret

000017d6 <heat_enable>:
#include "EscharotomyArm.h"

volatile uint8_t pulse_enabled;
void heat_enable(void)
{
	PORTB |= (1<<PB7);
    17d6:	2f 9a       	sbi	0x05, 7	; 5
}
    17d8:	08 95       	ret

000017da <pulse_stop>:
	last_loop_start = millis();
	pulse_enabled = 1;
}
void pulse_stop(void)
{
	pulse_enabled = 0;
    17da:	10 92 2a 06 	sts	0x062A, r1
}
    17de:	08 95       	ret

000017e0 <pulse_set_delay>:
void pulse_set_delay(int delay)
{
	pulse_enabled = 1;
    17e0:	21 e0       	ldi	r18, 0x01	; 1
    17e2:	20 93 2a 06 	sts	0x062A, r18
	if (delay > PULSE_NUM_ELTS) {
    17e6:	85 34       	cpi	r24, 0x45	; 69
    17e8:	91 05       	cpc	r25, r1
    17ea:	14 f4       	brge	.+4      	; 0x17f0 <pulse_set_delay+0x10>
		pulse_delay_ms = delay;
	} else {
		pulse_delay_ms = PULSE_NUM_ELTS; // FIXME 50% seems a good choice
    17ec:	84 e4       	ldi	r24, 0x44	; 68
    17ee:	90 e0       	ldi	r25, 0x00	; 0
    17f0:	90 93 e9 02 	sts	0x02E9, r25
    17f4:	80 93 e8 02 	sts	0x02E8, r24
    17f8:	08 95       	ret

000017fa <ram_prog_cmp>:
			return -1;
		} else if (ram[i] > pgm_read_byte(&(prog[i]))) {
			return 1;
		}
	}
	return 0;
    17fa:	dc 01       	movw	r26, r24
}


int ram_prog_cmp(char* ram, char* prog, int n)
{
	for (int i = 0; i < n; i++) {
    17fc:	80 e0       	ldi	r24, 0x00	; 0
    17fe:	90 e0       	ldi	r25, 0x00	; 0
    1800:	0a c0       	rjmp	.+20     	; 0x1816 <ram_prog_cmp+0x1c>
		if (ram[i] < pgm_read_byte(&(prog[i]))) {
    1802:	2d 91       	ld	r18, X+
	*/
	
}


int ram_prog_cmp(char* ram, char* prog, int n)
    1804:	fb 01       	movw	r30, r22
    1806:	e8 0f       	add	r30, r24
    1808:	f9 1f       	adc	r31, r25
{
	for (int i = 0; i < n; i++) {
		if (ram[i] < pgm_read_byte(&(prog[i]))) {
    180a:	e4 91       	lpm	r30, Z
    180c:	2e 17       	cp	r18, r30
    180e:	48 f0       	brcs	.+18     	; 0x1822 <ram_prog_cmp+0x28>
			return -1;
		} else if (ram[i] > pgm_read_byte(&(prog[i]))) {
    1810:	e2 17       	cp	r30, r18
    1812:	50 f0       	brcs	.+20     	; 0x1828 <ram_prog_cmp+0x2e>
}


int ram_prog_cmp(char* ram, char* prog, int n)
{
	for (int i = 0; i < n; i++) {
    1814:	01 96       	adiw	r24, 0x01	; 1
    1816:	84 17       	cp	r24, r20
    1818:	95 07       	cpc	r25, r21
    181a:	9c f3       	brlt	.-26     	; 0x1802 <ram_prog_cmp+0x8>
			return -1;
		} else if (ram[i] > pgm_read_byte(&(prog[i]))) {
			return 1;
		}
	}
	return 0;
    181c:	80 e0       	ldi	r24, 0x00	; 0
    181e:	90 e0       	ldi	r25, 0x00	; 0
    1820:	08 95       	ret

int ram_prog_cmp(char* ram, char* prog, int n)
{
	for (int i = 0; i < n; i++) {
		if (ram[i] < pgm_read_byte(&(prog[i]))) {
			return -1;
    1822:	8f ef       	ldi	r24, 0xFF	; 255
    1824:	9f ef       	ldi	r25, 0xFF	; 255
    1826:	08 95       	ret
		} else if (ram[i] > pgm_read_byte(&(prog[i]))) {
			return 1;
    1828:	81 e0       	ldi	r24, 0x01	; 1
    182a:	90 e0       	ldi	r25, 0x00	; 0
		}
	}
	return 0;
}
    182c:	08 95       	ret

0000182e <flow_sensor_handle_PROX>:

void flow_sensor_handle_PROX(char* data)
{
    182e:	0f 93       	push	r16
    1830:	1f 93       	push	r17
    1832:	cf 93       	push	r28
    1834:	df 93       	push	r29
    1836:	ec 01       	movw	r28, r24
#define AS_ACT_CMP_CASE(s) if (!ram_prog_cmp(data,(char*)&pstr_rcv_##s,MIN(data[0],pstr_rcv_##s .len))) {last_flowmsg_rcvd = el_##s;return;} 
	
	FLOW_ACT_MESSAGE_TABLE(AS_ACT_CMP_CASE);
    1838:	18 81       	ld	r17, Y
    183a:	41 2f       	mov	r20, r17
    183c:	1a 30       	cpi	r17, 0x0A	; 10
    183e:	08 f0       	brcs	.+2      	; 0x1842 <flow_sensor_handle_PROX+0x14>
    1840:	49 e0       	ldi	r20, 0x09	; 9
    1842:	ce 01       	movw	r24, r28
    1844:	67 e2       	ldi	r22, 0x27	; 39
    1846:	75 e0       	ldi	r23, 0x05	; 5
    1848:	50 e0       	ldi	r21, 0x00	; 0
    184a:	d7 df       	rcall	.-82     	; 0x17fa <ram_prog_cmp>
    184c:	00 97       	sbiw	r24, 0x00	; 0
    184e:	11 f4       	brne	.+4      	; 0x1854 <flow_sensor_handle_PROX+0x26>
    1850:	81 e0       	ldi	r24, 0x01	; 1
    1852:	4f c0       	rjmp	.+158    	; 0x18f2 <flow_sensor_handle_PROX+0xc4>
    1854:	01 2f       	mov	r16, r17
    1856:	19 30       	cpi	r17, 0x09	; 9
    1858:	08 f0       	brcs	.+2      	; 0x185c <flow_sensor_handle_PROX+0x2e>
    185a:	08 e0       	ldi	r16, 0x08	; 8
    185c:	ce 01       	movw	r24, r28
    185e:	6d e1       	ldi	r22, 0x1D	; 29
    1860:	75 e0       	ldi	r23, 0x05	; 5
    1862:	40 2f       	mov	r20, r16
    1864:	50 e0       	ldi	r21, 0x00	; 0
    1866:	c9 df       	rcall	.-110    	; 0x17fa <ram_prog_cmp>
    1868:	00 97       	sbiw	r24, 0x00	; 0
    186a:	11 f4       	brne	.+4      	; 0x1870 <flow_sensor_handle_PROX+0x42>
    186c:	82 e0       	ldi	r24, 0x02	; 2
    186e:	41 c0       	rjmp	.+130    	; 0x18f2 <flow_sensor_handle_PROX+0xc4>
    1870:	ce 01       	movw	r24, r28
    1872:	63 e1       	ldi	r22, 0x13	; 19
    1874:	75 e0       	ldi	r23, 0x05	; 5
    1876:	40 2f       	mov	r20, r16
    1878:	50 e0       	ldi	r21, 0x00	; 0
    187a:	bf df       	rcall	.-130    	; 0x17fa <ram_prog_cmp>
    187c:	00 97       	sbiw	r24, 0x00	; 0
    187e:	11 f4       	brne	.+4      	; 0x1884 <flow_sensor_handle_PROX+0x56>
    1880:	83 e0       	ldi	r24, 0x03	; 3
    1882:	37 c0       	rjmp	.+110    	; 0x18f2 <flow_sensor_handle_PROX+0xc4>
    1884:	ce 01       	movw	r24, r28
    1886:	69 e0       	ldi	r22, 0x09	; 9
    1888:	75 e0       	ldi	r23, 0x05	; 5
    188a:	40 2f       	mov	r20, r16
    188c:	50 e0       	ldi	r21, 0x00	; 0
    188e:	b5 df       	rcall	.-150    	; 0x17fa <ram_prog_cmp>
    1890:	00 97       	sbiw	r24, 0x00	; 0
    1892:	11 f4       	brne	.+4      	; 0x1898 <flow_sensor_handle_PROX+0x6a>
    1894:	84 e0       	ldi	r24, 0x04	; 4
    1896:	2d c0       	rjmp	.+90     	; 0x18f2 <flow_sensor_handle_PROX+0xc4>
    1898:	41 2f       	mov	r20, r17
    189a:	1c 30       	cpi	r17, 0x0C	; 12
    189c:	08 f0       	brcs	.+2      	; 0x18a0 <flow_sensor_handle_PROX+0x72>
    189e:	4b e0       	ldi	r20, 0x0B	; 11
    18a0:	ce 01       	movw	r24, r28
    18a2:	6c ef       	ldi	r22, 0xFC	; 252
    18a4:	74 e0       	ldi	r23, 0x04	; 4
    18a6:	50 e0       	ldi	r21, 0x00	; 0
    18a8:	a8 df       	rcall	.-176    	; 0x17fa <ram_prog_cmp>
    18aa:	00 97       	sbiw	r24, 0x00	; 0
    18ac:	11 f4       	brne	.+4      	; 0x18b2 <flow_sensor_handle_PROX+0x84>
    18ae:	85 e0       	ldi	r24, 0x05	; 5
    18b0:	20 c0       	rjmp	.+64     	; 0x18f2 <flow_sensor_handle_PROX+0xc4>
    18b2:	ce 01       	movw	r24, r28
    18b4:	62 ef       	ldi	r22, 0xF2	; 242
    18b6:	74 e0       	ldi	r23, 0x04	; 4
    18b8:	40 2f       	mov	r20, r16
    18ba:	50 e0       	ldi	r21, 0x00	; 0
    18bc:	9e df       	rcall	.-196    	; 0x17fa <ram_prog_cmp>
    18be:	00 97       	sbiw	r24, 0x00	; 0
    18c0:	11 f4       	brne	.+4      	; 0x18c6 <flow_sensor_handle_PROX+0x98>
    18c2:	86 e0       	ldi	r24, 0x06	; 6
    18c4:	16 c0       	rjmp	.+44     	; 0x18f2 <flow_sensor_handle_PROX+0xc4>
    18c6:	ce 01       	movw	r24, r28
    18c8:	68 ee       	ldi	r22, 0xE8	; 232
    18ca:	74 e0       	ldi	r23, 0x04	; 4
    18cc:	40 2f       	mov	r20, r16
    18ce:	50 e0       	ldi	r21, 0x00	; 0
    18d0:	94 df       	rcall	.-216    	; 0x17fa <ram_prog_cmp>
    18d2:	00 97       	sbiw	r24, 0x00	; 0
    18d4:	11 f4       	brne	.+4      	; 0x18da <flow_sensor_handle_PROX+0xac>
    18d6:	87 e0       	ldi	r24, 0x07	; 7
    18d8:	0c c0       	rjmp	.+24     	; 0x18f2 <flow_sensor_handle_PROX+0xc4>
    18da:	41 2f       	mov	r20, r17
    18dc:	14 30       	cpi	r17, 0x04	; 4
    18de:	08 f0       	brcs	.+2      	; 0x18e2 <flow_sensor_handle_PROX+0xb4>
    18e0:	43 e0       	ldi	r20, 0x03	; 3
    18e2:	ce 01       	movw	r24, r28
    18e4:	63 ee       	ldi	r22, 0xE3	; 227
    18e6:	74 e0       	ldi	r23, 0x04	; 4
    18e8:	50 e0       	ldi	r21, 0x00	; 0
    18ea:	87 df       	rcall	.-242    	; 0x17fa <ram_prog_cmp>
    18ec:	00 97       	sbiw	r24, 0x00	; 0
    18ee:	19 f4       	brne	.+6      	; 0x18f6 <flow_sensor_handle_PROX+0xc8>
    18f0:	88 e0       	ldi	r24, 0x08	; 8
    18f2:	80 93 4d 04 	sts	0x044D, r24
    18f6:	df 91       	pop	r29
    18f8:	cf 91       	pop	r28
    18fa:	1f 91       	pop	r17
    18fc:	0f 91       	pop	r16
    18fe:	08 95       	ret

00001900 <flow_sensor_handle_ACT>:
    1900:	64 ed       	ldi	r22, 0xD4	; 212
    1902:	74 e0       	ldi	r23, 0x04	; 4
    1904:	4d e0       	ldi	r20, 0x0D	; 13
	//determine which string it is
	
}
    1906:	50 e0       	ldi	r21, 0x00	; 0
    1908:	78 df       	rcall	.-272    	; 0x17fa <ram_prog_cmp>
    190a:	00 97       	sbiw	r24, 0x00	; 0
    190c:	19 f4       	brne	.+6      	; 0x1914 <flow_sensor_handle_ACT+0x14>
    190e:	81 e0       	ldi	r24, 0x01	; 1
DEFINE_PSTRING(iv_connected_str, "ARM_R_IV_CATH");
void flow_sensor_handle_ACT(char* data)
{
	//if ARM_R_IV_CATH is received, begin acknowledging IVs
	if (!ram_prog_cmp(data,(char*)&iv_connected_str,iv_connected_str.len)) {
		iv_connected = 1;
    1910:	80 93 2f 06 	sts	0x062F, r24
    1914:	08 95       	ret

00001916 <Endpoint_Write_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    1916:	af 92       	push	r10
    1918:	bf 92       	push	r11
    191a:	cf 92       	push	r12
    191c:	df 92       	push	r13
    191e:	ef 92       	push	r14
    1920:	ff 92       	push	r15
    1922:	1f 93       	push	r17
    1924:	cf 93       	push	r28
    1926:	df 93       	push	r29
    1928:	ec 01       	movw	r28, r24
    192a:	7b 01       	movw	r14, r22
    192c:	6a 01       	movw	r12, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    192e:	f0 d1       	rcall	.+992    	; 0x1d10 <Endpoint_WaitUntilReady>
    1930:	18 2f       	mov	r17, r24
    1932:	88 23       	and	r24, r24
    1934:	a9 f5       	brne	.+106    	; 0x19a0 <Endpoint_Write_Stream_LE+0x8a>
    1936:	c1 14       	cp	r12, r1
	  return ErrorCode;

	if (BytesProcessed != NULL)
    1938:	d1 04       	cpc	r13, r1
    193a:	39 f0       	breq	.+14     	; 0x194a <Endpoint_Write_Stream_LE+0x34>
    193c:	f6 01       	movw	r30, r12
	{
		Length -= *BytesProcessed;
    193e:	20 81       	ld	r18, Z
    1940:	31 81       	ldd	r19, Z+1	; 0x01
    1942:	e2 1a       	sub	r14, r18
    1944:	f3 0a       	sbc	r15, r19
    1946:	c2 0f       	add	r28, r18
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    1948:	d3 1f       	adc	r29, r19
    194a:	aa 24       	eor	r10, r10

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    194c:	bb 24       	eor	r11, r11
    194e:	23 c0       	rjmp	.+70     	; 0x1996 <Endpoint_Write_Stream_LE+0x80>
    1950:	80 91 e8 00 	lds	r24, 0x00E8
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    1954:	85 fd       	sbrc	r24, 5
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    1956:	16 c0       	rjmp	.+44     	; 0x1984 <Endpoint_Write_Stream_LE+0x6e>
    1958:	80 91 e8 00 	lds	r24, 0x00E8
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    195c:	8e 77       	andi	r24, 0x7E	; 126
    195e:	80 93 e8 00 	sts	0x00E8, r24
    1962:	98 d4       	rcall	.+2352   	; 0x2294 <USB_USBTask>
		{
			TEMPLATE_CLEAR_ENDPOINT();

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
    1964:	c1 14       	cp	r12, r1
    1966:	d1 04       	cpc	r13, r1
			#endif

			if (BytesProcessed != NULL)
    1968:	49 f0       	breq	.+18     	; 0x197c <Endpoint_Write_Stream_LE+0x66>
    196a:	f6 01       	movw	r30, r12
    196c:	80 81       	ld	r24, Z
			{
				*BytesProcessed += BytesInTransfer;
    196e:	91 81       	ldd	r25, Z+1	; 0x01
    1970:	8a 0d       	add	r24, r10
    1972:	9b 1d       	adc	r25, r11
    1974:	91 83       	std	Z+1, r25	; 0x01
    1976:	80 83       	st	Z, r24
    1978:	15 e0       	ldi	r17, 0x05	; 5
    197a:	12 c0       	rjmp	.+36     	; 0x19a0 <Endpoint_Write_Stream_LE+0x8a>
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
    197c:	c9 d1       	rcall	.+914    	; 0x1d10 <Endpoint_WaitUntilReady>
    197e:	88 23       	and	r24, r24
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    1980:	51 f0       	breq	.+20     	; 0x1996 <Endpoint_Write_Stream_LE+0x80>
    1982:	0d c0       	rjmp	.+26     	; 0x199e <Endpoint_Write_Stream_LE+0x88>
    1984:	89 91       	ld	r24, Y+
    1986:	80 93 f1 00 	sts	0x00F1, r24
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    198a:	08 94       	sec
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    198c:	e1 08       	sbc	r14, r1
    198e:	f1 08       	sbc	r15, r1
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    1990:	08 94       	sec
    1992:	a1 1c       	adc	r10, r1
    1994:	b1 1c       	adc	r11, r1
			BytesInTransfer++;
    1996:	e1 14       	cp	r14, r1
    1998:	f1 04       	cpc	r15, r1
    199a:	d1 f6       	brne	.-76     	; 0x1950 <Endpoint_Write_Stream_LE+0x3a>
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    199c:	01 c0       	rjmp	.+2      	; 0x19a0 <Endpoint_Write_Stream_LE+0x8a>
    199e:	18 2f       	mov	r17, r24
    19a0:	81 2f       	mov	r24, r17
    19a2:	df 91       	pop	r29
			{
				*BytesProcessed += BytesInTransfer;
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    19a4:	cf 91       	pop	r28
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    19a6:	1f 91       	pop	r17
    19a8:	ff 90       	pop	r15
    19aa:	ef 90       	pop	r14
    19ac:	df 90       	pop	r13
    19ae:	cf 90       	pop	r12
    19b0:	bf 90       	pop	r11
    19b2:	af 90       	pop	r10
    19b4:	08 95       	ret

000019b6 <Endpoint_Write_Control_Stream_LE>:
    19b6:	40 91 3d 06 	lds	r20, 0x063D
    19ba:	50 91 3e 06 	lds	r21, 0x063E
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    19be:	46 17       	cp	r20, r22
    19c0:	57 07       	cpc	r21, r23
    19c2:	20 f4       	brcc	.+8      	; 0x19cc <Endpoint_Write_Control_Stream_LE+0x16>
    19c4:	ba 01       	movw	r22, r20
    19c6:	fc 01       	movw	r30, r24
    19c8:	40 e0       	ldi	r20, 0x00	; 0
    19ca:	3d c0       	rjmp	.+122    	; 0x1a46 <Endpoint_Write_Control_Stream_LE+0x90>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    19cc:	61 15       	cp	r22, r1
    19ce:	71 05       	cpc	r23, r1
    19d0:	d1 f7       	brne	.-12     	; 0x19c6 <Endpoint_Write_Control_Stream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    19d2:	40 91 e8 00 	lds	r20, 0x00E8
    19d6:	4e 77       	andi	r20, 0x7E	; 126
    19d8:	40 93 e8 00 	sts	0x00E8, r20
    19dc:	f4 cf       	rjmp	.-24     	; 0x19c6 <Endpoint_Write_Control_Stream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    19de:	80 91 36 06 	lds	r24, 0x0636

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    19e2:	88 23       	and	r24, r24
    19e4:	09 f4       	brne	.+2      	; 0x19e8 <Endpoint_Write_Control_Stream_LE+0x32>
    19e6:	47 c0       	rjmp	.+142    	; 0x1a76 <Endpoint_Write_Control_Stream_LE+0xc0>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    19e8:	85 30       	cpi	r24, 0x05	; 5
    19ea:	09 f4       	brne	.+2      	; 0x19ee <Endpoint_Write_Control_Stream_LE+0x38>
    19ec:	46 c0       	rjmp	.+140    	; 0x1a7a <Endpoint_Write_Control_Stream_LE+0xc4>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    19ee:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    19f2:	83 fd       	sbrc	r24, 3
    19f4:	3e c0       	rjmp	.+124    	; 0x1a72 <Endpoint_Write_Control_Stream_LE+0xbc>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    19f6:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    19fa:	82 fd       	sbrc	r24, 2
    19fc:	34 c0       	rjmp	.+104    	; 0x1a66 <Endpoint_Write_Control_Stream_LE+0xb0>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    19fe:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    1a02:	80 ff       	sbrs	r24, 0
    1a04:	20 c0       	rjmp	.+64     	; 0x1a46 <Endpoint_Write_Control_Stream_LE+0x90>
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
				#elif defined(USB_SERIES_4_AVR)
					return (((uint16_t)UEBCHX << 8) | UEBCLX);
    1a06:	90 91 f3 00 	lds	r25, 0x00F3
    1a0a:	80 91 f2 00 	lds	r24, 0x00F2
    1a0e:	39 2f       	mov	r19, r25
    1a10:	20 e0       	ldi	r18, 0x00	; 0
    1a12:	90 e0       	ldi	r25, 0x00	; 0
    1a14:	82 2b       	or	r24, r18
    1a16:	93 2b       	or	r25, r19
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    1a18:	06 c0       	rjmp	.+12     	; 0x1a26 <Endpoint_Write_Control_Stream_LE+0x70>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    1a1a:	41 91       	ld	r20, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    1a1c:	40 93 f1 00 	sts	0x00F1, r20
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    1a20:	61 50       	subi	r22, 0x01	; 1
    1a22:	70 40       	sbci	r23, 0x00	; 0
				BytesInEndpoint++;
    1a24:	01 96       	adiw	r24, 0x01	; 1

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    1a26:	61 15       	cp	r22, r1
    1a28:	71 05       	cpc	r23, r1
    1a2a:	19 f0       	breq	.+6      	; 0x1a32 <Endpoint_Write_Control_Stream_LE+0x7c>
    1a2c:	88 30       	cpi	r24, 0x08	; 8
    1a2e:	91 05       	cpc	r25, r1
    1a30:	a0 f3       	brcs	.-24     	; 0x1a1a <Endpoint_Write_Control_Stream_LE+0x64>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    1a32:	41 e0       	ldi	r20, 0x01	; 1
    1a34:	88 30       	cpi	r24, 0x08	; 8
    1a36:	91 05       	cpc	r25, r1
    1a38:	09 f0       	breq	.+2      	; 0x1a3c <Endpoint_Write_Control_Stream_LE+0x86>
    1a3a:	40 e0       	ldi	r20, 0x00	; 0
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1a3c:	80 91 e8 00 	lds	r24, 0x00E8
    1a40:	8e 77       	andi	r24, 0x7E	; 126
    1a42:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    1a46:	61 15       	cp	r22, r1
    1a48:	71 05       	cpc	r23, r1
    1a4a:	49 f6       	brne	.-110    	; 0x19de <Endpoint_Write_Control_Stream_LE+0x28>
    1a4c:	44 23       	and	r20, r20
    1a4e:	39 f6       	brne	.-114    	; 0x19de <Endpoint_Write_Control_Stream_LE+0x28>
    1a50:	0a c0       	rjmp	.+20     	; 0x1a66 <Endpoint_Write_Control_Stream_LE+0xb0>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1a52:	80 91 36 06 	lds	r24, 0x0636

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1a56:	88 23       	and	r24, r24
    1a58:	71 f0       	breq	.+28     	; 0x1a76 <Endpoint_Write_Control_Stream_LE+0xc0>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1a5a:	85 30       	cpi	r24, 0x05	; 5
    1a5c:	71 f0       	breq	.+28     	; 0x1a7a <Endpoint_Write_Control_Stream_LE+0xc4>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1a5e:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1a62:	83 fd       	sbrc	r24, 3
    1a64:	0c c0       	rjmp	.+24     	; 0x1a7e <Endpoint_Write_Control_Stream_LE+0xc8>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1a66:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    1a6a:	82 ff       	sbrs	r24, 2
    1a6c:	f2 cf       	rjmp	.-28     	; 0x1a52 <Endpoint_Write_Control_Stream_LE+0x9c>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    1a6e:	80 e0       	ldi	r24, 0x00	; 0
    1a70:	08 95       	ret
		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    1a72:	81 e0       	ldi	r24, 0x01	; 1
    1a74:	08 95       	ret
	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    1a76:	82 e0       	ldi	r24, 0x02	; 2
    1a78:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    1a7a:	83 e0       	ldi	r24, 0x03	; 3
    1a7c:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    1a7e:	81 e0       	ldi	r24, 0x01	; 1
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    1a80:	08 95       	ret

00001a82 <Endpoint_Read_Control_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
    1a82:	61 15       	cp	r22, r1
    1a84:	71 05       	cpc	r23, r1
    1a86:	29 f4       	brne	.+10     	; 0x1a92 <Endpoint_Read_Control_Stream_LE+0x10>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    1a88:	40 91 e8 00 	lds	r20, 0x00E8
    1a8c:	4b 77       	andi	r20, 0x7B	; 123
    1a8e:	40 93 e8 00 	sts	0x00E8, r20

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
    1a92:	58 2f       	mov	r21, r24
    1a94:	49 2f       	mov	r20, r25
    1a96:	2b c0       	rjmp	.+86     	; 0x1aee <Endpoint_Read_Control_Stream_LE+0x6c>
	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1a98:	80 91 36 06 	lds	r24, 0x0636

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1a9c:	88 23       	and	r24, r24
    1a9e:	d9 f1       	breq	.+118    	; 0x1b16 <Endpoint_Read_Control_Stream_LE+0x94>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1aa0:	85 30       	cpi	r24, 0x05	; 5
    1aa2:	a9 f1       	breq	.+106    	; 0x1b0e <Endpoint_Read_Control_Stream_LE+0x8c>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1aa4:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1aa8:	83 fd       	sbrc	r24, 3
    1aaa:	33 c0       	rjmp	.+102    	; 0x1b12 <Endpoint_Read_Control_Stream_LE+0x90>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1aac:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
    1ab0:	82 ff       	sbrs	r24, 2
    1ab2:	f2 cf       	rjmp	.-28     	; 0x1a98 <Endpoint_Read_Control_Stream_LE+0x16>
    1ab4:	e5 2f       	mov	r30, r21
    1ab6:	f4 2f       	mov	r31, r20
    1ab8:	08 c0       	rjmp	.+16     	; 0x1aca <Endpoint_Read_Control_Stream_LE+0x48>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    1aba:	80 91 f1 00 	lds	r24, 0x00F1
		{
			while (Length && Endpoint_BytesInEndpoint())
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    1abe:	81 93       	st	Z+, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    1ac0:	5e 2f       	mov	r21, r30
    1ac2:	4f 2f       	mov	r20, r31
				Length--;
    1ac4:	61 50       	subi	r22, 0x01	; 1
    1ac6:	70 40       	sbci	r23, 0x00	; 0
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
		{
			while (Length && Endpoint_BytesInEndpoint())
    1ac8:	69 f0       	breq	.+26     	; 0x1ae4 <Endpoint_Read_Control_Stream_LE+0x62>
    1aca:	5e 2f       	mov	r21, r30
    1acc:	4f 2f       	mov	r20, r31
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
				#elif defined(USB_SERIES_4_AVR)
					return (((uint16_t)UEBCHX << 8) | UEBCLX);
    1ace:	90 91 f3 00 	lds	r25, 0x00F3
    1ad2:	80 91 f2 00 	lds	r24, 0x00F2
    1ad6:	39 2f       	mov	r19, r25
    1ad8:	20 e0       	ldi	r18, 0x00	; 0
    1ada:	90 e0       	ldi	r25, 0x00	; 0
    1adc:	82 2b       	or	r24, r18
    1ade:	93 2b       	or	r25, r19
    1ae0:	00 97       	sbiw	r24, 0x00	; 0
    1ae2:	59 f7       	brne	.-42     	; 0x1aba <Endpoint_Read_Control_Stream_LE+0x38>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    1ae4:	80 91 e8 00 	lds	r24, 0x00E8
    1ae8:	8b 77       	andi	r24, 0x7B	; 123
    1aea:	80 93 e8 00 	sts	0x00E8, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
    1aee:	61 15       	cp	r22, r1
    1af0:	71 05       	cpc	r23, r1
    1af2:	91 f6       	brne	.-92     	; 0x1a98 <Endpoint_Read_Control_Stream_LE+0x16>
    1af4:	06 c0       	rjmp	.+12     	; 0x1b02 <Endpoint_Read_Control_Stream_LE+0x80>
		}
	}

	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1af6:	80 91 36 06 	lds	r24, 0x0636

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1afa:	88 23       	and	r24, r24
    1afc:	61 f0       	breq	.+24     	; 0x1b16 <Endpoint_Read_Control_Stream_LE+0x94>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1afe:	85 30       	cpi	r24, 0x05	; 5
    1b00:	61 f0       	breq	.+24     	; 0x1b1a <Endpoint_Read_Control_Stream_LE+0x98>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1b02:	80 91 e8 00 	lds	r24, 0x00E8

			Endpoint_ClearOUT();
		}
	}

	while (!(Endpoint_IsINReady()))
    1b06:	80 ff       	sbrs	r24, 0
    1b08:	f6 cf       	rjmp	.-20     	; 0x1af6 <Endpoint_Read_Control_Stream_LE+0x74>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    1b0a:	80 e0       	ldi	r24, 0x00	; 0
    1b0c:	08 95       	ret
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    1b0e:	83 e0       	ldi	r24, 0x03	; 3
    1b10:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    1b12:	81 e0       	ldi	r24, 0x01	; 1
    1b14:	08 95       	ret
	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    1b16:	82 e0       	ldi	r24, 0x02	; 2
    1b18:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    1b1a:	83 e0       	ldi	r24, 0x03	; 3
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    1b1c:	08 95       	ret

00001b1e <Endpoint_Write_Control_PStream_LE>:
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    1b1e:	40 91 3d 06 	lds	r20, 0x063D
    1b22:	50 91 3e 06 	lds	r21, 0x063E
    1b26:	46 17       	cp	r20, r22
    1b28:	57 07       	cpc	r21, r23
    1b2a:	20 f4       	brcc	.+8      	; 0x1b34 <Endpoint_Write_Control_PStream_LE+0x16>
    1b2c:	ba 01       	movw	r22, r20
    1b2e:	fc 01       	movw	r30, r24
    1b30:	40 e0       	ldi	r20, 0x00	; 0
    1b32:	3e c0       	rjmp	.+124    	; 0x1bb0 <Endpoint_Write_Control_PStream_LE+0x92>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    1b34:	61 15       	cp	r22, r1
    1b36:	71 05       	cpc	r23, r1
    1b38:	d1 f7       	brne	.-12     	; 0x1b2e <Endpoint_Write_Control_PStream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1b3a:	40 91 e8 00 	lds	r20, 0x00E8
    1b3e:	4e 77       	andi	r20, 0x7E	; 126
    1b40:	40 93 e8 00 	sts	0x00E8, r20
    1b44:	f4 cf       	rjmp	.-24     	; 0x1b2e <Endpoint_Write_Control_PStream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1b46:	80 91 36 06 	lds	r24, 0x0636

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1b4a:	88 23       	and	r24, r24
    1b4c:	09 f4       	brne	.+2      	; 0x1b50 <Endpoint_Write_Control_PStream_LE+0x32>
    1b4e:	48 c0       	rjmp	.+144    	; 0x1be0 <Endpoint_Write_Control_PStream_LE+0xc2>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1b50:	85 30       	cpi	r24, 0x05	; 5
    1b52:	09 f4       	brne	.+2      	; 0x1b56 <Endpoint_Write_Control_PStream_LE+0x38>
    1b54:	47 c0       	rjmp	.+142    	; 0x1be4 <Endpoint_Write_Control_PStream_LE+0xc6>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1b56:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1b5a:	83 fd       	sbrc	r24, 3
    1b5c:	3f c0       	rjmp	.+126    	; 0x1bdc <Endpoint_Write_Control_PStream_LE+0xbe>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1b5e:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    1b62:	82 fd       	sbrc	r24, 2
    1b64:	35 c0       	rjmp	.+106    	; 0x1bd0 <Endpoint_Write_Control_PStream_LE+0xb2>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1b66:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    1b6a:	80 ff       	sbrs	r24, 0
    1b6c:	21 c0       	rjmp	.+66     	; 0x1bb0 <Endpoint_Write_Control_PStream_LE+0x92>
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
				#elif defined(USB_SERIES_4_AVR)
					return (((uint16_t)UEBCHX << 8) | UEBCLX);
    1b6e:	90 91 f3 00 	lds	r25, 0x00F3
    1b72:	80 91 f2 00 	lds	r24, 0x00F2
    1b76:	39 2f       	mov	r19, r25
    1b78:	20 e0       	ldi	r18, 0x00	; 0
    1b7a:	90 e0       	ldi	r25, 0x00	; 0
    1b7c:	82 2b       	or	r24, r18
    1b7e:	93 2b       	or	r25, r19
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    1b80:	07 c0       	rjmp	.+14     	; 0x1b90 <Endpoint_Write_Control_PStream_LE+0x72>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    1b82:	44 91       	lpm	r20, Z
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    1b84:	40 93 f1 00 	sts	0x00F1, r20
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    1b88:	31 96       	adiw	r30, 0x01	; 1
				Length--;
    1b8a:	61 50       	subi	r22, 0x01	; 1
    1b8c:	70 40       	sbci	r23, 0x00	; 0
				BytesInEndpoint++;
    1b8e:	01 96       	adiw	r24, 0x01	; 1

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    1b90:	61 15       	cp	r22, r1
    1b92:	71 05       	cpc	r23, r1
    1b94:	19 f0       	breq	.+6      	; 0x1b9c <Endpoint_Write_Control_PStream_LE+0x7e>
    1b96:	88 30       	cpi	r24, 0x08	; 8
    1b98:	91 05       	cpc	r25, r1
    1b9a:	98 f3       	brcs	.-26     	; 0x1b82 <Endpoint_Write_Control_PStream_LE+0x64>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    1b9c:	41 e0       	ldi	r20, 0x01	; 1
    1b9e:	88 30       	cpi	r24, 0x08	; 8
    1ba0:	91 05       	cpc	r25, r1
    1ba2:	09 f0       	breq	.+2      	; 0x1ba6 <Endpoint_Write_Control_PStream_LE+0x88>
    1ba4:	40 e0       	ldi	r20, 0x00	; 0
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1ba6:	80 91 e8 00 	lds	r24, 0x00E8
    1baa:	8e 77       	andi	r24, 0x7E	; 126
    1bac:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    1bb0:	61 15       	cp	r22, r1
    1bb2:	71 05       	cpc	r23, r1
    1bb4:	41 f6       	brne	.-112    	; 0x1b46 <Endpoint_Write_Control_PStream_LE+0x28>
    1bb6:	44 23       	and	r20, r20
    1bb8:	31 f6       	brne	.-116    	; 0x1b46 <Endpoint_Write_Control_PStream_LE+0x28>
    1bba:	0a c0       	rjmp	.+20     	; 0x1bd0 <Endpoint_Write_Control_PStream_LE+0xb2>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1bbc:	80 91 36 06 	lds	r24, 0x0636

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1bc0:	88 23       	and	r24, r24
    1bc2:	71 f0       	breq	.+28     	; 0x1be0 <Endpoint_Write_Control_PStream_LE+0xc2>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1bc4:	85 30       	cpi	r24, 0x05	; 5
    1bc6:	71 f0       	breq	.+28     	; 0x1be4 <Endpoint_Write_Control_PStream_LE+0xc6>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1bc8:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1bcc:	83 fd       	sbrc	r24, 3
    1bce:	0c c0       	rjmp	.+24     	; 0x1be8 <Endpoint_Write_Control_PStream_LE+0xca>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1bd0:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    1bd4:	82 ff       	sbrs	r24, 2
    1bd6:	f2 cf       	rjmp	.-28     	; 0x1bbc <Endpoint_Write_Control_PStream_LE+0x9e>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    1bd8:	80 e0       	ldi	r24, 0x00	; 0
    1bda:	08 95       	ret
		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    1bdc:	81 e0       	ldi	r24, 0x01	; 1
    1bde:	08 95       	ret
	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    1be0:	82 e0       	ldi	r24, 0x02	; 2
    1be2:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    1be4:	83 e0       	ldi	r24, 0x03	; 3
    1be6:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    1be8:	81 e0       	ldi	r24, 0x01	; 1
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    1bea:	08 95       	ret

00001bec <Endpoint_ConfigureEndpoint_Prv>:
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    1bec:	98 2f       	mov	r25, r24
    1bee:	2a c0       	rjmp	.+84     	; 0x1c44 <Endpoint_ConfigureEndpoint_Prv+0x58>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    1bf0:	90 93 e9 00 	sts	0x00E9, r25
		uint8_t UECFG1XTemp;
		uint8_t UEIENXTemp;

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
    1bf4:	98 17       	cp	r25, r24
    1bf6:	39 f0       	breq	.+14     	; 0x1c06 <Endpoint_ConfigureEndpoint_Prv+0x1a>
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
		}
		else
		{
			UECFG0XTemp = UECFG0X;
    1bf8:	70 91 ec 00 	lds	r23, 0x00EC
			UECFG1XTemp = UECFG1X;
    1bfc:	20 91 ed 00 	lds	r18, 0x00ED
			UEIENXTemp  = UEIENX;
    1c00:	50 91 f0 00 	lds	r21, 0x00F0
    1c04:	03 c0       	rjmp	.+6      	; 0x1c0c <Endpoint_ConfigureEndpoint_Prv+0x20>
		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
			UECFG1XTemp = UECFG1XData;
    1c06:	24 2f       	mov	r18, r20

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
    1c08:	76 2f       	mov	r23, r22
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
    1c0a:	50 e0       	ldi	r21, 0x00	; 0
			UECFG0XTemp = UECFG0X;
			UECFG1XTemp = UECFG1X;
			UEIENXTemp  = UEIENX;
		}

		if (!(UECFG1XTemp & (1 << ALLOC)))
    1c0c:	21 ff       	sbrs	r18, 1
    1c0e:	19 c0       	rjmp	.+50     	; 0x1c42 <Endpoint_ConfigureEndpoint_Prv+0x56>
			 *  to and from a host.
			 */
			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_DisableEndpoint(void)
			{
				UECONX &= ~(1 << EPEN);
    1c10:	30 91 eb 00 	lds	r19, 0x00EB
    1c14:	3e 7f       	andi	r19, 0xFE	; 254
    1c16:	30 93 eb 00 	sts	0x00EB, r19
		  continue;

		Endpoint_DisableEndpoint();
		UECFG1X &= ~(1 << ALLOC);
    1c1a:	30 91 ed 00 	lds	r19, 0x00ED
    1c1e:	3d 7f       	andi	r19, 0xFD	; 253
    1c20:	30 93 ed 00 	sts	0x00ED, r19
			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
			 */
			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_EnableEndpoint(void)
			{
				UECONX |= (1 << EPEN);
    1c24:	30 91 eb 00 	lds	r19, 0x00EB
    1c28:	31 60       	ori	r19, 0x01	; 1
    1c2a:	30 93 eb 00 	sts	0x00EB, r19

		Endpoint_EnableEndpoint();
		UECFG0X = UECFG0XTemp;
    1c2e:	70 93 ec 00 	sts	0x00EC, r23
		UECFG1X = UECFG1XTemp;
    1c32:	20 93 ed 00 	sts	0x00ED, r18
		UEIENX  = UEIENXTemp;
    1c36:	50 93 f0 00 	sts	0x00F0, r21
			 *  \return Boolean \c true if the currently selected endpoint has been configured, \c false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
    1c3a:	20 91 ee 00 	lds	r18, 0x00EE

		if (!(Endpoint_IsConfigured()))
    1c3e:	27 ff       	sbrs	r18, 7
    1c40:	08 c0       	rjmp	.+16     	; 0x1c52 <Endpoint_ConfigureEndpoint_Prv+0x66>
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    1c42:	9f 5f       	subi	r25, 0xFF	; 255
    1c44:	97 30       	cpi	r25, 0x07	; 7
    1c46:	a0 f2       	brcs	.-88     	; 0x1bf0 <Endpoint_ConfigureEndpoint_Prv+0x4>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    1c48:	8f 70       	andi	r24, 0x0F	; 15
    1c4a:	80 93 e9 00 	sts	0x00E9, r24
		if (!(Endpoint_IsConfigured()))
		  return false;
	}

	Endpoint_SelectEndpoint(Number);
	return true;
    1c4e:	81 e0       	ldi	r24, 0x01	; 1
    1c50:	08 95       	ret
		UECFG0X = UECFG0XTemp;
		UECFG1X = UECFG1XTemp;
		UEIENX  = UEIENXTemp;

		if (!(Endpoint_IsConfigured()))
		  return false;
    1c52:	80 e0       	ldi	r24, 0x00	; 0
	}

	Endpoint_SelectEndpoint(Number);
	return true;
#endif
}
    1c54:	08 95       	ret

00001c56 <Endpoint_ConfigureEndpointTable>:
uint8_t USB_Device_ControlEndpointSize = ENDPOINT_CONTROLEP_DEFAULT_SIZE;
#endif

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
    1c56:	0f 93       	push	r16
    1c58:	1f 93       	push	r17
    1c5a:	cf 93       	push	r28
    1c5c:	df 93       	push	r29
    1c5e:	16 2f       	mov	r17, r22
	{
		if (!(Table[i].Address))
		  continue;

		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
		  return false;
    1c60:	ec 01       	movw	r28, r24
#endif

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
	for (uint8_t i = 0; i < Entries; i++)
    1c62:	00 e0       	ldi	r16, 0x00	; 0
    1c64:	2a c0       	rjmp	.+84     	; 0x1cba <Endpoint_ConfigureEndpointTable+0x64>
	{
		if (!(Table[i].Address))
    1c66:	98 81       	ld	r25, Y
    1c68:	99 23       	and	r25, r25
    1c6a:	29 f1       	breq	.+74     	; 0x1cb6 <Endpoint_ConfigureEndpointTable+0x60>
		  continue;

		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
    1c6c:	6b 81       	ldd	r22, Y+3	; 0x03
    1c6e:	e9 81       	ldd	r30, Y+1	; 0x01
    1c70:	fa 81       	ldd	r31, Y+2	; 0x02
    1c72:	2c 81       	ldd	r18, Y+4	; 0x04
			static inline bool Endpoint_ConfigureEndpoint(const uint8_t Address,
			                                              const uint8_t Type,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);
    1c74:	89 2f       	mov	r24, r25
    1c76:	8f 70       	andi	r24, 0x0F	; 15

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
    1c78:	87 30       	cpi	r24, 0x07	; 7
    1c7a:	18 f5       	brcc	.+70     	; 0x1cc2 <Endpoint_ConfigureEndpointTable+0x6c>
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
				                                      ((Type << EPTYPE0) | ((Address & ENDPOINT_DIR_IN) ? (1 << EPDIR) : 0)),
    1c7c:	62 95       	swap	r22
    1c7e:	66 0f       	add	r22, r22
    1c80:	66 0f       	add	r22, r22
    1c82:	60 7c       	andi	r22, 0xC0	; 192
    1c84:	99 1f       	adc	r25, r25
    1c86:	99 27       	eor	r25, r25
    1c88:	99 1f       	adc	r25, r25
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    1c8a:	69 2b       	or	r22, r25
    1c8c:	22 30       	cpi	r18, 0x02	; 2
    1c8e:	10 f0       	brcs	.+4      	; 0x1c94 <Endpoint_ConfigureEndpointTable+0x3e>
    1c90:	96 e0       	ldi	r25, 0x06	; 6
    1c92:	01 c0       	rjmp	.+2      	; 0x1c96 <Endpoint_ConfigureEndpointTable+0x40>
    1c94:	92 e0       	ldi	r25, 0x02	; 2
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST
			                                                                       ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;
    1c96:	28 e0       	ldi	r18, 0x08	; 8
    1c98:	30 e0       	ldi	r19, 0x00	; 0
		/* Inline Functions: */
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST
			                                                                       ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
    1c9a:	40 e0       	ldi	r20, 0x00	; 0
    1c9c:	03 c0       	rjmp	.+6      	; 0x1ca4 <Endpoint_ConfigureEndpointTable+0x4e>
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
				{
					MaskVal++;
    1c9e:	4f 5f       	subi	r20, 0xFF	; 255
					CheckBytes <<= 1;
    1ca0:	22 0f       	add	r18, r18
    1ca2:	33 1f       	adc	r19, r19
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
    1ca4:	2e 17       	cp	r18, r30
    1ca6:	3f 07       	cpc	r19, r31
    1ca8:	d0 f3       	brcs	.-12     	; 0x1c9e <Endpoint_ConfigureEndpointTable+0x48>
				{
					MaskVal++;
					CheckBytes <<= 1;
				}

				return (MaskVal << EPSIZE0);
    1caa:	42 95       	swap	r20
    1cac:	40 7f       	andi	r20, 0xF0	; 240
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    1cae:	49 2b       	or	r20, r25
    1cb0:	9d df       	rcall	.-198    	; 0x1bec <Endpoint_ConfigureEndpoint_Prv>
    1cb2:	88 23       	and	r24, r24
    1cb4:	31 f0       	breq	.+12     	; 0x1cc2 <Endpoint_ConfigureEndpointTable+0x6c>
    1cb6:	0f 5f       	subi	r16, 0xFF	; 255
#endif

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
	for (uint8_t i = 0; i < Entries; i++)
    1cb8:	25 96       	adiw	r28, 0x05	; 5
    1cba:	01 17       	cp	r16, r17
    1cbc:	a1 f6       	brne	.-88     	; 0x1c66 <Endpoint_ConfigureEndpointTable+0x10>
    1cbe:	81 e0       	ldi	r24, 0x01	; 1

		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
		  return false;
	}

	return true;
    1cc0:	01 c0       	rjmp	.+2      	; 0x1cc4 <Endpoint_ConfigureEndpointTable+0x6e>
    1cc2:	80 e0       	ldi	r24, 0x00	; 0
	{
		if (!(Table[i].Address))
		  continue;

		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
		  return false;
    1cc4:	df 91       	pop	r29
	}

	return true;
}
    1cc6:	cf 91       	pop	r28
    1cc8:	1f 91       	pop	r17
    1cca:	0f 91       	pop	r16
    1ccc:	08 95       	ret

00001cce <Endpoint_ClearStatusStage>:
    1cce:	80 91 37 06 	lds	r24, 0x0637
	}
}

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    1cd2:	87 ff       	sbrs	r24, 7
    1cd4:	13 c0       	rjmp	.+38     	; 0x1cfc <Endpoint_ClearStatusStage+0x2e>
    1cd6:	04 c0       	rjmp	.+8      	; 0x1ce0 <Endpoint_ClearStatusStage+0x12>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    1cd8:	80 91 36 06 	lds	r24, 0x0636
    1cdc:	88 23       	and	r24, r24
    1cde:	b9 f0       	breq	.+46     	; 0x1d0e <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1ce0:	80 91 e8 00 	lds	r24, 0x00E8

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    1ce4:	82 ff       	sbrs	r24, 2
    1ce6:	f8 cf       	rjmp	.-16     	; 0x1cd8 <Endpoint_ClearStatusStage+0xa>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    1ce8:	80 91 e8 00 	lds	r24, 0x00E8
    1cec:	8b 77       	andi	r24, 0x7B	; 123
    1cee:	80 93 e8 00 	sts	0x00E8, r24
    1cf2:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    1cf4:	80 91 36 06 	lds	r24, 0x0636
    1cf8:	88 23       	and	r24, r24
    1cfa:	49 f0       	breq	.+18     	; 0x1d0e <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1cfc:	80 91 e8 00 	lds	r24, 0x00E8

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    1d00:	80 ff       	sbrs	r24, 0
    1d02:	f8 cf       	rjmp	.-16     	; 0x1cf4 <Endpoint_ClearStatusStage+0x26>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1d04:	80 91 e8 00 	lds	r24, 0x00E8
    1d08:	8e 77       	andi	r24, 0x7E	; 126
    1d0a:	80 93 e8 00 	sts	0x00E8, r24
    1d0e:	08 95       	ret

00001d10 <Endpoint_WaitUntilReady>:
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    1d10:	80 91 e4 00 	lds	r24, 0x00E4
    1d14:	90 91 e5 00 	lds	r25, 0x00E5
    1d18:	45 e6       	ldi	r20, 0x65	; 101
    1d1a:	01 c0       	rjmp	.+2      	; 0x1d1e <Endpoint_WaitUntilReady+0xe>
    1d1c:	c9 01       	movw	r24, r18
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    1d1e:	20 91 ec 00 	lds	r18, 0x00EC
    1d22:	20 ff       	sbrs	r18, 0
    1d24:	23 c0       	rjmp	.+70     	; 0x1d6c <Endpoint_WaitUntilReady+0x5c>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1d26:	20 91 e8 00 	lds	r18, 0x00E8

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
    1d2a:	20 fd       	sbrc	r18, 0
    1d2c:	15 c0       	rjmp	.+42     	; 0x1d58 <Endpoint_WaitUntilReady+0x48>
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1d2e:	20 91 36 06 	lds	r18, 0x0636

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1d32:	22 23       	and	r18, r18
    1d34:	99 f0       	breq	.+38     	; 0x1d5c <Endpoint_WaitUntilReady+0x4c>
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1d36:	25 30       	cpi	r18, 0x05	; 5
    1d38:	99 f0       	breq	.+38     	; 0x1d60 <Endpoint_WaitUntilReady+0x50>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    1d3a:	20 91 eb 00 	lds	r18, 0x00EB
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    1d3e:	25 fd       	sbrc	r18, 5
    1d40:	11 c0       	rjmp	.+34     	; 0x1d64 <Endpoint_WaitUntilReady+0x54>
    1d42:	20 91 e4 00 	lds	r18, 0x00E4
    1d46:	30 91 e5 00 	lds	r19, 0x00E5
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    1d4a:	28 17       	cp	r18, r24
    1d4c:	39 07       	cpc	r19, r25
    1d4e:	39 f3       	breq	.-50     	; 0x1d1e <Endpoint_WaitUntilReady+0xe>
    1d50:	41 50       	subi	r20, 0x01	; 1
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    1d52:	21 f7       	brne	.-56     	; 0x1d1c <Endpoint_WaitUntilReady+0xc>
			  return ENDPOINT_READYWAIT_Timeout;
    1d54:	84 e0       	ldi	r24, 0x04	; 4
    1d56:	08 95       	ret
	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
    1d58:	80 e0       	ldi	r24, 0x00	; 0
    1d5a:	08 95       	ret
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
    1d5c:	82 e0       	ldi	r24, 0x02	; 2
    1d5e:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_READYWAIT_BusSuspended;
    1d60:	83 e0       	ldi	r24, 0x03	; 3
    1d62:	08 95       	ret
		else if (Endpoint_IsStalled())
		  return ENDPOINT_READYWAIT_EndpointStalled;
    1d64:	81 e0       	ldi	r24, 0x01	; 1
    1d66:	08 95       	ret
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
    1d68:	80 e0       	ldi	r24, 0x00	; 0

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    1d6a:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1d6c:	20 91 e8 00 	lds	r18, 0x00E8
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    1d70:	22 ff       	sbrs	r18, 2
    1d72:	dd cf       	rjmp	.-70     	; 0x1d2e <Endpoint_WaitUntilReady+0x1e>
    1d74:	f9 cf       	rjmp	.-14     	; 0x1d68 <Endpoint_WaitUntilReady+0x58>

00001d76 <USB_ResetInterface>:

	USB_IsInitialized = false;
}

void USB_ResetInterface(void)
{
    1d76:	0f 93       	push	r16
    1d78:	1f 93       	push	r17
    1d7a:	cf 93       	push	r28
    1d7c:	df 93       	push	r29
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
    1d7e:	4b d0       	rcall	.+150    	; 0x1e16 <USB_INT_DisableAllInterrupts>
    1d80:	52 d0       	rcall	.+164    	; 0x1e26 <USB_INT_ClearAllInterrupts>
	USB_INT_ClearAllInterrupts();
    1d82:	c8 ed       	ldi	r28, 0xD8	; 216
    1d84:	d0 e0       	ldi	r29, 0x00	; 0
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USBCON &= ~(1 << USBE);
    1d86:	88 81       	ld	r24, Y
    1d88:	8f 77       	andi	r24, 0x7F	; 127
    1d8a:	88 83       	st	Y, r24
    1d8c:	88 81       	ld	r24, Y
    1d8e:	80 68       	ori	r24, 0x80	; 128
				USBCON |=  (1 << USBE);
    1d90:	88 83       	st	Y, r24
    1d92:	88 81       	ld	r24, Y
    1d94:	8f 7d       	andi	r24, 0xDF	; 223
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    1d96:	88 83       	st	Y, r24
    1d98:	19 bc       	out	0x29, r1	; 41
    1d9a:	10 92 36 06 	sts	0x0636, r1
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    1d9e:	10 92 32 06 	sts	0x0632, r1
	USB_Device_ConfigurationNumber  = 0;
    1da2:	10 92 34 06 	sts	0x0634, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    1da6:	10 92 33 06 	sts	0x0633, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    1daa:	00 ee       	ldi	r16, 0xE0	; 224
    1dac:	10 e0       	ldi	r17, 0x00	; 0
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
    1dae:	f8 01       	movw	r30, r16
    1db0:	80 81       	ld	r24, Z
    1db2:	8b 7f       	andi	r24, 0xFB	; 251
    1db4:	80 83       	st	Z, r24
    1db6:	88 81       	ld	r24, Y
    1db8:	81 60       	ori	r24, 0x01	; 1
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBCON |= (1 << VBUSTE);
    1dba:	88 83       	st	Y, r24
    1dbc:	80 e0       	ldi	r24, 0x00	; 0
    1dbe:	60 e0       	ldi	r22, 0x00	; 0
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    1dc0:	42 e0       	ldi	r20, 0x02	; 2
    1dc2:	14 df       	rcall	.-472    	; 0x1bec <Endpoint_ConfigureEndpoint_Prv>
    1dc4:	e1 ee       	ldi	r30, 0xE1	; 225
    1dc6:	f0 e0       	ldi	r31, 0x00	; 0
    1dc8:	80 81       	ld	r24, Z
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    1dca:	8e 7f       	andi	r24, 0xFE	; 254
    1dcc:	80 83       	st	Z, r24
    1dce:	e2 ee       	ldi	r30, 0xE2	; 226
    1dd0:	f0 e0       	ldi	r31, 0x00	; 0
    1dd2:	80 81       	ld	r24, Z
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    1dd4:	81 60       	ori	r24, 0x01	; 1
    1dd6:	80 83       	st	Z, r24
    1dd8:	80 81       	ld	r24, Z
    1dda:	88 60       	ori	r24, 0x08	; 8
    1ddc:	80 83       	st	Z, r24
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
    1dde:	f8 01       	movw	r30, r16
    1de0:	80 81       	ld	r24, Z
    1de2:	8e 7f       	andi	r24, 0xFE	; 254
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    1de4:	80 83       	st	Z, r24
    1de6:	88 81       	ld	r24, Y
    1de8:	80 61       	ori	r24, 0x10	; 16
    1dea:	88 83       	st	Y, r24

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON |=  (1 << OTGPADE);
    1dec:	df 91       	pop	r29
    1dee:	cf 91       	pop	r28
    1df0:	1f 91       	pop	r17
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    1df2:	0f 91       	pop	r16
    1df4:	08 95       	ret

00001df6 <USB_Init>:
    1df6:	e8 ed       	ldi	r30, 0xD8	; 216
    1df8:	f0 e0       	ldi	r31, 0x00	; 0
    1dfa:	80 81       	ld	r24, Z
			}

			static inline void USB_OTGPAD_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_Off(void)
			{
				USBCON &= ~(1 << OTGPADE);
    1dfc:	8f 7e       	andi	r24, 0xEF	; 239
    1dfe:	80 83       	st	Z, r24

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON |=  (1 << UVREGE);
    1e00:	e7 ed       	ldi	r30, 0xD7	; 215
    1e02:	f0 e0       	ldi	r31, 0x00	; 0
    1e04:	80 81       	ld	r24, Z
    1e06:	81 60       	ori	r24, 0x01	; 1
    1e08:	80 83       	st	Z, r24
	  USB_REG_Off();

	if (!(USB_Options & USB_OPT_MANUAL_PLL))
	{
		#if defined(USB_SERIES_4_AVR)
		PLLFRQ = (1 << PDIV2);
    1e0a:	84 e0       	ldi	r24, 0x04	; 4
    1e0c:	82 bf       	out	0x32, r24	; 50
		UHWCON &= ~(1 << UIDE);
		USB_CurrentMode = Mode;
	}
	#endif

	USB_IsInitialized = true;
    1e0e:	81 e0       	ldi	r24, 0x01	; 1
    1e10:	80 93 35 06 	sts	0x0635, r24

	USB_ResetInterface();
    1e14:	b0 cf       	rjmp	.-160    	; 0x1d76 <USB_ResetInterface>

00001e16 <USB_INT_DisableAllInterrupts>:
void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
	#elif defined(USB_SERIES_4_AVR)
	USBCON &= ~(1 << VBUSTE);
    1e16:	e8 ed       	ldi	r30, 0xD8	; 216
    1e18:	f0 e0       	ldi	r31, 0x00	; 0
    1e1a:	80 81       	ld	r24, Z
    1e1c:	8e 7f       	andi	r24, 0xFE	; 254
    1e1e:	80 83       	st	Z, r24
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    1e20:	10 92 e2 00 	sts	0x00E2, r1
	#endif
}
    1e24:	08 95       	ret

00001e26 <USB_INT_ClearAllInterrupts>:

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
    1e26:	10 92 da 00 	sts	0x00DA, r1
	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
    1e2a:	10 92 e1 00 	sts	0x00E1, r1
	#endif
}
    1e2e:	08 95       	ret

00001e30 <__vector_10>:

ISR(USB_GEN_vect, ISR_BLOCK)
{
    1e30:	1f 92       	push	r1
    1e32:	0f 92       	push	r0
    1e34:	0f b6       	in	r0, 0x3f	; 63
    1e36:	0f 92       	push	r0
    1e38:	11 24       	eor	r1, r1
    1e3a:	2f 93       	push	r18
    1e3c:	3f 93       	push	r19
    1e3e:	4f 93       	push	r20
    1e40:	5f 93       	push	r21
    1e42:	6f 93       	push	r22
    1e44:	7f 93       	push	r23
    1e46:	8f 93       	push	r24
    1e48:	9f 93       	push	r25
    1e4a:	af 93       	push	r26
    1e4c:	bf 93       	push	r27
    1e4e:	ef 93       	push	r30
    1e50:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
    1e52:	80 91 e1 00 	lds	r24, 0x00E1
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    1e56:	82 ff       	sbrs	r24, 2
    1e58:	0b c0       	rjmp	.+22     	; 0x1e70 <__vector_10+0x40>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
    1e5a:	80 91 e2 00 	lds	r24, 0x00E2
    1e5e:	82 ff       	sbrs	r24, 2
    1e60:	07 c0       	rjmp	.+14     	; 0x1e70 <__vector_10+0x40>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
    1e62:	80 91 e1 00 	lds	r24, 0x00E1
    1e66:	8b 7f       	andi	r24, 0xFB	; 251
    1e68:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    1e6c:	0e 94 ba 04 	call	0x974	; 0x974 <EVENT_USB_Device_StartOfFrame>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
    1e70:	80 91 da 00 	lds	r24, 0x00DA
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
    1e74:	80 ff       	sbrs	r24, 0
    1e76:	1f c0       	rjmp	.+62     	; 0x1eb6 <__vector_10+0x86>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
    1e78:	80 91 d8 00 	lds	r24, 0x00D8
    1e7c:	80 ff       	sbrs	r24, 0
    1e7e:	1b c0       	rjmp	.+54     	; 0x1eb6 <__vector_10+0x86>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
    1e80:	80 91 da 00 	lds	r24, 0x00DA
    1e84:	8e 7f       	andi	r24, 0xFE	; 254
    1e86:	80 93 da 00 	sts	0x00DA, r24
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    1e8a:	80 91 d9 00 	lds	r24, 0x00D9
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
    1e8e:	80 ff       	sbrs	r24, 0
    1e90:	0d c0       	rjmp	.+26     	; 0x1eac <__vector_10+0x7c>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    1e92:	80 e1       	ldi	r24, 0x10	; 16
    1e94:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    1e96:	82 e1       	ldi	r24, 0x12	; 18
    1e98:	89 bd       	out	0x29, r24	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
    1e9a:	09 b4       	in	r0, 0x29	; 41
    1e9c:	00 fe       	sbrs	r0, 0
    1e9e:	fd cf       	rjmp	.-6      	; 0x1e9a <__vector_10+0x6a>
			}

			USB_DeviceState = DEVICE_STATE_Powered;
    1ea0:	81 e0       	ldi	r24, 0x01	; 1
    1ea2:	80 93 36 06 	sts	0x0636, r24
			EVENT_USB_Device_Connect();
    1ea6:	0e 94 a3 04 	call	0x946	; 0x946 <EVENT_USB_Device_Connect>
    1eaa:	05 c0       	rjmp	.+10     	; 0x1eb6 <__vector_10+0x86>
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    1eac:	19 bc       	out	0x29, r1	; 41
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
    1eae:	10 92 36 06 	sts	0x0636, r1
			EVENT_USB_Device_Disconnect();
    1eb2:	0e 94 a5 04 	call	0x94a	; 0x94a <EVENT_USB_Device_Disconnect>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
    1eb6:	80 91 e1 00 	lds	r24, 0x00E1
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    1eba:	80 ff       	sbrs	r24, 0
    1ebc:	18 c0       	rjmp	.+48     	; 0x1eee <__vector_10+0xbe>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
    1ebe:	80 91 e2 00 	lds	r24, 0x00E2
    1ec2:	80 ff       	sbrs	r24, 0
    1ec4:	14 c0       	rjmp	.+40     	; 0x1eee <__vector_10+0xbe>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    1ec6:	80 91 e2 00 	lds	r24, 0x00E2
    1eca:	8e 7f       	andi	r24, 0xFE	; 254
    1ecc:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    1ed0:	80 91 e2 00 	lds	r24, 0x00E2
    1ed4:	80 61       	ori	r24, 0x10	; 16
    1ed6:	80 93 e2 00 	sts	0x00E2, r24
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON |=  (1 << FRZCLK);
    1eda:	80 91 d8 00 	lds	r24, 0x00D8
    1ede:	80 62       	ori	r24, 0x20	; 32
    1ee0:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    1ee4:	19 bc       	out	0x29, r1	; 41

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    1ee6:	85 e0       	ldi	r24, 0x05	; 5
    1ee8:	80 93 36 06 	sts	0x0636, r24
		EVENT_USB_Device_Suspend();
    1eec:	d2 d1       	rcall	.+932    	; 0x2292 <USB_Event_Stub>
    1eee:	80 91 e1 00 	lds	r24, 0x00E1
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
    1ef2:	84 ff       	sbrs	r24, 4
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    1ef4:	2f c0       	rjmp	.+94     	; 0x1f54 <__vector_10+0x124>
    1ef6:	80 91 e2 00 	lds	r24, 0x00E2
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
    1efa:	84 ff       	sbrs	r24, 4
    1efc:	2b c0       	rjmp	.+86     	; 0x1f54 <__vector_10+0x124>
    1efe:	80 e1       	ldi	r24, 0x10	; 16

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    1f00:	89 bd       	out	0x29, r24	; 41
    1f02:	82 e1       	ldi	r24, 0x12	; 18
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    1f04:	89 bd       	out	0x29, r24	; 41
    1f06:	09 b4       	in	r0, 0x29	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    1f08:	00 fe       	sbrs	r0, 0
    1f0a:	fd cf       	rjmp	.-6      	; 0x1f06 <__vector_10+0xd6>
    1f0c:	80 91 d8 00 	lds	r24, 0x00D8
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    1f10:	8f 7d       	andi	r24, 0xDF	; 223
    1f12:	80 93 d8 00 	sts	0x00D8, r24
    1f16:	80 91 e1 00 	lds	r24, 0x00E1
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
    1f1a:	8f 7e       	andi	r24, 0xEF	; 239
    1f1c:	80 93 e1 00 	sts	0x00E1, r24
    1f20:	80 91 e2 00 	lds	r24, 0x00E2
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
    1f24:	8f 7e       	andi	r24, 0xEF	; 239
    1f26:	80 93 e2 00 	sts	0x00E2, r24
    1f2a:	80 91 e2 00 	lds	r24, 0x00E2
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    1f2e:	81 60       	ori	r24, 0x01	; 1
    1f30:	80 93 e2 00 	sts	0x00E2, r24
    1f34:	80 91 32 06 	lds	r24, 0x0632
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
    1f38:	88 23       	and	r24, r24
    1f3a:	11 f0       	breq	.+4      	; 0x1f40 <__vector_10+0x110>
    1f3c:	84 e0       	ldi	r24, 0x04	; 4
		  USB_DeviceState = DEVICE_STATE_Configured;
    1f3e:	07 c0       	rjmp	.+14     	; 0x1f4e <__vector_10+0x11e>
    1f40:	80 91 e3 00 	lds	r24, 0x00E3
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    1f44:	87 ff       	sbrs	r24, 7
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Addressed : DEVICE_STATE_Powered;
    1f46:	02 c0       	rjmp	.+4      	; 0x1f4c <__vector_10+0x11c>
    1f48:	83 e0       	ldi	r24, 0x03	; 3
    1f4a:	01 c0       	rjmp	.+2      	; 0x1f4e <__vector_10+0x11e>
    1f4c:	81 e0       	ldi	r24, 0x01	; 1
    1f4e:	80 93 36 06 	sts	0x0636, r24
    1f52:	9f d1       	rcall	.+830    	; 0x2292 <USB_Event_Stub>

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    1f54:	80 91 e1 00 	lds	r24, 0x00E1
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
    1f58:	83 ff       	sbrs	r24, 3
    1f5a:	22 c0       	rjmp	.+68     	; 0x1fa0 <__vector_10+0x170>
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    1f5c:	80 91 e2 00 	lds	r24, 0x00E2
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
    1f60:	83 ff       	sbrs	r24, 3
    1f62:	1e c0       	rjmp	.+60     	; 0x1fa0 <__vector_10+0x170>
    1f64:	80 91 e1 00 	lds	r24, 0x00E1
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
    1f68:	87 7f       	andi	r24, 0xF7	; 247
    1f6a:	80 93 e1 00 	sts	0x00E1, r24
    1f6e:	82 e0       	ldi	r24, 0x02	; 2
    1f70:	80 93 36 06 	sts	0x0636, r24
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
    1f74:	10 92 32 06 	sts	0x0632, r1
		USB_Device_ConfigurationNumber = 0;
    1f78:	80 91 e1 00 	lds	r24, 0x00E1
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    1f7c:	8e 7f       	andi	r24, 0xFE	; 254
    1f7e:	80 93 e1 00 	sts	0x00E1, r24
    1f82:	80 91 e2 00 	lds	r24, 0x00E2
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    1f86:	8e 7f       	andi	r24, 0xFE	; 254
    1f88:	80 93 e2 00 	sts	0x00E2, r24
    1f8c:	80 91 e2 00 	lds	r24, 0x00E2
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    1f90:	80 61       	ori	r24, 0x10	; 16
    1f92:	80 93 e2 00 	sts	0x00E2, r24
    1f96:	80 e0       	ldi	r24, 0x00	; 0
    1f98:	60 e0       	ldi	r22, 0x00	; 0
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    1f9a:	42 e0       	ldi	r20, 0x02	; 2
    1f9c:	27 de       	rcall	.-946    	; 0x1bec <Endpoint_ConfigureEndpoint_Prv>
    1f9e:	79 d1       	rcall	.+754    	; 0x2292 <USB_Event_Stub>
    1fa0:	ff 91       	pop	r31
    1fa2:	ef 91       	pop	r30

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    1fa4:	bf 91       	pop	r27
    1fa6:	af 91       	pop	r26
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
    1fa8:	9f 91       	pop	r25
    1faa:	8f 91       	pop	r24
    1fac:	7f 91       	pop	r23
    1fae:	6f 91       	pop	r22
    1fb0:	5f 91       	pop	r21
    1fb2:	4f 91       	pop	r20
    1fb4:	3f 91       	pop	r19
    1fb6:	2f 91       	pop	r18
    1fb8:	0f 90       	pop	r0
    1fba:	0f be       	out	0x3f, r0	; 63
    1fbc:	0f 90       	pop	r0
    1fbe:	1f 90       	pop	r1
    1fc0:	18 95       	reti

00001fc2 <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    1fc2:	1f 93       	push	r17
    1fc4:	cf 93       	push	r28
    1fc6:	df 93       	push	r29
    1fc8:	cd b7       	in	r28, 0x3d	; 61
    1fca:	de b7       	in	r29, 0x3e	; 62
    1fcc:	ac 97       	sbiw	r28, 0x2c	; 44
    1fce:	0f b6       	in	r0, 0x3f	; 63
    1fd0:	f8 94       	cli
    1fd2:	de bf       	out	0x3e, r29	; 62
    1fd4:	0f be       	out	0x3f, r0	; 63
    1fd6:	cd bf       	out	0x3d, r28	; 61
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    1fd8:	80 e0       	ldi	r24, 0x00	; 0
	USB_ControlRequest.bRequest      = Endpoint_Read_8();
	USB_ControlRequest.wValue        = Endpoint_Read_16_LE();
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;
    1fda:	e7 e3       	ldi	r30, 0x37	; 55
    1fdc:	f6 e0       	ldi	r31, 0x06	; 6
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    1fde:	90 91 f1 00 	lds	r25, 0x00F1

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
    1fe2:	91 93       	st	Z+, r25
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    1fe4:	8f 5f       	subi	r24, 0xFF	; 255
    1fe6:	88 30       	cpi	r24, 0x08	; 8
    1fe8:	d1 f7       	brne	.-12     	; 0x1fde <USB_Device_ProcessControlRequest+0x1c>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
    1fea:	0e 94 b6 04 	call	0x96c	; 0x96c <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1fee:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsSETUPReceived())
    1ff2:	83 ff       	sbrs	r24, 3
    1ff4:	36 c1       	rjmp	.+620    	; 0x2262 <USB_Device_ProcessControlRequest+0x2a0>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    1ff6:	80 91 37 06 	lds	r24, 0x0637

		switch (USB_ControlRequest.bRequest)
    1ffa:	20 91 38 06 	lds	r18, 0x0638
    1ffe:	25 30       	cpi	r18, 0x05	; 5
    2000:	09 f4       	brne	.+2      	; 0x2004 <USB_Device_ProcessControlRequest+0x42>
    2002:	84 c0       	rjmp	.+264    	; 0x210c <USB_Device_ProcessControlRequest+0x14a>
    2004:	26 30       	cpi	r18, 0x06	; 6
    2006:	40 f4       	brcc	.+16     	; 0x2018 <USB_Device_ProcessControlRequest+0x56>
    2008:	21 30       	cpi	r18, 0x01	; 1
    200a:	a1 f1       	breq	.+104    	; 0x2074 <USB_Device_ProcessControlRequest+0xb2>
    200c:	21 30       	cpi	r18, 0x01	; 1
    200e:	70 f0       	brcs	.+28     	; 0x202c <USB_Device_ProcessControlRequest+0x6a>
    2010:	23 30       	cpi	r18, 0x03	; 3
    2012:	09 f0       	breq	.+2      	; 0x2016 <USB_Device_ProcessControlRequest+0x54>
    2014:	26 c1       	rjmp	.+588    	; 0x2262 <USB_Device_ProcessControlRequest+0x2a0>
    2016:	2e c0       	rjmp	.+92     	; 0x2074 <USB_Device_ProcessControlRequest+0xb2>
    2018:	28 30       	cpi	r18, 0x08	; 8
    201a:	09 f4       	brne	.+2      	; 0x201e <USB_Device_ProcessControlRequest+0x5c>
    201c:	f3 c0       	rjmp	.+486    	; 0x2204 <USB_Device_ProcessControlRequest+0x242>
    201e:	29 30       	cpi	r18, 0x09	; 9
    2020:	09 f4       	brne	.+2      	; 0x2024 <USB_Device_ProcessControlRequest+0x62>
    2022:	02 c1       	rjmp	.+516    	; 0x2228 <USB_Device_ProcessControlRequest+0x266>
    2024:	26 30       	cpi	r18, 0x06	; 6
    2026:	09 f0       	breq	.+2      	; 0x202a <USB_Device_ProcessControlRequest+0x68>
    2028:	1c c1       	rjmp	.+568    	; 0x2262 <USB_Device_ProcessControlRequest+0x2a0>
    202a:	93 c0       	rjmp	.+294    	; 0x2152 <USB_Device_ProcessControlRequest+0x190>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    202c:	80 38       	cpi	r24, 0x80	; 128
    202e:	21 f0       	breq	.+8      	; 0x2038 <USB_Device_ProcessControlRequest+0x76>
    2030:	82 38       	cpi	r24, 0x82	; 130
    2032:	09 f0       	breq	.+2      	; 0x2036 <USB_Device_ProcessControlRequest+0x74>
    2034:	16 c1       	rjmp	.+556    	; 0x2262 <USB_Device_ProcessControlRequest+0x2a0>
    2036:	08 c0       	rjmp	.+16     	; 0x2048 <USB_Device_ProcessControlRequest+0x86>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
    2038:	80 91 33 06 	lds	r24, 0x0633
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    203c:	90 91 34 06 	lds	r25, 0x0634
    2040:	99 23       	and	r25, r25
    2042:	71 f0       	breq	.+28     	; 0x2060 <USB_Device_ProcessControlRequest+0x9e>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    2044:	82 60       	ori	r24, 0x02	; 2
    2046:	0c c0       	rjmp	.+24     	; 0x2060 <USB_Device_ProcessControlRequest+0x9e>
			#endif
			break;
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			#if !defined(CONTROL_ONLY_DEVICE)
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    2048:	80 91 3b 06 	lds	r24, 0x063B
    204c:	8f 70       	andi	r24, 0x0F	; 15
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    204e:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    2052:	90 91 eb 00 	lds	r25, 0x00EB

			CurrentStatus = Endpoint_IsStalled();
    2056:	81 e0       	ldi	r24, 0x01	; 1
    2058:	95 ff       	sbrs	r25, 5
    205a:	80 e0       	ldi	r24, 0x00	; 0
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    205c:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2060:	90 91 e8 00 	lds	r25, 0x00E8
    2064:	97 7f       	andi	r25, 0xF7	; 247
    2066:	90 93 e8 00 	sts	0x00E8, r25
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    206a:	80 93 f1 00 	sts	0x00F1, r24
				UEDATX = (Data >> 8);
    206e:	10 92 f1 00 	sts	0x00F1, r1
    2072:	d3 c0       	rjmp	.+422    	; 0x221a <USB_Device_ProcessControlRequest+0x258>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    2074:	88 23       	and	r24, r24
    2076:	19 f0       	breq	.+6      	; 0x207e <USB_Device_ProcessControlRequest+0xbc>
    2078:	82 30       	cpi	r24, 0x02	; 2
    207a:	09 f0       	breq	.+2      	; 0x207e <USB_Device_ProcessControlRequest+0xbc>
    207c:	f2 c0       	rjmp	.+484    	; 0x2262 <USB_Device_ProcessControlRequest+0x2a0>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    207e:	90 e0       	ldi	r25, 0x00	; 0
    2080:	8f 71       	andi	r24, 0x1F	; 31
    2082:	90 70       	andi	r25, 0x00	; 0
    2084:	00 97       	sbiw	r24, 0x00	; 0
    2086:	29 f0       	breq	.+10     	; 0x2092 <USB_Device_ProcessControlRequest+0xd0>
    2088:	82 30       	cpi	r24, 0x02	; 2
    208a:	91 05       	cpc	r25, r1
    208c:	09 f0       	breq	.+2      	; 0x2090 <USB_Device_ProcessControlRequest+0xce>
    208e:	e9 c0       	rjmp	.+466    	; 0x2262 <USB_Device_ProcessControlRequest+0x2a0>
    2090:	0b c0       	rjmp	.+22     	; 0x20a8 <USB_Device_ProcessControlRequest+0xe6>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    2092:	80 91 39 06 	lds	r24, 0x0639
    2096:	81 30       	cpi	r24, 0x01	; 1
    2098:	09 f0       	breq	.+2      	; 0x209c <USB_Device_ProcessControlRequest+0xda>
    209a:	e3 c0       	rjmp	.+454    	; 0x2262 <USB_Device_ProcessControlRequest+0x2a0>
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    209c:	23 30       	cpi	r18, 0x03	; 3
    209e:	09 f0       	breq	.+2      	; 0x20a2 <USB_Device_ProcessControlRequest+0xe0>
    20a0:	80 e0       	ldi	r24, 0x00	; 0
    20a2:	80 93 34 06 	sts	0x0634, r24
    20a6:	2c c0       	rjmp	.+88     	; 0x2100 <USB_Device_ProcessControlRequest+0x13e>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    20a8:	80 91 39 06 	lds	r24, 0x0639
    20ac:	88 23       	and	r24, r24
    20ae:	41 f5       	brne	.+80     	; 0x2100 <USB_Device_ProcessControlRequest+0x13e>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    20b0:	20 91 3b 06 	lds	r18, 0x063B
    20b4:	2f 70       	andi	r18, 0x0F	; 15

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    20b6:	09 f4       	brne	.+2      	; 0x20ba <USB_Device_ProcessControlRequest+0xf8>
    20b8:	d4 c0       	rjmp	.+424    	; 0x2262 <USB_Device_ProcessControlRequest+0x2a0>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    20ba:	20 93 e9 00 	sts	0x00E9, r18
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    20be:	80 91 eb 00 	lds	r24, 0x00EB
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    20c2:	80 ff       	sbrs	r24, 0
    20c4:	1d c0       	rjmp	.+58     	; 0x2100 <USB_Device_ProcessControlRequest+0x13e>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    20c6:	80 91 38 06 	lds	r24, 0x0638
    20ca:	83 30       	cpi	r24, 0x03	; 3
    20cc:	21 f4       	brne	.+8      	; 0x20d6 <USB_Device_ProcessControlRequest+0x114>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    20ce:	80 91 eb 00 	lds	r24, 0x00EB
    20d2:	80 62       	ori	r24, 0x20	; 32
    20d4:	13 c0       	rjmp	.+38     	; 0x20fc <USB_Device_ProcessControlRequest+0x13a>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    20d6:	80 91 eb 00 	lds	r24, 0x00EB
    20da:	80 61       	ori	r24, 0x10	; 16
    20dc:	80 93 eb 00 	sts	0x00EB, r24
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
    20e0:	81 e0       	ldi	r24, 0x01	; 1
    20e2:	90 e0       	ldi	r25, 0x00	; 0
    20e4:	02 c0       	rjmp	.+4      	; 0x20ea <USB_Device_ProcessControlRequest+0x128>
    20e6:	88 0f       	add	r24, r24
    20e8:	99 1f       	adc	r25, r25
    20ea:	2a 95       	dec	r18
    20ec:	e2 f7       	brpl	.-8      	; 0x20e6 <USB_Device_ProcessControlRequest+0x124>
    20ee:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
    20f2:	10 92 ea 00 	sts	0x00EA, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    20f6:	80 91 eb 00 	lds	r24, 0x00EB
    20fa:	88 60       	ori	r24, 0x08	; 8
    20fc:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    2100:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2104:	80 91 e8 00 	lds	r24, 0x00E8
    2108:	87 7f       	andi	r24, 0xF7	; 247
    210a:	8a c0       	rjmp	.+276    	; 0x2220 <USB_Device_ProcessControlRequest+0x25e>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    210c:	88 23       	and	r24, r24
    210e:	09 f0       	breq	.+2      	; 0x2112 <USB_Device_ProcessControlRequest+0x150>
    2110:	a8 c0       	rjmp	.+336    	; 0x2262 <USB_Device_ProcessControlRequest+0x2a0>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    2112:	10 91 39 06 	lds	r17, 0x0639
    2116:	1f 77       	andi	r17, 0x7F	; 127
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				UDADDR = (UDADDR & (1 << ADDEN)) | (Address & 0x7F);
    2118:	80 91 e3 00 	lds	r24, 0x00E3
    211c:	80 78       	andi	r24, 0x80	; 128
    211e:	81 2b       	or	r24, r17
    2120:	80 93 e3 00 	sts	0x00E3, r24
    2124:	80 91 e8 00 	lds	r24, 0x00E8
    2128:	87 7f       	andi	r24, 0xF7	; 247
    212a:	80 93 e8 00 	sts	0x00E8, r24

	USB_Device_SetDeviceAddress(DeviceAddress);

	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    212e:	cf dd       	rcall	.-1122   	; 0x1cce <Endpoint_ClearStatusStage>
    2130:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2134:	80 ff       	sbrs	r24, 0

	while (!(Endpoint_IsINReady()));
    2136:	fc cf       	rjmp	.-8      	; 0x2130 <USB_Device_ProcessControlRequest+0x16e>
    2138:	80 91 e3 00 	lds	r24, 0x00E3
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				(void)Address;

				UDADDR |= (1 << ADDEN);
    213c:	80 68       	ori	r24, 0x80	; 128
    213e:	80 93 e3 00 	sts	0x00E3, r24
    2142:	11 23       	and	r17, r17

	USB_Device_EnableDeviceAddress(DeviceAddress);

	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    2144:	11 f0       	breq	.+4      	; 0x214a <USB_Device_ProcessControlRequest+0x188>
    2146:	83 e0       	ldi	r24, 0x03	; 3
    2148:	01 c0       	rjmp	.+2      	; 0x214c <USB_Device_ProcessControlRequest+0x18a>
    214a:	82 e0       	ldi	r24, 0x02	; 2
    214c:	80 93 36 06 	sts	0x0636, r24
    2150:	88 c0       	rjmp	.+272    	; 0x2262 <USB_Device_ProcessControlRequest+0x2a0>
    2152:	80 58       	subi	r24, 0x80	; 128
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    2154:	82 30       	cpi	r24, 0x02	; 2
    2156:	08 f0       	brcs	.+2      	; 0x215a <USB_Device_ProcessControlRequest+0x198>
    2158:	84 c0       	rjmp	.+264    	; 0x2262 <USB_Device_ProcessControlRequest+0x2a0>
    215a:	80 91 39 06 	lds	r24, 0x0639
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    215e:	90 91 3a 06 	lds	r25, 0x063A
    2162:	23 e0       	ldi	r18, 0x03	; 3
    2164:	8c 3d       	cpi	r24, 0xDC	; 220
    2166:	92 07       	cpc	r25, r18
    2168:	a9 f5       	brne	.+106    	; 0x21d4 <USB_Device_ProcessControlRequest+0x212>
    216a:	83 e0       	ldi	r24, 0x03	; 3
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    216c:	8c 83       	std	Y+4, r24	; 0x04
    216e:	8a e2       	ldi	r24, 0x2A	; 42
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    2170:	8b 83       	std	Y+3, r24	; 0x03
    2172:	5f b7       	in	r21, 0x3f	; 63
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    2174:	f8 94       	cli
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    2176:	de 01       	movw	r26, r28
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
				#endif

				GCC_MEMORY_BARRIER();
    2178:	13 96       	adiw	r26, 0x03	; 3
    217a:	80 e0       	ldi	r24, 0x00	; 0
    217c:	90 e0       	ldi	r25, 0x00	; 0
    217e:	4e e0       	ldi	r20, 0x0E	; 14
			static inline void USB_Device_GetSerialString(uint16_t* const UnicodeString)
			{
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;
    2180:	61 e2       	ldi	r22, 0x21	; 33

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
    2182:	e4 2f       	mov	r30, r20
    2184:	f0 e0       	ldi	r31, 0x00	; 0
    2186:	60 93 57 00 	sts	0x0057, r22
    218a:	e4 91       	lpm	r30, Z
    218c:	80 ff       	sbrs	r24, 0

					if (SerialCharNum & 0x01)
    218e:	03 c0       	rjmp	.+6      	; 0x2196 <USB_Device_ProcessControlRequest+0x1d4>
    2190:	e2 95       	swap	r30
					{
						SerialByte >>= 4;
    2192:	ef 70       	andi	r30, 0x0F	; 15
    2194:	4f 5f       	subi	r20, 0xFF	; 255
						SigReadAddress++;
    2196:	ef 70       	andi	r30, 0x0F	; 15
					}

					SerialByte &= 0x0F;
    2198:	2e 2f       	mov	r18, r30
    219a:	30 e0       	ldi	r19, 0x00	; 0
    219c:	ea 30       	cpi	r30, 0x0A	; 10

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    219e:	18 f0       	brcs	.+6      	; 0x21a6 <USB_Device_ProcessControlRequest+0x1e4>
    21a0:	29 5c       	subi	r18, 0xC9	; 201
    21a2:	3f 4f       	sbci	r19, 0xFF	; 255
    21a4:	02 c0       	rjmp	.+4      	; 0x21aa <USB_Device_ProcessControlRequest+0x1e8>
    21a6:	20 5d       	subi	r18, 0xD0	; 208
    21a8:	3f 4f       	sbci	r19, 0xFF	; 255
    21aa:	13 96       	adiw	r26, 0x03	; 3
    21ac:	3c 93       	st	X, r19
    21ae:	2e 93       	st	-X, r18
    21b0:	12 97       	sbiw	r26, 0x02	; 2
    21b2:	01 96       	adiw	r24, 0x01	; 1
    21b4:	12 96       	adiw	r26, 0x02	; 2
    21b6:	84 31       	cpi	r24, 0x14	; 20
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    21b8:	91 05       	cpc	r25, r1
    21ba:	19 f7       	brne	.-58     	; 0x2182 <USB_Device_ProcessControlRequest+0x1c0>
    21bc:	5f bf       	out	0x3f, r21	; 63
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    21be:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    21c2:	87 7f       	andi	r24, 0xF7	; 247
    21c4:	80 93 e8 00 	sts	0x00E8, r24
    21c8:	ce 01       	movw	r24, r28

	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    21ca:	03 96       	adiw	r24, 0x03	; 3
    21cc:	6a e2       	ldi	r22, 0x2A	; 42
    21ce:	70 e0       	ldi	r23, 0x00	; 0
    21d0:	f2 db       	rcall	.-2076   	; 0x19b6 <Endpoint_Write_Control_Stream_LE>
    21d2:	12 c0       	rjmp	.+36     	; 0x21f8 <USB_Device_ProcessControlRequest+0x236>
    21d4:	60 91 3b 06 	lds	r22, 0x063B
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    21d8:	ae 01       	movw	r20, r28
    21da:	4f 5f       	subi	r20, 0xFF	; 255
    21dc:	5f 4f       	sbci	r21, 0xFF	; 255
    21de:	27 d8       	rcall	.-4018   	; 0x122e <CALLBACK_USB_GetDescriptor>
    21e0:	bc 01       	movw	r22, r24
    21e2:	00 97       	sbiw	r24, 0x00	; 0
    21e4:	09 f4       	brne	.+2      	; 0x21e8 <USB_Device_ProcessControlRequest+0x226>
    21e6:	3d c0       	rjmp	.+122    	; 0x2262 <USB_Device_ProcessControlRequest+0x2a0>
    21e8:	80 91 e8 00 	lds	r24, 0x00E8
    21ec:	87 7f       	andi	r24, 0xF7	; 247
    21ee:	80 93 e8 00 	sts	0x00E8, r24
    21f2:	89 81       	ldd	r24, Y+1	; 0x01
    21f4:	9a 81       	ldd	r25, Y+2	; 0x02
    21f6:	93 dc       	rcall	.-1754   	; 0x1b1e <Endpoint_Write_Control_PStream_LE>
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    21f8:	80 91 e8 00 	lds	r24, 0x00E8
    21fc:	8b 77       	andi	r24, 0x7B	; 123
    21fe:	80 93 e8 00 	sts	0x00E8, r24
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2202:	2f c0       	rjmp	.+94     	; 0x2262 <USB_Device_ProcessControlRequest+0x2a0>
    2204:	80 38       	cpi	r24, 0x80	; 128
    2206:	69 f5       	brne	.+90     	; 0x2262 <USB_Device_ProcessControlRequest+0x2a0>
    2208:	80 91 e8 00 	lds	r24, 0x00E8
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    220c:	87 7f       	andi	r24, 0xF7	; 247
    220e:	80 93 e8 00 	sts	0x00E8, r24
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2212:	80 91 32 06 	lds	r24, 0x0632
    2216:	80 93 f1 00 	sts	0x00F1, r24

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    221a:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    221e:	8e 77       	andi	r24, 0x7E	; 126
    2220:	80 93 e8 00 	sts	0x00E8, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2224:	54 dd       	rcall	.-1368   	; 0x1cce <Endpoint_ClearStatusStage>
    2226:	1d c0       	rjmp	.+58     	; 0x2262 <USB_Device_ProcessControlRequest+0x2a0>
    2228:	88 23       	and	r24, r24
    222a:	d9 f4       	brne	.+54     	; 0x2262 <USB_Device_ProcessControlRequest+0x2a0>
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    222c:	90 91 39 06 	lds	r25, 0x0639
    2230:	92 30       	cpi	r25, 0x02	; 2
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    2232:	b8 f4       	brcc	.+46     	; 0x2262 <USB_Device_ProcessControlRequest+0x2a0>
    2234:	80 91 e8 00 	lds	r24, 0x00E8
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    2238:	87 7f       	andi	r24, 0xF7	; 247
    223a:	80 93 e8 00 	sts	0x00E8, r24
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    223e:	90 93 32 06 	sts	0x0632, r25
    2242:	45 dd       	rcall	.-1398   	; 0x1cce <Endpoint_ClearStatusStage>
    2244:	80 91 32 06 	lds	r24, 0x0632
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    2248:	88 23       	and	r24, r24
    224a:	21 f4       	brne	.+8      	; 0x2254 <USB_Device_ProcessControlRequest+0x292>

	Endpoint_ClearStatusStage();
    224c:	80 91 e3 00 	lds	r24, 0x00E3

	if (USB_Device_ConfigurationNumber)
    2250:	87 ff       	sbrs	r24, 7
    2252:	02 c0       	rjmp	.+4      	; 0x2258 <USB_Device_ProcessControlRequest+0x296>
    2254:	84 e0       	ldi	r24, 0x04	; 4
    2256:	01 c0       	rjmp	.+2      	; 0x225a <USB_Device_ProcessControlRequest+0x298>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    2258:	81 e0       	ldi	r24, 0x01	; 1
    225a:	80 93 36 06 	sts	0x0636, r24
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    225e:	0e 94 a7 04 	call	0x94e	; 0x94e <EVENT_USB_Device_ConfigurationChanged>
    2262:	80 91 e8 00 	lds	r24, 0x00E8
    2266:	83 ff       	sbrs	r24, 3
    2268:	0a c0       	rjmp	.+20     	; 0x227e <USB_Device_ProcessControlRequest+0x2bc>

	EVENT_USB_Device_ConfigurationChanged();
    226a:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    226e:	87 7f       	andi	r24, 0xF7	; 247
    2270:	80 93 e8 00 	sts	0x00E8, r24
			default:
				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    2274:	80 91 eb 00 	lds	r24, 0x00EB
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2278:	80 62       	ori	r24, 0x20	; 32
    227a:	80 93 eb 00 	sts	0x00EB, r24
    227e:	ac 96       	adiw	r28, 0x2c	; 44
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    2280:	0f b6       	in	r0, 0x3f	; 63
    2282:	f8 94       	cli
    2284:	de bf       	out	0x3e, r29	; 62
    2286:	0f be       	out	0x3f, r0	; 63
    2288:	cd bf       	out	0x3d, r28	; 61
	{
		Endpoint_ClearSETUP();
		Endpoint_StallTransaction();
	}
}
    228a:	df 91       	pop	r29
    228c:	cf 91       	pop	r28
    228e:	1f 91       	pop	r17
    2290:	08 95       	ret

00002292 <USB_Event_Stub>:
#include "Events.h"

void USB_Event_Stub(void)
{

}
    2292:	08 95       	ret

00002294 <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    2294:	cf 93       	push	r28
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState == DEVICE_STATE_Unattached)
    2296:	80 91 36 06 	lds	r24, 0x0636
    229a:	88 23       	and	r24, r24
    229c:	a9 f0       	breq	.+42     	; 0x22c8 <USB_USBTask+0x34>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    229e:	80 91 e9 00 	lds	r24, 0x00E9
    22a2:	8f 70       	andi	r24, 0x0F	; 15
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    22a4:	90 91 ec 00 	lds	r25, 0x00EC
    22a8:	90 ff       	sbrs	r25, 0
    22aa:	02 c0       	rjmp	.+4      	; 0x22b0 <USB_USBTask+0x1c>
    22ac:	c0 e8       	ldi	r28, 0x80	; 128
    22ae:	01 c0       	rjmp	.+2      	; 0x22b2 <USB_USBTask+0x1e>
    22b0:	c0 e0       	ldi	r28, 0x00	; 0
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    22b2:	c8 2b       	or	r28, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    22b4:	10 92 e9 00 	sts	0x00E9, r1
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    22b8:	80 91 e8 00 	lds	r24, 0x00E8

	uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

	if (Endpoint_IsSETUPReceived())
    22bc:	83 ff       	sbrs	r24, 3
    22be:	01 c0       	rjmp	.+2      	; 0x22c2 <USB_USBTask+0x2e>
	  USB_Device_ProcessControlRequest();
    22c0:	80 de       	rcall	.-768    	; 0x1fc2 <USB_Device_ProcessControlRequest>
    22c2:	cf 70       	andi	r28, 0x0F	; 15
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    22c4:	c0 93 e9 00 	sts	0x00E9, r28
    22c8:	cf 91       	pop	r28
	#elif defined(USB_CAN_BE_HOST)
		USB_HostTask();
	#elif defined(USB_CAN_BE_DEVICE)
		USB_DeviceTask();
	#endif
}
    22ca:	08 95       	ret

000022cc <HID_Device_ProcessControlRequest>:
#define  __INCLUDE_FROM_HID_DRIVER
#define  __INCLUDE_FROM_HID_DEVICE_C
#include "HIDClassDevice.h"

void HID_Device_ProcessControlRequest(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
{
    22cc:	6f 92       	push	r6
    22ce:	7f 92       	push	r7
    22d0:	8f 92       	push	r8
    22d2:	9f 92       	push	r9
    22d4:	af 92       	push	r10
    22d6:	bf 92       	push	r11
    22d8:	cf 92       	push	r12
    22da:	df 92       	push	r13
    22dc:	ef 92       	push	r14
    22de:	ff 92       	push	r15
    22e0:	0f 93       	push	r16
    22e2:	1f 93       	push	r17
    22e4:	cf 93       	push	r28
    22e6:	df 93       	push	r29
    22e8:	00 d0       	rcall	.+0      	; 0x22ea <HID_Device_ProcessControlRequest+0x1e>
    22ea:	0f 92       	push	r0
    22ec:	cd b7       	in	r28, 0x3d	; 61
    22ee:	de b7       	in	r29, 0x3e	; 62
    22f0:	7c 01       	movw	r14, r24
				Endpoint_ClearStatusStage();
			}

			break;
	}
}
    22f2:	6d b6       	in	r6, 0x3d	; 61
    22f4:	7e b6       	in	r7, 0x3e	; 62
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    22f6:	80 91 e8 00 	lds	r24, 0x00E8
#define  __INCLUDE_FROM_HID_DEVICE_C
#include "HIDClassDevice.h"

void HID_Device_ProcessControlRequest(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
{
	if (!(Endpoint_IsSETUPReceived()))
    22fa:	83 ff       	sbrs	r24, 3
    22fc:	0a c1       	rjmp	.+532    	; 0x2512 <HID_Device_ProcessControlRequest+0x246>
	  return;

	if (USB_ControlRequest.wIndex != HIDInterfaceInfo->Config.InterfaceNumber)
    22fe:	f7 01       	movw	r30, r14
    2300:	80 81       	ld	r24, Z
    2302:	90 e0       	ldi	r25, 0x00	; 0
    2304:	20 91 3b 06 	lds	r18, 0x063B
    2308:	30 91 3c 06 	lds	r19, 0x063C
    230c:	28 17       	cp	r18, r24
    230e:	39 07       	cpc	r19, r25
    2310:	09 f0       	breq	.+2      	; 0x2314 <HID_Device_ProcessControlRequest+0x48>
    2312:	ff c0       	rjmp	.+510    	; 0x2512 <HID_Device_ProcessControlRequest+0x246>
	  return;

	switch (USB_ControlRequest.bRequest)
    2314:	80 91 38 06 	lds	r24, 0x0638
    2318:	83 30       	cpi	r24, 0x03	; 3
    231a:	09 f4       	brne	.+2      	; 0x231e <HID_Device_ProcessControlRequest+0x52>
    231c:	a1 c0       	rjmp	.+322    	; 0x2460 <HID_Device_ProcessControlRequest+0x194>
    231e:	84 30       	cpi	r24, 0x04	; 4
    2320:	30 f4       	brcc	.+12     	; 0x232e <HID_Device_ProcessControlRequest+0x62>
    2322:	81 30       	cpi	r24, 0x01	; 1
    2324:	71 f0       	breq	.+28     	; 0x2342 <HID_Device_ProcessControlRequest+0x76>
    2326:	82 30       	cpi	r24, 0x02	; 2
    2328:	09 f0       	breq	.+2      	; 0x232c <HID_Device_ProcessControlRequest+0x60>
    232a:	f3 c0       	rjmp	.+486    	; 0x2512 <HID_Device_ProcessControlRequest+0x246>
    232c:	d6 c0       	rjmp	.+428    	; 0x24da <HID_Device_ProcessControlRequest+0x20e>
    232e:	8a 30       	cpi	r24, 0x0A	; 10
    2330:	09 f4       	brne	.+2      	; 0x2334 <HID_Device_ProcessControlRequest+0x68>
    2332:	bb c0       	rjmp	.+374    	; 0x24aa <HID_Device_ProcessControlRequest+0x1de>
    2334:	8b 30       	cpi	r24, 0x0B	; 11
    2336:	09 f4       	brne	.+2      	; 0x233a <HID_Device_ProcessControlRequest+0x6e>
    2338:	a4 c0       	rjmp	.+328    	; 0x2482 <HID_Device_ProcessControlRequest+0x1b6>
    233a:	89 30       	cpi	r24, 0x09	; 9
    233c:	09 f0       	breq	.+2      	; 0x2340 <HID_Device_ProcessControlRequest+0x74>
    233e:	e9 c0       	rjmp	.+466    	; 0x2512 <HID_Device_ProcessControlRequest+0x246>
    2340:	51 c0       	rjmp	.+162    	; 0x23e4 <HID_Device_ProcessControlRequest+0x118>
	{
		case HID_REQ_GetReport:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    2342:	80 91 37 06 	lds	r24, 0x0637
    2346:	81 3a       	cpi	r24, 0xA1	; 161
    2348:	09 f0       	breq	.+2      	; 0x234c <HID_Device_ProcessControlRequest+0x80>
    234a:	e3 c0       	rjmp	.+454    	; 0x2512 <HID_Device_ProcessControlRequest+0x246>
    234c:	9d b6       	in	r9, 0x3d	; 61
    234e:	8e b6       	in	r8, 0x3e	; 62
			{
				uint16_t ReportSize = 0;
    2350:	1b 82       	std	Y+3, r1	; 0x03
    2352:	1a 82       	std	Y+2, r1	; 0x02
				uint8_t  ReportID   = (USB_ControlRequest.wValue & 0xFF);
    2354:	80 91 39 06 	lds	r24, 0x0639
    2358:	00 91 3a 06 	lds	r16, 0x063A
    235c:	89 83       	std	Y+1, r24	; 0x01
				uint8_t  ReportType = (USB_ControlRequest.wValue >> 8) - 1;
				uint8_t  ReportData[HIDInterfaceInfo->Config.PrevReportINBufferSize];
    235e:	f7 01       	movw	r30, r14
    2360:	40 85       	ldd	r20, Z+8	; 0x08
    2362:	8d b7       	in	r24, 0x3d	; 61
    2364:	9e b7       	in	r25, 0x3e	; 62
    2366:	84 1b       	sub	r24, r20
    2368:	91 09       	sbc	r25, r1
    236a:	0f b6       	in	r0, 0x3f	; 63
    236c:	f8 94       	cli
    236e:	9e bf       	out	0x3e, r25	; 62
    2370:	0f be       	out	0x3f, r0	; 63
    2372:	8d bf       	out	0x3d, r24	; 61
    2374:	cd b6       	in	r12, 0x3d	; 61
    2376:	de b6       	in	r13, 0x3e	; 62
    2378:	08 94       	sec
    237a:	c1 1c       	adc	r12, r1
    237c:	d1 1c       	adc	r13, r1

				memset(ReportData, 0, sizeof(ReportData));
    237e:	bc 2c       	mov	r11, r12
    2380:	ad 2c       	mov	r10, r13
    2382:	c6 01       	movw	r24, r12
    2384:	60 e0       	ldi	r22, 0x00	; 0
    2386:	70 e0       	ldi	r23, 0x00	; 0
    2388:	50 e0       	ldi	r21, 0x00	; 0
    238a:	31 d3       	rcall	.+1634   	; 0x29ee <memset>
    238c:	40 2f       	mov	r20, r16
		case HID_REQ_GetReport:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
			{
				uint16_t ReportSize = 0;
				uint8_t  ReportID   = (USB_ControlRequest.wValue & 0xFF);
				uint8_t  ReportType = (USB_ControlRequest.wValue >> 8) - 1;
    238e:	41 50       	subi	r20, 0x01	; 1
    2390:	c7 01       	movw	r24, r14
				uint8_t  ReportData[HIDInterfaceInfo->Config.PrevReportINBufferSize];

				memset(ReportData, 0, sizeof(ReportData));

				CALLBACK_HID_Device_CreateHIDReport(HIDInterfaceInfo, &ReportID, ReportType, ReportData, &ReportSize);
    2392:	be 01       	movw	r22, r28
    2394:	6f 5f       	subi	r22, 0xFF	; 255
    2396:	7f 4f       	sbci	r23, 0xFF	; 255
    2398:	96 01       	movw	r18, r12
    239a:	8e 01       	movw	r16, r28
    239c:	0e 5f       	subi	r16, 0xFE	; 254
    239e:	1f 4f       	sbci	r17, 0xFF	; 255
    23a0:	0e 94 c6 04 	call	0x98c	; 0x98c <CALLBACK_HID_Device_CreateHIDReport>
    23a4:	f7 01       	movw	r30, r14

				if (HIDInterfaceInfo->Config.PrevReportINBuffer != NULL)
    23a6:	86 81       	ldd	r24, Z+6	; 0x06
    23a8:	97 81       	ldd	r25, Z+7	; 0x07
    23aa:	00 97       	sbiw	r24, 0x00	; 0
    23ac:	21 f0       	breq	.+8      	; 0x23b6 <HID_Device_ProcessControlRequest+0xea>
    23ae:	40 85       	ldd	r20, Z+8	; 0x08
				{
					memcpy(HIDInterfaceInfo->Config.PrevReportINBuffer, ReportData,
    23b0:	b6 01       	movw	r22, r12
    23b2:	50 e0       	ldi	r21, 0x00	; 0
    23b4:	13 d3       	rcall	.+1574   	; 0x29dc <memcpy>
    23b6:	10 92 e9 00 	sts	0x00E9, r1
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    23ba:	80 91 e8 00 	lds	r24, 0x00E8
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    23be:	87 7f       	andi	r24, 0xF7	; 247
    23c0:	80 93 e8 00 	sts	0x00E8, r24
    23c4:	89 81       	ldd	r24, Y+1	; 0x01
    23c6:	88 23       	and	r24, r24

				Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

				Endpoint_ClearSETUP();

				if (ReportID)
    23c8:	11 f0       	breq	.+4      	; 0x23ce <HID_Device_ProcessControlRequest+0x102>
    23ca:	80 93 f1 00 	sts	0x00F1, r24
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    23ce:	6a 81       	ldd	r22, Y+2	; 0x02
    23d0:	7b 81       	ldd	r23, Y+3	; 0x03
				  Endpoint_Write_8(ReportID);

				Endpoint_Write_Control_Stream_LE(ReportData, ReportSize);
    23d2:	8b 2d       	mov	r24, r11
    23d4:	9a 2d       	mov	r25, r10
    23d6:	ef da       	rcall	.-2594   	; 0x19b6 <Endpoint_Write_Control_Stream_LE>
    23d8:	80 91 e8 00 	lds	r24, 0x00E8
    23dc:	8b 77       	andi	r24, 0x7B	; 123
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    23de:	80 93 e8 00 	sts	0x00E8, r24
    23e2:	3b c0       	rjmp	.+118    	; 0x245a <HID_Device_ProcessControlRequest+0x18e>
    23e4:	80 91 37 06 	lds	r24, 0x0637
    23e8:	81 32       	cpi	r24, 0x21	; 33
				Endpoint_ClearOUT();
			}

			break;
		case HID_REQ_SetReport:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    23ea:	09 f0       	breq	.+2      	; 0x23ee <HID_Device_ProcessControlRequest+0x122>
    23ec:	92 c0       	rjmp	.+292    	; 0x2512 <HID_Device_ProcessControlRequest+0x246>
    23ee:	9d b6       	in	r9, 0x3d	; 61
    23f0:	8e b6       	in	r8, 0x3e	; 62
    23f2:	00 91 3d 06 	lds	r16, 0x063D
    23f6:	10 91 3e 06 	lds	r17, 0x063E
			{
				uint16_t ReportSize = USB_ControlRequest.wLength;
    23fa:	c0 90 39 06 	lds	r12, 0x0639
    23fe:	d0 90 3a 06 	lds	r13, 0x063A
				uint8_t  ReportID   = (USB_ControlRequest.wValue & 0xFF);
    2402:	8d b7       	in	r24, 0x3d	; 61
    2404:	9e b7       	in	r25, 0x3e	; 62
    2406:	80 1b       	sub	r24, r16
				uint8_t  ReportType = (USB_ControlRequest.wValue >> 8) - 1;
				uint8_t  ReportData[ReportSize];
    2408:	91 0b       	sbc	r25, r17
    240a:	0f b6       	in	r0, 0x3f	; 63
    240c:	f8 94       	cli
    240e:	9e bf       	out	0x3e, r25	; 62
    2410:	0f be       	out	0x3f, r0	; 63
    2412:	8d bf       	out	0x3d, r24	; 61
    2414:	ad b6       	in	r10, 0x3d	; 61
    2416:	be b6       	in	r11, 0x3e	; 62
    2418:	08 94       	sec
    241a:	a1 1c       	adc	r10, r1
    241c:	b1 1c       	adc	r11, r1
    241e:	80 91 e8 00 	lds	r24, 0x00E8
    2422:	87 7f       	andi	r24, 0xF7	; 247
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2424:	80 93 e8 00 	sts	0x00E8, r24
    2428:	c5 01       	movw	r24, r10
    242a:	b8 01       	movw	r22, r16
    242c:	2a db       	rcall	.-2476   	; 0x1a82 <Endpoint_Read_Control_Stream_LE>

				Endpoint_ClearSETUP();
				Endpoint_Read_Control_Stream_LE(ReportData, ReportSize);
    242e:	80 91 e8 00 	lds	r24, 0x00E8
    2432:	8e 77       	andi	r24, 0x7E	; 126
    2434:	80 93 e8 00 	sts	0x00E8, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2438:	81 e0       	ldi	r24, 0x01	; 1
    243a:	90 e0       	ldi	r25, 0x00	; 0
    243c:	cc 20       	and	r12, r12
    243e:	11 f4       	brne	.+4      	; 0x2444 <HID_Device_ProcessControlRequest+0x178>
				Endpoint_ClearIN();

				CALLBACK_HID_Device_ProcessHIDReport(HIDInterfaceInfo, ReportID, ReportType,
    2440:	80 e0       	ldi	r24, 0x00	; 0
    2442:	90 e0       	ldi	r25, 0x00	; 0
    2444:	4d 2d       	mov	r20, r13
    2446:	41 50       	subi	r20, 0x01	; 1
    2448:	95 01       	movw	r18, r10
    244a:	28 0f       	add	r18, r24
		case HID_REQ_SetReport:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
			{
				uint16_t ReportSize = USB_ControlRequest.wLength;
				uint8_t  ReportID   = (USB_ControlRequest.wValue & 0xFF);
				uint8_t  ReportType = (USB_ControlRequest.wValue >> 8) - 1;
    244c:	39 1f       	adc	r19, r25
    244e:	08 1b       	sub	r16, r24

				Endpoint_ClearSETUP();
				Endpoint_Read_Control_Stream_LE(ReportData, ReportSize);
				Endpoint_ClearIN();

				CALLBACK_HID_Device_ProcessHIDReport(HIDInterfaceInfo, ReportID, ReportType,
    2450:	19 0b       	sbc	r17, r25
    2452:	c7 01       	movw	r24, r14
    2454:	6c 2d       	mov	r22, r12
    2456:	0e 94 5c 08 	call	0x10b8	; 0x10b8 <CALLBACK_HID_Device_ProcessHIDReport>
    245a:	9d be       	out	0x3d, r9	; 61
    245c:	8e be       	out	0x3e, r8	; 62
    245e:	59 c0       	rjmp	.+178    	; 0x2512 <HID_Device_ProcessControlRequest+0x246>
    2460:	80 91 37 06 	lds	r24, 0x0637
    2464:	81 3a       	cpi	r24, 0xA1	; 161
    2466:	09 f0       	breq	.+2      	; 0x246a <HID_Device_ProcessControlRequest+0x19e>
				                                     &ReportData[ReportID ? 1 : 0], ReportSize - (ReportID ? 1 : 0));
			}

			break;
		case HID_REQ_GetProtocol:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    2468:	54 c0       	rjmp	.+168    	; 0x2512 <HID_Device_ProcessControlRequest+0x246>
    246a:	80 91 e8 00 	lds	r24, 0x00E8
    246e:	87 7f       	andi	r24, 0xF7	; 247
    2470:	80 93 e8 00 	sts	0x00E8, r24
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2474:	80 91 e8 00 	lds	r24, 0x00E8
    2478:	80 ff       	sbrs	r24, 0
    247a:	fc cf       	rjmp	.-8      	; 0x2474 <HID_Device_ProcessControlRequest+0x1a8>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    247c:	f7 01       	movw	r30, r14
    247e:	81 85       	ldd	r24, Z+9	; 0x09
			{
				Endpoint_ClearSETUP();
				while (!(Endpoint_IsINReady()));
    2480:	40 c0       	rjmp	.+128    	; 0x2502 <HID_Device_ProcessControlRequest+0x236>
    2482:	80 91 37 06 	lds	r24, 0x0637
				Endpoint_Write_8(HIDInterfaceInfo->State.UsingReportProtocol);
    2486:	81 32       	cpi	r24, 0x21	; 33
    2488:	09 f0       	breq	.+2      	; 0x248c <HID_Device_ProcessControlRequest+0x1c0>
				Endpoint_ClearStatusStage();
			}

			break;
		case HID_REQ_SetProtocol:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    248a:	43 c0       	rjmp	.+134    	; 0x2512 <HID_Device_ProcessControlRequest+0x246>
    248c:	80 91 e8 00 	lds	r24, 0x00E8
    2490:	87 7f       	andi	r24, 0xF7	; 247
    2492:	80 93 e8 00 	sts	0x00E8, r24
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2496:	1b dc       	rcall	.-1994   	; 0x1cce <Endpoint_ClearStatusStage>
    2498:	90 91 39 06 	lds	r25, 0x0639
    249c:	81 e0       	ldi	r24, 0x01	; 1
			{
				Endpoint_ClearSETUP();
				Endpoint_ClearStatusStage();
    249e:	99 23       	and	r25, r25
    24a0:	09 f4       	brne	.+2      	; 0x24a4 <HID_Device_ProcessControlRequest+0x1d8>

				HIDInterfaceInfo->State.UsingReportProtocol = ((USB_ControlRequest.wValue & 0xFF) != 0x00);
    24a2:	80 e0       	ldi	r24, 0x00	; 0
    24a4:	f7 01       	movw	r30, r14
    24a6:	81 87       	std	Z+9, r24	; 0x09
    24a8:	34 c0       	rjmp	.+104    	; 0x2512 <HID_Device_ProcessControlRequest+0x246>
    24aa:	80 91 37 06 	lds	r24, 0x0637
    24ae:	81 32       	cpi	r24, 0x21	; 33
    24b0:	81 f5       	brne	.+96     	; 0x2512 <HID_Device_ProcessControlRequest+0x246>
    24b2:	80 91 e8 00 	lds	r24, 0x00E8
			}

			break;
		case HID_REQ_SetIdle:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    24b6:	87 7f       	andi	r24, 0xF7	; 247
    24b8:	80 93 e8 00 	sts	0x00E8, r24
    24bc:	08 dc       	rcall	.-2032   	; 0x1cce <Endpoint_ClearStatusStage>
    24be:	80 91 39 06 	lds	r24, 0x0639
    24c2:	90 91 3a 06 	lds	r25, 0x063A
			{
				Endpoint_ClearSETUP();
				Endpoint_ClearStatusStage();
    24c6:	80 70       	andi	r24, 0x00	; 0
    24c8:	36 e0       	ldi	r19, 0x06	; 6

				HIDInterfaceInfo->State.IdleCount = ((USB_ControlRequest.wValue & 0xFF00) >> 6);
    24ca:	96 95       	lsr	r25
    24cc:	87 95       	ror	r24
    24ce:	3a 95       	dec	r19
    24d0:	e1 f7       	brne	.-8      	; 0x24ca <HID_Device_ProcessControlRequest+0x1fe>
    24d2:	f7 01       	movw	r30, r14
    24d4:	95 87       	std	Z+13, r25	; 0x0d
    24d6:	84 87       	std	Z+12, r24	; 0x0c
    24d8:	1c c0       	rjmp	.+56     	; 0x2512 <HID_Device_ProcessControlRequest+0x246>
    24da:	80 91 37 06 	lds	r24, 0x0637
    24de:	81 3a       	cpi	r24, 0xA1	; 161
    24e0:	c1 f4       	brne	.+48     	; 0x2512 <HID_Device_ProcessControlRequest+0x246>
    24e2:	80 91 e8 00 	lds	r24, 0x00E8
			}

			break;
		case HID_REQ_GetIdle:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    24e6:	87 7f       	andi	r24, 0xF7	; 247
    24e8:	80 93 e8 00 	sts	0x00E8, r24
    24ec:	80 91 e8 00 	lds	r24, 0x00E8
    24f0:	80 ff       	sbrs	r24, 0
    24f2:	fc cf       	rjmp	.-8      	; 0x24ec <HID_Device_ProcessControlRequest+0x220>
    24f4:	f7 01       	movw	r30, r14
    24f6:	84 85       	ldd	r24, Z+12	; 0x0c
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    24f8:	95 85       	ldd	r25, Z+13	; 0x0d
    24fa:	96 95       	lsr	r25
			{
				Endpoint_ClearSETUP();
				while (!(Endpoint_IsINReady()));
    24fc:	87 95       	ror	r24
    24fe:	96 95       	lsr	r25
				Endpoint_Write_8(HIDInterfaceInfo->State.IdleCount >> 2);
    2500:	87 95       	ror	r24
    2502:	80 93 f1 00 	sts	0x00F1, r24
    2506:	80 91 e8 00 	lds	r24, 0x00E8
    250a:	8e 77       	andi	r24, 0x7E	; 126
    250c:	80 93 e8 00 	sts	0x00E8, r24
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    2510:	de db       	rcall	.-2116   	; 0x1cce <Endpoint_ClearStatusStage>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2512:	0f b6       	in	r0, 0x3f	; 63
    2514:	f8 94       	cli
    2516:	7e be       	out	0x3e, r7	; 62
    2518:	0f be       	out	0x3f, r0	; 63
    251a:	6d be       	out	0x3d, r6	; 61
				Endpoint_ClearIN();
				Endpoint_ClearStatusStage();
    251c:	0f 90       	pop	r0
    251e:	0f 90       	pop	r0
			}

			break;
	}
}
    2520:	0f 90       	pop	r0
    2522:	df 91       	pop	r29
    2524:	cf 91       	pop	r28
    2526:	1f 91       	pop	r17
    2528:	0f 91       	pop	r16
    252a:	ff 90       	pop	r15
    252c:	ef 90       	pop	r14
    252e:	df 90       	pop	r13
    2530:	cf 90       	pop	r12
    2532:	bf 90       	pop	r11
    2534:	af 90       	pop	r10
    2536:	9f 90       	pop	r9
    2538:	8f 90       	pop	r8
    253a:	7f 90       	pop	r7
    253c:	6f 90       	pop	r6
    253e:	08 95       	ret

00002540 <HID_Device_ConfigureEndpoints>:
    2540:	cf 93       	push	r28
    2542:	df 93       	push	r29
    2544:	fc 01       	movw	r30, r24
    2546:	09 96       	adiw	r24, 0x09	; 9
    2548:	dc 01       	movw	r26, r24
    254a:	87 e0       	ldi	r24, 0x07	; 7
    254c:	ed 01       	movw	r28, r26

bool HID_Device_ConfigureEndpoints(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
{
	memset(&HIDInterfaceInfo->State, 0x00, sizeof(HIDInterfaceInfo->State));
    254e:	19 92       	st	Y+, r1
    2550:	8a 95       	dec	r24
    2552:	e9 f7       	brne	.-6      	; 0x254e <HID_Device_ConfigureEndpoints+0xe>
	HIDInterfaceInfo->State.UsingReportProtocol = true;
    2554:	81 e0       	ldi	r24, 0x01	; 1
    2556:	81 87       	std	Z+9, r24	; 0x09
	HIDInterfaceInfo->State.IdleCount           = 500;
    2558:	84 ef       	ldi	r24, 0xF4	; 244
    255a:	91 e0       	ldi	r25, 0x01	; 1
    255c:	95 87       	std	Z+13, r25	; 0x0d
    255e:	84 87       	std	Z+12, r24	; 0x0c

	HIDInterfaceInfo->Config.ReportINEndpoint.Type = EP_TYPE_INTERRUPT;
    2560:	83 e0       	ldi	r24, 0x03	; 3
    2562:	84 83       	std	Z+4, r24	; 0x04

	if (!(Endpoint_ConfigureEndpointTable(&HIDInterfaceInfo->Config.ReportINEndpoint, 1)))
    2564:	cf 01       	movw	r24, r30
    2566:	01 96       	adiw	r24, 0x01	; 1
    2568:	61 e0       	ldi	r22, 0x01	; 1
    256a:	75 db       	rcall	.-2326   	; 0x1c56 <Endpoint_ConfigureEndpointTable>
    256c:	df 91       	pop	r29
	  return false;

	return true;
}
    256e:	cf 91       	pop	r28
    2570:	08 95       	ret

00002572 <HID_Device_USBTask>:
    2572:	4f 92       	push	r4

void HID_Device_USBTask(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
{
    2574:	5f 92       	push	r5
    2576:	6f 92       	push	r6
    2578:	7f 92       	push	r7
    257a:	8f 92       	push	r8
    257c:	9f 92       	push	r9
    257e:	af 92       	push	r10
    2580:	bf 92       	push	r11
    2582:	cf 92       	push	r12
    2584:	df 92       	push	r13
    2586:	ef 92       	push	r14
    2588:	ff 92       	push	r15
    258a:	0f 93       	push	r16
    258c:	1f 93       	push	r17
    258e:	cf 93       	push	r28
    2590:	df 93       	push	r29
    2592:	00 d0       	rcall	.+0      	; 0x2594 <HID_Device_USBTask+0x22>
    2594:	0f 92       	push	r0
    2596:	cd b7       	in	r28, 0x3d	; 61
    2598:	de b7       	in	r29, 0x3e	; 62
    259a:	7c 01       	movw	r14, r24
			Endpoint_ClearIN();
		}

		HIDInterfaceInfo->State.PrevFrameNum = USB_Device_GetFrameNumber();
	}
}
    259c:	4d b6       	in	r4, 0x3d	; 61
    259e:	5e b6       	in	r5, 0x3e	; 62
	return true;
}

void HID_Device_USBTask(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
{
	if (USB_DeviceState != DEVICE_STATE_Configured)
    25a0:	80 91 36 06 	lds	r24, 0x0636
    25a4:	84 30       	cpi	r24, 0x04	; 4
    25a6:	09 f0       	breq	.+2      	; 0x25aa <HID_Device_USBTask+0x38>
    25a8:	92 c0       	rjmp	.+292    	; 0x26ce <HID_Device_USBTask+0x15c>
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    25aa:	80 91 e4 00 	lds	r24, 0x00E4
    25ae:	90 91 e5 00 	lds	r25, 0x00E5
	  return;

	if (HIDInterfaceInfo->State.PrevFrameNum == USB_Device_GetFrameNumber())
    25b2:	f7 01       	movw	r30, r14
    25b4:	22 85       	ldd	r18, Z+10	; 0x0a
    25b6:	33 85       	ldd	r19, Z+11	; 0x0b
    25b8:	28 17       	cp	r18, r24
    25ba:	39 07       	cpc	r19, r25
    25bc:	09 f4       	brne	.+2      	; 0x25c0 <HID_Device_USBTask+0x4e>
    25be:	87 c0       	rjmp	.+270    	; 0x26ce <HID_Device_USBTask+0x15c>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    25c0:	81 81       	ldd	r24, Z+1	; 0x01
    25c2:	8f 70       	andi	r24, 0x0F	; 15
    25c4:	80 93 e9 00 	sts	0x00E9, r24
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    25c8:	80 91 e8 00 	lds	r24, 0x00E8
		#endif
	}

	Endpoint_SelectEndpoint(HIDInterfaceInfo->Config.ReportINEndpoint.Address);

	if (Endpoint_IsReadWriteAllowed())
    25cc:	85 ff       	sbrs	r24, 5
    25ce:	7f c0       	rjmp	.+254    	; 0x26ce <HID_Device_USBTask+0x15c>
    25d0:	7d b6       	in	r7, 0x3d	; 61
    25d2:	6e b6       	in	r6, 0x3e	; 62
	{
		uint8_t  ReportINData[HIDInterfaceInfo->Config.PrevReportINBufferSize];
    25d4:	40 85       	ldd	r20, Z+8	; 0x08
    25d6:	8d b7       	in	r24, 0x3d	; 61
    25d8:	9e b7       	in	r25, 0x3e	; 62
    25da:	84 1b       	sub	r24, r20
    25dc:	91 09       	sbc	r25, r1
    25de:	0f b6       	in	r0, 0x3f	; 63
    25e0:	f8 94       	cli
    25e2:	9e bf       	out	0x3e, r25	; 62
    25e4:	0f be       	out	0x3f, r0	; 63
    25e6:	8d bf       	out	0x3d, r24	; 61
    25e8:	0d b7       	in	r16, 0x3d	; 61
    25ea:	1e b7       	in	r17, 0x3e	; 62
    25ec:	0f 5f       	subi	r16, 0xFF	; 255
    25ee:	1f 4f       	sbci	r17, 0xFF	; 255
		uint8_t  ReportID     = 0;
    25f0:	19 82       	std	Y+1, r1	; 0x01
		uint16_t ReportINSize = 0;
    25f2:	1b 82       	std	Y+3, r1	; 0x03
    25f4:	1a 82       	std	Y+2, r1	; 0x02

		memset(ReportINData, 0, sizeof(ReportINData));
    25f6:	b0 2e       	mov	r11, r16
    25f8:	a1 2e       	mov	r10, r17
    25fa:	c8 01       	movw	r24, r16
    25fc:	60 e0       	ldi	r22, 0x00	; 0
    25fe:	70 e0       	ldi	r23, 0x00	; 0
    2600:	50 e0       	ldi	r21, 0x00	; 0
    2602:	f5 d1       	rcall	.+1002   	; 0x29ee <memset>
    2604:	c7 01       	movw	r24, r14

		bool ForceSend         = CALLBACK_HID_Device_CreateHIDReport(HIDInterfaceInfo, &ReportID, HID_REPORT_ITEM_In,
    2606:	be 01       	movw	r22, r28
    2608:	6f 5f       	subi	r22, 0xFF	; 255
    260a:	7f 4f       	sbci	r23, 0xFF	; 255
    260c:	40 e0       	ldi	r20, 0x00	; 0
    260e:	98 01       	movw	r18, r16
    2610:	8e 01       	movw	r16, r28
    2612:	0e 5f       	subi	r16, 0xFE	; 254
    2614:	1f 4f       	sbci	r17, 0xFF	; 255
    2616:	0e 94 c6 04 	call	0x98c	; 0x98c <CALLBACK_HID_Device_CreateHIDReport>
    261a:	18 2f       	mov	r17, r24
    261c:	f7 01       	movw	r30, r14
		                                                             ReportINData, &ReportINSize);
		bool StatesChanged     = false;
		bool IdlePeriodElapsed = (HIDInterfaceInfo->State.IdleCount && !(HIDInterfaceInfo->State.IdleMSRemaining));
    261e:	84 85       	ldd	r24, Z+12	; 0x0c
    2620:	95 85       	ldd	r25, Z+13	; 0x0d
    2622:	00 97       	sbiw	r24, 0x00	; 0
    2624:	59 f0       	breq	.+22     	; 0x263c <HID_Device_USBTask+0xca>
    2626:	81 e0       	ldi	r24, 0x01	; 1
	  return false;

	return true;
}

void HID_Device_USBTask(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
    2628:	90 e0       	ldi	r25, 0x00	; 0
    262a:	26 85       	ldd	r18, Z+14	; 0x0e
    262c:	37 85       	ldd	r19, Z+15	; 0x0f
    262e:	21 15       	cp	r18, r1
    2630:	31 05       	cpc	r19, r1
    2632:	11 f0       	breq	.+4      	; 0x2638 <HID_Device_USBTask+0xc6>
    2634:	80 e0       	ldi	r24, 0x00	; 0
    2636:	90 e0       	ldi	r25, 0x00	; 0
    2638:	4c 01       	movw	r8, r24
		memset(ReportINData, 0, sizeof(ReportINData));

		bool ForceSend         = CALLBACK_HID_Device_CreateHIDReport(HIDInterfaceInfo, &ReportID, HID_REPORT_ITEM_In,
		                                                             ReportINData, &ReportINSize);
		bool StatesChanged     = false;
		bool IdlePeriodElapsed = (HIDInterfaceInfo->State.IdleCount && !(HIDInterfaceInfo->State.IdleMSRemaining));
    263a:	02 c0       	rjmp	.+4      	; 0x2640 <HID_Device_USBTask+0xce>
    263c:	88 24       	eor	r8, r8
    263e:	99 24       	eor	r9, r9
    2640:	f7 01       	movw	r30, r14

		if (HIDInterfaceInfo->Config.PrevReportINBuffer != NULL)
    2642:	c6 80       	ldd	r12, Z+6	; 0x06
    2644:	d7 80       	ldd	r13, Z+7	; 0x07
    2646:	c1 14       	cp	r12, r1
    2648:	d1 04       	cpc	r13, r1
    264a:	91 f0       	breq	.+36     	; 0x2670 <HID_Device_USBTask+0xfe>
    264c:	4a 81       	ldd	r20, Y+2	; 0x02
		{
			StatesChanged = (memcmp(ReportINData, HIDInterfaceInfo->Config.PrevReportINBuffer, ReportINSize) != 0);
    264e:	5b 81       	ldd	r21, Y+3	; 0x03
    2650:	8b 2d       	mov	r24, r11
    2652:	9a 2d       	mov	r25, r10
    2654:	b6 01       	movw	r22, r12
    2656:	b5 d1       	rcall	.+874    	; 0x29c2 <memcmp>
    2658:	01 e0       	ldi	r16, 0x01	; 1
    265a:	00 97       	sbiw	r24, 0x00	; 0
    265c:	09 f4       	brne	.+2      	; 0x2660 <HID_Device_USBTask+0xee>
    265e:	00 e0       	ldi	r16, 0x00	; 0
    2660:	f7 01       	movw	r30, r14
    2662:	40 85       	ldd	r20, Z+8	; 0x08
			memcpy(HIDInterfaceInfo->Config.PrevReportINBuffer, ReportINData, HIDInterfaceInfo->Config.PrevReportINBufferSize);
    2664:	c6 01       	movw	r24, r12
    2666:	6b 2d       	mov	r22, r11
    2668:	7a 2d       	mov	r23, r10
    266a:	50 e0       	ldi	r21, 0x00	; 0
    266c:	b7 d1       	rcall	.+878    	; 0x29dc <memcpy>
    266e:	01 c0       	rjmp	.+2      	; 0x2672 <HID_Device_USBTask+0x100>
    2670:	00 e0       	ldi	r16, 0x00	; 0
    2672:	8a 81       	ldd	r24, Y+2	; 0x02
    2674:	9b 81       	ldd	r25, Y+3	; 0x03

		memset(ReportINData, 0, sizeof(ReportINData));

		bool ForceSend         = CALLBACK_HID_Device_CreateHIDReport(HIDInterfaceInfo, &ReportID, HID_REPORT_ITEM_In,
		                                                             ReportINData, &ReportINSize);
		bool StatesChanged     = false;
    2676:	00 97       	sbiw	r24, 0x00	; 0
		{
			StatesChanged = (memcmp(ReportINData, HIDInterfaceInfo->Config.PrevReportINBuffer, ReportINSize) != 0);
			memcpy(HIDInterfaceInfo->Config.PrevReportINBuffer, ReportINData, HIDInterfaceInfo->Config.PrevReportINBufferSize);
		}

		if (ReportINSize && (ForceSend || StatesChanged || IdlePeriodElapsed))
    2678:	09 f1       	breq	.+66     	; 0x26bc <HID_Device_USBTask+0x14a>
    267a:	11 23       	and	r17, r17
    267c:	29 f4       	brne	.+10     	; 0x2688 <HID_Device_USBTask+0x116>
    267e:	00 23       	and	r16, r16
    2680:	19 f4       	brne	.+6      	; 0x2688 <HID_Device_USBTask+0x116>
    2682:	81 14       	cp	r8, r1
    2684:	91 04       	cpc	r9, r1
    2686:	d1 f0       	breq	.+52     	; 0x26bc <HID_Device_USBTask+0x14a>
    2688:	f7 01       	movw	r30, r14
    268a:	84 85       	ldd	r24, Z+12	; 0x0c
    268c:	95 85       	ldd	r25, Z+13	; 0x0d
		{
			HIDInterfaceInfo->State.IdleMSRemaining = HIDInterfaceInfo->State.IdleCount;
    268e:	97 87       	std	Z+15, r25	; 0x0f
    2690:	86 87       	std	Z+14, r24	; 0x0e
    2692:	81 81       	ldd	r24, Z+1	; 0x01
    2694:	8f 70       	andi	r24, 0x0F	; 15
    2696:	80 93 e9 00 	sts	0x00E9, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    269a:	89 81       	ldd	r24, Y+1	; 0x01
    269c:	88 23       	and	r24, r24
    269e:	11 f0       	breq	.+4      	; 0x26a4 <HID_Device_USBTask+0x132>

			Endpoint_SelectEndpoint(HIDInterfaceInfo->Config.ReportINEndpoint.Address);

			if (ReportID)
    26a0:	80 93 f1 00 	sts	0x00F1, r24
    26a4:	6a 81       	ldd	r22, Y+2	; 0x02
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    26a6:	7b 81       	ldd	r23, Y+3	; 0x03
    26a8:	8b 2d       	mov	r24, r11
			  Endpoint_Write_8(ReportID);

			Endpoint_Write_Stream_LE(ReportINData, ReportINSize, NULL);
    26aa:	9a 2d       	mov	r25, r10
    26ac:	40 e0       	ldi	r20, 0x00	; 0
    26ae:	50 e0       	ldi	r21, 0x00	; 0
    26b0:	32 d9       	rcall	.-3484   	; 0x1916 <Endpoint_Write_Stream_LE>
    26b2:	80 91 e8 00 	lds	r24, 0x00E8
    26b6:	8e 77       	andi	r24, 0x7E	; 126
    26b8:	80 93 e8 00 	sts	0x00E8, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    26bc:	80 91 e4 00 	lds	r24, 0x00E4
    26c0:	90 91 e5 00 	lds	r25, 0x00E5
    26c4:	f7 01       	movw	r30, r14
    26c6:	93 87       	std	Z+11, r25	; 0x0b
    26c8:	82 87       	std	Z+10, r24	; 0x0a
    26ca:	7d be       	out	0x3d, r7	; 61

			Endpoint_ClearIN();
		}

		HIDInterfaceInfo->State.PrevFrameNum = USB_Device_GetFrameNumber();
    26cc:	6e be       	out	0x3e, r6	; 62
    26ce:	0f b6       	in	r0, 0x3f	; 63
    26d0:	f8 94       	cli
    26d2:	5e be       	out	0x3e, r5	; 62
    26d4:	0f be       	out	0x3f, r0	; 63
	}
}
    26d6:	4d be       	out	0x3d, r4	; 61
    26d8:	0f 90       	pop	r0
    26da:	0f 90       	pop	r0
    26dc:	0f 90       	pop	r0
    26de:	df 91       	pop	r29
    26e0:	cf 91       	pop	r28
    26e2:	1f 91       	pop	r17
    26e4:	0f 91       	pop	r16
    26e6:	ff 90       	pop	r15
    26e8:	ef 90       	pop	r14
    26ea:	df 90       	pop	r13
    26ec:	cf 90       	pop	r12
    26ee:	bf 90       	pop	r11
    26f0:	af 90       	pop	r10
    26f2:	9f 90       	pop	r9
    26f4:	8f 90       	pop	r8
    26f6:	7f 90       	pop	r7
    26f8:	6f 90       	pop	r6
    26fa:	5f 90       	pop	r5
    26fc:	4f 90       	pop	r4
    26fe:	08 95       	ret

00002700 <__divsf3>:
    2700:	0c d0       	rcall	.+24     	; 0x271a <__divsf3x>
    2702:	ae c0       	rjmp	.+348    	; 0x2860 <__fp_round>
    2704:	a6 d0       	rcall	.+332    	; 0x2852 <__fp_pscB>
    2706:	40 f0       	brcs	.+16     	; 0x2718 <__divsf3+0x18>
    2708:	9d d0       	rcall	.+314    	; 0x2844 <__fp_pscA>
    270a:	30 f0       	brcs	.+12     	; 0x2718 <__divsf3+0x18>
    270c:	21 f4       	brne	.+8      	; 0x2716 <__divsf3+0x16>
    270e:	5f 3f       	cpi	r21, 0xFF	; 255
    2710:	19 f0       	breq	.+6      	; 0x2718 <__divsf3+0x18>
    2712:	8f c0       	rjmp	.+286    	; 0x2832 <__fp_inf>
    2714:	51 11       	cpse	r21, r1
    2716:	d8 c0       	rjmp	.+432    	; 0x28c8 <__fp_szero>
    2718:	92 c0       	rjmp	.+292    	; 0x283e <__fp_nan>

0000271a <__divsf3x>:
    271a:	b3 d0       	rcall	.+358    	; 0x2882 <__fp_split3>
    271c:	98 f3       	brcs	.-26     	; 0x2704 <__divsf3+0x4>

0000271e <__divsf3_pse>:
    271e:	99 23       	and	r25, r25
    2720:	c9 f3       	breq	.-14     	; 0x2714 <__divsf3+0x14>
    2722:	55 23       	and	r21, r21
    2724:	b1 f3       	breq	.-20     	; 0x2712 <__divsf3+0x12>
    2726:	95 1b       	sub	r25, r21
    2728:	55 0b       	sbc	r21, r21
    272a:	bb 27       	eor	r27, r27
    272c:	aa 27       	eor	r26, r26
    272e:	62 17       	cp	r22, r18
    2730:	73 07       	cpc	r23, r19
    2732:	84 07       	cpc	r24, r20
    2734:	38 f0       	brcs	.+14     	; 0x2744 <__divsf3_pse+0x26>
    2736:	9f 5f       	subi	r25, 0xFF	; 255
    2738:	5f 4f       	sbci	r21, 0xFF	; 255
    273a:	22 0f       	add	r18, r18
    273c:	33 1f       	adc	r19, r19
    273e:	44 1f       	adc	r20, r20
    2740:	aa 1f       	adc	r26, r26
    2742:	a9 f3       	breq	.-22     	; 0x272e <__divsf3_pse+0x10>
    2744:	33 d0       	rcall	.+102    	; 0x27ac <__divsf3_pse+0x8e>
    2746:	0e 2e       	mov	r0, r30
    2748:	3a f0       	brmi	.+14     	; 0x2758 <__divsf3_pse+0x3a>
    274a:	e0 e8       	ldi	r30, 0x80	; 128
    274c:	30 d0       	rcall	.+96     	; 0x27ae <__divsf3_pse+0x90>
    274e:	91 50       	subi	r25, 0x01	; 1
    2750:	50 40       	sbci	r21, 0x00	; 0
    2752:	e6 95       	lsr	r30
    2754:	00 1c       	adc	r0, r0
    2756:	ca f7       	brpl	.-14     	; 0x274a <__divsf3_pse+0x2c>
    2758:	29 d0       	rcall	.+82     	; 0x27ac <__divsf3_pse+0x8e>
    275a:	fe 2f       	mov	r31, r30
    275c:	27 d0       	rcall	.+78     	; 0x27ac <__divsf3_pse+0x8e>
    275e:	66 0f       	add	r22, r22
    2760:	77 1f       	adc	r23, r23
    2762:	88 1f       	adc	r24, r24
    2764:	bb 1f       	adc	r27, r27
    2766:	26 17       	cp	r18, r22
    2768:	37 07       	cpc	r19, r23
    276a:	48 07       	cpc	r20, r24
    276c:	ab 07       	cpc	r26, r27
    276e:	b0 e8       	ldi	r27, 0x80	; 128
    2770:	09 f0       	breq	.+2      	; 0x2774 <__divsf3_pse+0x56>
    2772:	bb 0b       	sbc	r27, r27
    2774:	80 2d       	mov	r24, r0
    2776:	bf 01       	movw	r22, r30
    2778:	ff 27       	eor	r31, r31
    277a:	93 58       	subi	r25, 0x83	; 131
    277c:	5f 4f       	sbci	r21, 0xFF	; 255
    277e:	2a f0       	brmi	.+10     	; 0x278a <__divsf3_pse+0x6c>
    2780:	9e 3f       	cpi	r25, 0xFE	; 254
    2782:	51 05       	cpc	r21, r1
    2784:	68 f0       	brcs	.+26     	; 0x27a0 <__divsf3_pse+0x82>
    2786:	55 c0       	rjmp	.+170    	; 0x2832 <__fp_inf>
    2788:	9f c0       	rjmp	.+318    	; 0x28c8 <__fp_szero>
    278a:	5f 3f       	cpi	r21, 0xFF	; 255
    278c:	ec f3       	brlt	.-6      	; 0x2788 <__divsf3_pse+0x6a>
    278e:	98 3e       	cpi	r25, 0xE8	; 232
    2790:	dc f3       	brlt	.-10     	; 0x2788 <__divsf3_pse+0x6a>
    2792:	86 95       	lsr	r24
    2794:	77 95       	ror	r23
    2796:	67 95       	ror	r22
    2798:	b7 95       	ror	r27
    279a:	f7 95       	ror	r31
    279c:	9f 5f       	subi	r25, 0xFF	; 255
    279e:	c9 f7       	brne	.-14     	; 0x2792 <__divsf3_pse+0x74>
    27a0:	88 0f       	add	r24, r24
    27a2:	91 1d       	adc	r25, r1
    27a4:	96 95       	lsr	r25
    27a6:	87 95       	ror	r24
    27a8:	97 f9       	bld	r25, 7
    27aa:	08 95       	ret
    27ac:	e1 e0       	ldi	r30, 0x01	; 1
    27ae:	66 0f       	add	r22, r22
    27b0:	77 1f       	adc	r23, r23
    27b2:	88 1f       	adc	r24, r24
    27b4:	bb 1f       	adc	r27, r27
    27b6:	62 17       	cp	r22, r18
    27b8:	73 07       	cpc	r23, r19
    27ba:	84 07       	cpc	r24, r20
    27bc:	ba 07       	cpc	r27, r26
    27be:	20 f0       	brcs	.+8      	; 0x27c8 <__divsf3_pse+0xaa>
    27c0:	62 1b       	sub	r22, r18
    27c2:	73 0b       	sbc	r23, r19
    27c4:	84 0b       	sbc	r24, r20
    27c6:	ba 0b       	sbc	r27, r26
    27c8:	ee 1f       	adc	r30, r30
    27ca:	88 f7       	brcc	.-30     	; 0x27ae <__divsf3_pse+0x90>
    27cc:	e0 95       	com	r30
    27ce:	08 95       	ret

000027d0 <__fixsfsi>:
    27d0:	04 d0       	rcall	.+8      	; 0x27da <__fixunssfsi>
    27d2:	68 94       	set
    27d4:	b1 11       	cpse	r27, r1
    27d6:	78 c0       	rjmp	.+240    	; 0x28c8 <__fp_szero>
    27d8:	08 95       	ret

000027da <__fixunssfsi>:
    27da:	5b d0       	rcall	.+182    	; 0x2892 <__fp_splitA>
    27dc:	88 f0       	brcs	.+34     	; 0x2800 <__fixunssfsi+0x26>
    27de:	9f 57       	subi	r25, 0x7F	; 127
    27e0:	90 f0       	brcs	.+36     	; 0x2806 <__fixunssfsi+0x2c>
    27e2:	b9 2f       	mov	r27, r25
    27e4:	99 27       	eor	r25, r25
    27e6:	b7 51       	subi	r27, 0x17	; 23
    27e8:	a0 f0       	brcs	.+40     	; 0x2812 <__fixunssfsi+0x38>
    27ea:	d1 f0       	breq	.+52     	; 0x2820 <__fixunssfsi+0x46>
    27ec:	66 0f       	add	r22, r22
    27ee:	77 1f       	adc	r23, r23
    27f0:	88 1f       	adc	r24, r24
    27f2:	99 1f       	adc	r25, r25
    27f4:	1a f0       	brmi	.+6      	; 0x27fc <__fixunssfsi+0x22>
    27f6:	ba 95       	dec	r27
    27f8:	c9 f7       	brne	.-14     	; 0x27ec <__fixunssfsi+0x12>
    27fa:	12 c0       	rjmp	.+36     	; 0x2820 <__fixunssfsi+0x46>
    27fc:	b1 30       	cpi	r27, 0x01	; 1
    27fe:	81 f0       	breq	.+32     	; 0x2820 <__fixunssfsi+0x46>
    2800:	62 d0       	rcall	.+196    	; 0x28c6 <__fp_zero>
    2802:	b1 e0       	ldi	r27, 0x01	; 1
    2804:	08 95       	ret
    2806:	5f c0       	rjmp	.+190    	; 0x28c6 <__fp_zero>
    2808:	67 2f       	mov	r22, r23
    280a:	78 2f       	mov	r23, r24
    280c:	88 27       	eor	r24, r24
    280e:	b8 5f       	subi	r27, 0xF8	; 248
    2810:	39 f0       	breq	.+14     	; 0x2820 <__fixunssfsi+0x46>
    2812:	b9 3f       	cpi	r27, 0xF9	; 249
    2814:	cc f3       	brlt	.-14     	; 0x2808 <__fixunssfsi+0x2e>
    2816:	86 95       	lsr	r24
    2818:	77 95       	ror	r23
    281a:	67 95       	ror	r22
    281c:	b3 95       	inc	r27
    281e:	d9 f7       	brne	.-10     	; 0x2816 <__fixunssfsi+0x3c>
    2820:	3e f4       	brtc	.+14     	; 0x2830 <__fixunssfsi+0x56>
    2822:	90 95       	com	r25
    2824:	80 95       	com	r24
    2826:	70 95       	com	r23
    2828:	61 95       	neg	r22
    282a:	7f 4f       	sbci	r23, 0xFF	; 255
    282c:	8f 4f       	sbci	r24, 0xFF	; 255
    282e:	9f 4f       	sbci	r25, 0xFF	; 255
    2830:	08 95       	ret

00002832 <__fp_inf>:
    2832:	97 f9       	bld	r25, 7
    2834:	9f 67       	ori	r25, 0x7F	; 127
    2836:	80 e8       	ldi	r24, 0x80	; 128
    2838:	70 e0       	ldi	r23, 0x00	; 0
    283a:	60 e0       	ldi	r22, 0x00	; 0
    283c:	08 95       	ret

0000283e <__fp_nan>:
    283e:	9f ef       	ldi	r25, 0xFF	; 255
    2840:	80 ec       	ldi	r24, 0xC0	; 192
    2842:	08 95       	ret

00002844 <__fp_pscA>:
    2844:	00 24       	eor	r0, r0
    2846:	0a 94       	dec	r0
    2848:	16 16       	cp	r1, r22
    284a:	17 06       	cpc	r1, r23
    284c:	18 06       	cpc	r1, r24
    284e:	09 06       	cpc	r0, r25
    2850:	08 95       	ret

00002852 <__fp_pscB>:
    2852:	00 24       	eor	r0, r0
    2854:	0a 94       	dec	r0
    2856:	12 16       	cp	r1, r18
    2858:	13 06       	cpc	r1, r19
    285a:	14 06       	cpc	r1, r20
    285c:	05 06       	cpc	r0, r21
    285e:	08 95       	ret

00002860 <__fp_round>:
    2860:	09 2e       	mov	r0, r25
    2862:	03 94       	inc	r0
    2864:	00 0c       	add	r0, r0
    2866:	11 f4       	brne	.+4      	; 0x286c <__fp_round+0xc>
    2868:	88 23       	and	r24, r24
    286a:	52 f0       	brmi	.+20     	; 0x2880 <__fp_round+0x20>
    286c:	bb 0f       	add	r27, r27
    286e:	40 f4       	brcc	.+16     	; 0x2880 <__fp_round+0x20>
    2870:	bf 2b       	or	r27, r31
    2872:	11 f4       	brne	.+4      	; 0x2878 <__fp_round+0x18>
    2874:	60 ff       	sbrs	r22, 0
    2876:	04 c0       	rjmp	.+8      	; 0x2880 <__fp_round+0x20>
    2878:	6f 5f       	subi	r22, 0xFF	; 255
    287a:	7f 4f       	sbci	r23, 0xFF	; 255
    287c:	8f 4f       	sbci	r24, 0xFF	; 255
    287e:	9f 4f       	sbci	r25, 0xFF	; 255
    2880:	08 95       	ret

00002882 <__fp_split3>:
    2882:	57 fd       	sbrc	r21, 7
    2884:	90 58       	subi	r25, 0x80	; 128
    2886:	44 0f       	add	r20, r20
    2888:	55 1f       	adc	r21, r21
    288a:	59 f0       	breq	.+22     	; 0x28a2 <__fp_splitA+0x10>
    288c:	5f 3f       	cpi	r21, 0xFF	; 255
    288e:	71 f0       	breq	.+28     	; 0x28ac <__fp_splitA+0x1a>
    2890:	47 95       	ror	r20

00002892 <__fp_splitA>:
    2892:	88 0f       	add	r24, r24
    2894:	97 fb       	bst	r25, 7
    2896:	99 1f       	adc	r25, r25
    2898:	61 f0       	breq	.+24     	; 0x28b2 <__fp_splitA+0x20>
    289a:	9f 3f       	cpi	r25, 0xFF	; 255
    289c:	79 f0       	breq	.+30     	; 0x28bc <__fp_splitA+0x2a>
    289e:	87 95       	ror	r24
    28a0:	08 95       	ret
    28a2:	12 16       	cp	r1, r18
    28a4:	13 06       	cpc	r1, r19
    28a6:	14 06       	cpc	r1, r20
    28a8:	55 1f       	adc	r21, r21
    28aa:	f2 cf       	rjmp	.-28     	; 0x2890 <__fp_split3+0xe>
    28ac:	46 95       	lsr	r20
    28ae:	f1 df       	rcall	.-30     	; 0x2892 <__fp_splitA>
    28b0:	08 c0       	rjmp	.+16     	; 0x28c2 <__fp_splitA+0x30>
    28b2:	16 16       	cp	r1, r22
    28b4:	17 06       	cpc	r1, r23
    28b6:	18 06       	cpc	r1, r24
    28b8:	99 1f       	adc	r25, r25
    28ba:	f1 cf       	rjmp	.-30     	; 0x289e <__fp_splitA+0xc>
    28bc:	86 95       	lsr	r24
    28be:	71 05       	cpc	r23, r1
    28c0:	61 05       	cpc	r22, r1
    28c2:	08 94       	sec
    28c4:	08 95       	ret

000028c6 <__fp_zero>:
    28c6:	e8 94       	clt

000028c8 <__fp_szero>:
    28c8:	bb 27       	eor	r27, r27
    28ca:	66 27       	eor	r22, r22
    28cc:	77 27       	eor	r23, r23
    28ce:	cb 01       	movw	r24, r22
    28d0:	97 f9       	bld	r25, 7
    28d2:	08 95       	ret

000028d4 <__mulsf3>:
    28d4:	0b d0       	rcall	.+22     	; 0x28ec <__mulsf3x>
    28d6:	c4 cf       	rjmp	.-120    	; 0x2860 <__fp_round>
    28d8:	b5 df       	rcall	.-150    	; 0x2844 <__fp_pscA>
    28da:	28 f0       	brcs	.+10     	; 0x28e6 <__mulsf3+0x12>
    28dc:	ba df       	rcall	.-140    	; 0x2852 <__fp_pscB>
    28de:	18 f0       	brcs	.+6      	; 0x28e6 <__mulsf3+0x12>
    28e0:	95 23       	and	r25, r21
    28e2:	09 f0       	breq	.+2      	; 0x28e6 <__mulsf3+0x12>
    28e4:	a6 cf       	rjmp	.-180    	; 0x2832 <__fp_inf>
    28e6:	ab cf       	rjmp	.-170    	; 0x283e <__fp_nan>
    28e8:	11 24       	eor	r1, r1
    28ea:	ee cf       	rjmp	.-36     	; 0x28c8 <__fp_szero>

000028ec <__mulsf3x>:
    28ec:	ca df       	rcall	.-108    	; 0x2882 <__fp_split3>
    28ee:	a0 f3       	brcs	.-24     	; 0x28d8 <__mulsf3+0x4>

000028f0 <__mulsf3_pse>:
    28f0:	95 9f       	mul	r25, r21
    28f2:	d1 f3       	breq	.-12     	; 0x28e8 <__mulsf3+0x14>
    28f4:	95 0f       	add	r25, r21
    28f6:	50 e0       	ldi	r21, 0x00	; 0
    28f8:	55 1f       	adc	r21, r21
    28fa:	62 9f       	mul	r22, r18
    28fc:	f0 01       	movw	r30, r0
    28fe:	72 9f       	mul	r23, r18
    2900:	bb 27       	eor	r27, r27
    2902:	f0 0d       	add	r31, r0
    2904:	b1 1d       	adc	r27, r1
    2906:	63 9f       	mul	r22, r19
    2908:	aa 27       	eor	r26, r26
    290a:	f0 0d       	add	r31, r0
    290c:	b1 1d       	adc	r27, r1
    290e:	aa 1f       	adc	r26, r26
    2910:	64 9f       	mul	r22, r20
    2912:	66 27       	eor	r22, r22
    2914:	b0 0d       	add	r27, r0
    2916:	a1 1d       	adc	r26, r1
    2918:	66 1f       	adc	r22, r22
    291a:	82 9f       	mul	r24, r18
    291c:	22 27       	eor	r18, r18
    291e:	b0 0d       	add	r27, r0
    2920:	a1 1d       	adc	r26, r1
    2922:	62 1f       	adc	r22, r18
    2924:	73 9f       	mul	r23, r19
    2926:	b0 0d       	add	r27, r0
    2928:	a1 1d       	adc	r26, r1
    292a:	62 1f       	adc	r22, r18
    292c:	83 9f       	mul	r24, r19
    292e:	a0 0d       	add	r26, r0
    2930:	61 1d       	adc	r22, r1
    2932:	22 1f       	adc	r18, r18
    2934:	74 9f       	mul	r23, r20
    2936:	33 27       	eor	r19, r19
    2938:	a0 0d       	add	r26, r0
    293a:	61 1d       	adc	r22, r1
    293c:	23 1f       	adc	r18, r19
    293e:	84 9f       	mul	r24, r20
    2940:	60 0d       	add	r22, r0
    2942:	21 1d       	adc	r18, r1
    2944:	82 2f       	mov	r24, r18
    2946:	76 2f       	mov	r23, r22
    2948:	6a 2f       	mov	r22, r26
    294a:	11 24       	eor	r1, r1
    294c:	9f 57       	subi	r25, 0x7F	; 127
    294e:	50 40       	sbci	r21, 0x00	; 0
    2950:	8a f0       	brmi	.+34     	; 0x2974 <__mulsf3_pse+0x84>
    2952:	e1 f0       	breq	.+56     	; 0x298c <__mulsf3_pse+0x9c>
    2954:	88 23       	and	r24, r24
    2956:	4a f0       	brmi	.+18     	; 0x296a <__mulsf3_pse+0x7a>
    2958:	ee 0f       	add	r30, r30
    295a:	ff 1f       	adc	r31, r31
    295c:	bb 1f       	adc	r27, r27
    295e:	66 1f       	adc	r22, r22
    2960:	77 1f       	adc	r23, r23
    2962:	88 1f       	adc	r24, r24
    2964:	91 50       	subi	r25, 0x01	; 1
    2966:	50 40       	sbci	r21, 0x00	; 0
    2968:	a9 f7       	brne	.-22     	; 0x2954 <__mulsf3_pse+0x64>
    296a:	9e 3f       	cpi	r25, 0xFE	; 254
    296c:	51 05       	cpc	r21, r1
    296e:	70 f0       	brcs	.+28     	; 0x298c <__mulsf3_pse+0x9c>
    2970:	60 cf       	rjmp	.-320    	; 0x2832 <__fp_inf>
    2972:	aa cf       	rjmp	.-172    	; 0x28c8 <__fp_szero>
    2974:	5f 3f       	cpi	r21, 0xFF	; 255
    2976:	ec f3       	brlt	.-6      	; 0x2972 <__mulsf3_pse+0x82>
    2978:	98 3e       	cpi	r25, 0xE8	; 232
    297a:	dc f3       	brlt	.-10     	; 0x2972 <__mulsf3_pse+0x82>
    297c:	86 95       	lsr	r24
    297e:	77 95       	ror	r23
    2980:	67 95       	ror	r22
    2982:	b7 95       	ror	r27
    2984:	f7 95       	ror	r31
    2986:	e7 95       	ror	r30
    2988:	9f 5f       	subi	r25, 0xFF	; 255
    298a:	c1 f7       	brne	.-16     	; 0x297c <__mulsf3_pse+0x8c>
    298c:	fe 2b       	or	r31, r30
    298e:	88 0f       	add	r24, r24
    2990:	91 1d       	adc	r25, r1
    2992:	96 95       	lsr	r25
    2994:	87 95       	ror	r24
    2996:	97 f9       	bld	r25, 7
    2998:	08 95       	ret

0000299a <__udivmodhi4>:
    299a:	aa 1b       	sub	r26, r26
    299c:	bb 1b       	sub	r27, r27
    299e:	51 e1       	ldi	r21, 0x11	; 17
    29a0:	07 c0       	rjmp	.+14     	; 0x29b0 <__udivmodhi4_ep>

000029a2 <__udivmodhi4_loop>:
    29a2:	aa 1f       	adc	r26, r26
    29a4:	bb 1f       	adc	r27, r27
    29a6:	a6 17       	cp	r26, r22
    29a8:	b7 07       	cpc	r27, r23
    29aa:	10 f0       	brcs	.+4      	; 0x29b0 <__udivmodhi4_ep>
    29ac:	a6 1b       	sub	r26, r22
    29ae:	b7 0b       	sbc	r27, r23

000029b0 <__udivmodhi4_ep>:
    29b0:	88 1f       	adc	r24, r24
    29b2:	99 1f       	adc	r25, r25
    29b4:	5a 95       	dec	r21
    29b6:	a9 f7       	brne	.-22     	; 0x29a2 <__udivmodhi4_loop>
    29b8:	80 95       	com	r24
    29ba:	90 95       	com	r25
    29bc:	bc 01       	movw	r22, r24
    29be:	cd 01       	movw	r24, r26
    29c0:	08 95       	ret

000029c2 <memcmp>:
    29c2:	fb 01       	movw	r30, r22
    29c4:	dc 01       	movw	r26, r24
    29c6:	04 c0       	rjmp	.+8      	; 0x29d0 <memcmp+0xe>
    29c8:	8d 91       	ld	r24, X+
    29ca:	01 90       	ld	r0, Z+
    29cc:	80 19       	sub	r24, r0
    29ce:	21 f4       	brne	.+8      	; 0x29d8 <memcmp+0x16>
    29d0:	41 50       	subi	r20, 0x01	; 1
    29d2:	50 40       	sbci	r21, 0x00	; 0
    29d4:	c8 f7       	brcc	.-14     	; 0x29c8 <memcmp+0x6>
    29d6:	88 1b       	sub	r24, r24
    29d8:	99 0b       	sbc	r25, r25
    29da:	08 95       	ret

000029dc <memcpy>:
    29dc:	fb 01       	movw	r30, r22
    29de:	dc 01       	movw	r26, r24
    29e0:	02 c0       	rjmp	.+4      	; 0x29e6 <memcpy+0xa>
    29e2:	01 90       	ld	r0, Z+
    29e4:	0d 92       	st	X+, r0
    29e6:	41 50       	subi	r20, 0x01	; 1
    29e8:	50 40       	sbci	r21, 0x00	; 0
    29ea:	d8 f7       	brcc	.-10     	; 0x29e2 <memcpy+0x6>
    29ec:	08 95       	ret

000029ee <memset>:
    29ee:	dc 01       	movw	r26, r24
    29f0:	01 c0       	rjmp	.+2      	; 0x29f4 <memset+0x6>
    29f2:	6d 93       	st	X+, r22
    29f4:	41 50       	subi	r20, 0x01	; 1
    29f6:	50 40       	sbci	r21, 0x00	; 0
    29f8:	e0 f7       	brcc	.-8      	; 0x29f2 <memset+0x4>
    29fa:	08 95       	ret

000029fc <_exit>:
    29fc:	f8 94       	cli

000029fe <__stop_program>:
    29fe:	ff cf       	rjmp	.-2      	; 0x29fe <__stop_program>
